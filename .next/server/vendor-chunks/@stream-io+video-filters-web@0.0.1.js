"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io+video-filters-web@0.0.1";
exports.ids = ["vendor-chunks/@stream-io+video-filters-web@0.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@stream-io+video-filters-web@0.0.1/node_modules/@stream-io/video-filters-web/dist/index.es.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stream-io+video-filters-web@0.0.1/node_modules/@stream-io/video-filters-web/dist/index.es.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SegmentationLevel: () => (/* binding */ SegmentationLevel),\n/* harmony export */   createRenderer: () => (/* binding */ createRenderer),\n/* harmony export */   isPlatformSupported: () => (/* binding */ isPlatformSupported),\n/* harmony export */   loadTFLite: () => (/* binding */ loadTFLite)\n/* harmony export */ });\n/* harmony import */ var wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasm-feature-detect */ \"(ssr)/./node_modules/.pnpm/wasm-feature-detect@1.6.1/node_modules/wasm-feature-detect/dist/esm/index.js\");\n\n\n/**\n * Checks if the current platform is a mobile device.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n */\nconst isMobile = () => /Mobi/i.test(navigator.userAgent);\n/**\n * Runs a check to see if the current platform supports\n * the necessary APIs required for the video filters.\n */\nconst isPlatformSupported = async () => typeof document !== 'undefined' &&\n    typeof window !== 'undefined' &&\n    typeof navigator !== 'undefined' &&\n    !isMobile() && // we don't support mobile devices yet due to performance issues\n    typeof WebAssembly !== 'undefined' &&\n    !!window.WebGL2RenderingContext && // WebGL2 is required for the video filters\n    !!document.createElement('canvas').getContext('webgl2') &&\n    (await (0,wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__.simd)()); // SIMD is required for the wasm module\n\n/**\n * Use it along with boyswan.glsl-literal VSCode extension\n * to get GLSL syntax highlighting.\n * https://marketplace.visualstudio.com/items?itemName=boyswan.glsl-literal\n *\n * On VSCode OSS, boyswan.glsl-literal requires slevesque.shader extension\n * to be installed as well.\n * https://marketplace.visualstudio.com/items?itemName=slevesque.shader\n */\nconst glsl = String.raw;\nfunction createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer) {\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord');\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    return program;\n}\nfunction createProgram(gl, vertexShader, fragmentShader) {\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(`Could not link WebGL program: ${gl.getProgramInfoLog(program)}`);\n    }\n    return program;\n}\nfunction compileShader(gl, shaderType, shaderSource) {\n    const shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);\n    }\n    return shader;\n}\nfunction createTexture(gl, internalformat, width, height, minFilter = gl.NEAREST, magFilter = gl.NEAREST) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n    gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);\n    return texture;\n}\nasync function readPixelsAsync(gl, x, y, width, height, format, type, dest) {\n    const buf = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, format, type, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);\n    gl.deleteBuffer(buf);\n    return dest;\n}\nasync function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    const res = await clientWaitAsync(gl, sync);\n    gl.deleteSync(sync);\n    if (res !== gl.WAIT_FAILED) {\n        gl.bindBuffer(target, buffer);\n        gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);\n        gl.bindBuffer(target, null);\n    }\n}\nfunction clientWaitAsync(gl, sync) {\n    return new Promise((resolve) => {\n        function test() {\n            const res = gl.clientWaitSync(sync, 0, 0);\n            if (res === gl.WAIT_FAILED) {\n                resolve(res);\n                return;\n            }\n            if (res === gl.TIMEOUT_EXPIRED) {\n                setTimeout(test);\n                return;\n            }\n            resolve(res);\n        }\n        setTimeout(test);\n    });\n}\n\nfunction buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const blurPass = buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel);\n    const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas);\n    function render() {\n        blurPass.render();\n        blendPass.render();\n    }\n    function updateCoverage(coverage) {\n        blendPass.updateCoverage(coverage);\n    }\n    function cleanUp() {\n        blendPass.cleanUp();\n        blurPass.cleanUp();\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\nfunction buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const weights = blurLevel === 'low'\n        ? [0.227027027, 0.1545945946, 0.1016216216, 0.0340540541, 0.0142162162]\n        : blurLevel === 'medium'\n            ? [0.327027027, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162]\n            : [0.627027027, 0.3445945946, 0.2216216216, 0.0540540541, 0.0162162162];\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform vec2 u_texelSize;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    const float offset[5] = float[](0.0, 1.0, 2.0, 3.0, 4.0);\n    const float weight[5] = float[](\n      ${weights.join(',')}\n    );\n\n    void main() {\n      vec4 centerColor = texture(u_inputFrame, v_texCoord);\n      float personMask = texture(u_personMask, v_texCoord).a;\n\n      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);\n\n      for (int i = 1; i < 5; i++) {\n        vec2 offset = vec2(offset[i]) * u_texelSize;\n\n        vec2 texCoord = v_texCoord + offset;\n        frameColor += texture(u_inputFrame, texCoord)\n           * weight[i]\n           * (1.0 - texture(u_personMask, texCoord).a);\n\n        texCoord = v_texCoord - offset;\n        frameColor += texture(u_inputFrame, texCoord)\n          * weight[i]\n          * (1.0 - texture(u_personMask, texCoord).a);\n      }\n      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);\n    }\n  `;\n    const scale = 0.5;\n    const outputWidth = canvas.width * scale;\n    const outputHeight = canvas.height * scale;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const texture1 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const texture2 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const frameBuffer1 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);\n    const frameBuffer2 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);\n    gl.useProgram(program);\n    gl.uniform1i(personMaskLocation, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.uniform1i(inputFrameLocation, 0);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        for (let i = 0; i < 3; i++) {\n            gl.uniform2f(texelSizeLocation, 0, texelHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, texture1);\n            gl.uniform1i(inputFrameLocation, 2);\n            gl.uniform2f(texelSizeLocation, texelWidth, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.bindTexture(gl.TEXTURE_2D, texture2);\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer2);\n        gl.deleteFramebuffer(frameBuffer1);\n        gl.deleteTexture(texture2);\n        gl.deleteTexture(texture1);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return {\n        render,\n        cleanUp,\n    };\n}\nfunction buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_blurredInputFrame;\n    uniform vec2 u_coverage;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      vec3 color = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(mix(blurredColor, color, personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const blurredInputFrame = gl.getUniformLocation(program, 'u_blurredInputFrame');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform1i(blurredInputFrame, 2);\n    gl.uniform2f(coverageLocation, 0, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function cleanUp() {\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\n\nfunction buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    uniform vec2 u_backgroundScale;\n    uniform vec2 u_backgroundOffset;\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n    out vec2 v_backgroundCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_background;\n    uniform vec2 u_coverage;\n    uniform float u_lightWrapping;\n    uniform float u_blendMode;\n\n    in vec2 v_texCoord;\n    in vec2 v_backgroundCoord;\n\n    out vec4 outColor;\n\n    vec3 screen(vec3 a, vec3 b) {\n      return 1.0 - (1.0 - a) * (1.0 - b);\n    }\n\n    vec3 linearDodge(vec3 a, vec3 b) {\n      return a + b;\n    }\n\n    void main() {\n      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);\n      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;\n\n      frameColor = u_blendMode * linearDodge(frameColor, lightWrap)\n        + (1.0 - u_blendMode) * screen(frameColor, lightWrap);\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const outputRatio = outputWidth / outputHeight;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const backgroundScaleLocation = gl.getUniformLocation(program, 'u_backgroundScale');\n    const backgroundOffsetLocation = gl.getUniformLocation(program, 'u_backgroundOffset');\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const backgroundLocation = gl.getUniformLocation(program, 'u_background');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    const lightWrappingLocation = gl.getUniformLocation(program, 'u_lightWrapping');\n    const blendModeLocation = gl.getUniformLocation(program, 'u_blendMode');\n    gl.useProgram(program);\n    gl.uniform2f(backgroundScaleLocation, 1, 1);\n    gl.uniform2f(backgroundOffsetLocation, 0, 0);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform2f(coverageLocation, 0, 1);\n    gl.uniform1f(lightWrappingLocation, 0);\n    gl.uniform1f(blendModeLocation, 0);\n    let backgroundTexture = null;\n    // TODO Find a better to handle background being loaded\n    if (backgroundImage?.complete) {\n        updateBackgroundImage(backgroundImage);\n    }\n    else if (backgroundImage) {\n        backgroundImage.onload = () => {\n            updateBackgroundImage(backgroundImage);\n        };\n    }\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        if (backgroundTexture !== null) {\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);\n            // TODO Handle correctly the background not loaded yet\n            gl.uniform1i(backgroundLocation, 2);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateBackgroundImage(bgImage) {\n        backgroundTexture = createTexture(gl, gl.RGBA8, bgImage.naturalWidth, bgImage.naturalHeight, \n        // @ts-expect-error types are incomplete\n        gl.LINEAR, gl.LINEAR);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bgImage.naturalWidth, bgImage.naturalHeight, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);\n        let xOffset = 0;\n        let yOffset = 0;\n        let backgroundWidth = bgImage.naturalWidth;\n        let backgroundHeight = bgImage.naturalHeight;\n        const backgroundRatio = backgroundWidth / backgroundHeight;\n        if (backgroundRatio < outputRatio) {\n            backgroundHeight = backgroundWidth / outputRatio;\n            yOffset = (bgImage.naturalHeight - backgroundHeight) / 2;\n        }\n        else {\n            backgroundWidth = backgroundHeight * outputRatio;\n            xOffset = (bgImage.naturalWidth - backgroundWidth) / 2;\n        }\n        const xScale = backgroundWidth / bgImage.naturalWidth;\n        const yScale = backgroundHeight / bgImage.naturalHeight;\n        xOffset /= bgImage.naturalWidth;\n        yOffset /= bgImage.naturalHeight;\n        gl.uniform2f(backgroundScaleLocation, xScale, yScale);\n        gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function updateLightWrapping(lightWrapping) {\n        gl.useProgram(program);\n        gl.uniform1f(lightWrappingLocation, lightWrapping);\n    }\n    function updateBlendMode(blendMode) {\n        gl.useProgram(program);\n        gl.uniform1f(blendModeLocation, blendMode === 'screen' ? 0 : 1);\n    }\n    function cleanUp() {\n        gl.deleteTexture(backgroundTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        updateLightWrapping,\n        updateBlendMode,\n        cleanUp,\n    };\n}\n\nfunction buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, inputTexture, outputTexture, canvas, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);\n      return exp((x * x) * coeff);\n    }\n\n    void main() {\n      vec2 centerCoord = v_texCoord;\n      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;\n      float newVal = 0.0;\n\n      float spaceWeight = 0.0;\n      float colorWeight = 0.0;\n      float totalWeight = 0.0;\n\n      // Subsample kernel space.\n      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {\n        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {\n          vec2 shift = vec2(j, i) * u_texelSize;\n          vec2 coord = vec2(centerCoord + shift);\n          vec3 frameColor = texture(u_inputFrame, coord).rgb;\n          float outVal = texture(u_segmentationMask, coord).a;\n\n          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);\n          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);\n          totalWeight += spaceWeight * colorWeight;\n\n          newVal += spaceWeight * colorWeight * outVal;\n        }\n      }\n      newVal /= totalWeight;\n\n      outColor = vec4(vec3(0.0), newVal);\n    }\n  `;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const segmentationMaskLocation = gl.getUniformLocation(program, 'u_segmentationMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const stepLocation = gl.getUniformLocation(program, 'u_step');\n    const radiusLocation = gl.getUniformLocation(program, 'u_radius');\n    const offsetLocation = gl.getUniformLocation(program, 'u_offset');\n    const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel');\n    const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor');\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(segmentationMaskLocation, 1);\n    gl.uniform2f(texelSizeLocation, texelWidth, texelHeight);\n    // Ensures default values are configured to prevent infinite\n    // loop in fragment shader\n    updateSigmaSpace(0);\n    updateSigmaColor(0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateSigmaSpace(sigmaSpace) {\n        sigmaSpace *= Math.max(outputWidth / segmentationWidth, outputHeight / segmentationHeight);\n        const kSparsityFactor = 0.66; // Higher is sparser.\n        const step = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor);\n        const radius = sigmaSpace;\n        const offset = step > 1 ? step * 0.5 : 0;\n        const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace;\n        gl.useProgram(program);\n        gl.uniform1f(stepLocation, step);\n        gl.uniform1f(radiusLocation, radius);\n        gl.uniform1f(offsetLocation, offset);\n        gl.uniform1f(sigmaTexelLocation, sigmaTexel);\n    }\n    function updateSigmaColor(sigmaColor) {\n        gl.useProgram(program);\n        gl.uniform1f(sigmaColorLocation, sigmaColor);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, updateSigmaSpace, updateSigmaColor, cleanUp };\n}\n\nfunction buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n    uniform sampler2D u_inputFrame;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      outColor = texture(u_inputFrame, v_texCoord);\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4;\n    const { width: outputWidth, height: outputHeight } = segmentationConfig;\n    const outputPixelCount = outputWidth * outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    const outputPixels = new Uint8Array(outputPixelCount * 4);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        // Downloads pixels asynchronously from GPU while rendering the current frame.\n        // The pixels will be available in the next frame render which results\n        // in offsets in the segmentation output but increases the frame rate.\n        readPixelsAsync(gl, 0, 0, outputWidth, outputHeight, gl.RGBA, gl.UNSIGNED_BYTE, outputPixels);\n        for (let i = 0; i < outputPixelCount; i++) {\n            const tfliteIndex = tfliteInputMemoryOffset + i * 3;\n            const outputIndex = i * 4;\n            tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255;\n            tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255;\n            tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255;\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(outputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, outputTexture, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputSegmentation;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;\n      float shift = max(segmentation.r, segmentation.g);\n      float backgroundExp = exp(segmentation.r - shift);\n      float personExp = exp(segmentation.g - shift);\n      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputLocation = gl.getUniformLocation(program, 'u_inputSegmentation');\n    const inputTexture = createTexture(gl, gl.RG32F, segmentationWidth, segmentationHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputLocation, 1);\n    function render() {\n        gl.viewport(0, 0, segmentationWidth, segmentationHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, segmentationWidth, segmentationHeight, gl.RG, gl.FLOAT, tflite.HEAPF32, tfliteOutputMemoryOffset);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(inputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildWebGL2Pipeline(videoSource, backgroundImage, blurLevel, backgroundFilter, canvas, tflite, segmentationConfig) {\n    const gl = canvas.getContext('webgl2');\n    if (!gl)\n        throw new Error('WebGL2 is not supported');\n    const { width: frameWidth, height: frameHeight } = videoSource;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n    out vec2 v_texCoord;\n\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const vertexArray = gl.createVertexArray();\n    gl.bindVertexArray(vertexArray);\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    const texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    // We don't use texStorage2D here because texImage2D seems faster\n    // to upload video texture than texSubImage2D even though the latter\n    // is supposed to be the recommended way:\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_texstorage_to_create_textures\n    const inputFrameTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    // TODO Rename segmentation and person mask to be more specific\n    const segmentationTexture = createTexture(gl, gl.RGBA8, segmentationWidth, segmentationHeight);\n    const personMaskTexture = createTexture(gl, gl.RGBA8, frameWidth, frameHeight);\n    const resizingStage = buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig);\n    const loadSegmentationStage = buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationTexture, segmentationConfig);\n    const jointBilateralFilterStage = buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, segmentationTexture, personMaskTexture, canvas, segmentationConfig);\n    const backgroundStage = backgroundFilter === 'blur'\n        ? buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel || 'high')\n        : buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas);\n    function render() {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n        // texImage2D seems faster than texSubImage2D to upload\n        // video texture\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoSource);\n        gl.bindVertexArray(vertexArray);\n        resizingStage.render();\n        tflite._runInference();\n        loadSegmentationStage.render();\n        jointBilateralFilterStage.render();\n        backgroundStage.render();\n    }\n    function updatePostProcessingConfig() {\n        jointBilateralFilterStage.updateSigmaSpace(1);\n        jointBilateralFilterStage.updateSigmaColor(0.1);\n        if (backgroundFilter === 'image') {\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0.5, 0.75]);\n            backgroundImageStage.updateLightWrapping(0.3);\n            backgroundImageStage.updateBlendMode('screen');\n        }\n        else if (backgroundFilter === 'blur') {\n            const backgroundBlurStage = backgroundStage;\n            backgroundBlurStage.updateCoverage([0.5, 0.75]);\n        }\n        else {\n            // TODO Handle no background in a separate pipeline path\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0, 0.9999]);\n            backgroundImageStage.updateLightWrapping(0);\n        }\n    }\n    function cleanUp() {\n        backgroundStage.cleanUp();\n        jointBilateralFilterStage.cleanUp();\n        loadSegmentationStage.cleanUp();\n        resizingStage.cleanUp();\n        gl.deleteTexture(personMaskTexture);\n        gl.deleteTexture(segmentationTexture);\n        gl.deleteTexture(inputFrameTexture);\n        gl.deleteBuffer(texCoordBuffer);\n        gl.deleteBuffer(positionBuffer);\n        gl.deleteVertexArray(vertexArray);\n        gl.deleteShader(vertexShader);\n    }\n    return { render, updatePostProcessingConfig, cleanUp };\n}\n\nvar SegmentationLevel;\n(function (SegmentationLevel) {\n    SegmentationLevel[\"LOW\"] = \"low\";\n    SegmentationLevel[\"HIGH\"] = \"high\";\n})(SegmentationLevel || (SegmentationLevel = {}));\nconst getSegmentationParams = (level) => {\n    if (level === SegmentationLevel.HIGH) {\n        return { width: 256, height: 144 };\n    }\n    return { width: 160, height: 96 };\n};\n\nfunction createRenderer(tflite, videoSource, targetCanvas, options) {\n    const { backgroundFilter, backgroundImage, backgroundBlurLevel, segmentationLevel = SegmentationLevel.HIGH, fps = 30, } = options;\n    if (backgroundFilter === 'image' && !backgroundImage) {\n        throw new Error(`backgroundImage element is required when backgroundFilter is image`);\n    }\n    const pipeline = buildWebGL2Pipeline(videoSource, backgroundImage, backgroundBlurLevel, backgroundFilter, targetCanvas, tflite, getSegmentationParams(segmentationLevel));\n    const id = setInterval(() => {\n        pipeline.render();\n        if (backgroundFilter === 'image') {\n            pipeline.updatePostProcessingConfig();\n        }\n    }, 1000 / (fps <= 0 ? 30 : fps));\n    return {\n        dispose: () => {\n            pipeline.cleanUp();\n            clearInterval(id);\n        },\n    };\n}\n\nconst createTFLiteSIMDModule = (__Module) => {\n  __Module = __Module || {};\n\n  var _scriptDir =\n    typeof document !== 'undefined' && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n\n  var Module = typeof __Module != 'undefined' ? __Module : {};\n  var readyPromiseResolve, readyPromiseReject;\n  Module['ready'] = new Promise(function (resolve, reject) {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n  var moduleOverrides = Object.assign({}, Module);\n  var thisProgram = './this.program';\n  var quit_ = (status, toThrow) => {\n    throw toThrow;\n  };\n  var ENVIRONMENT_IS_WEB = true;\n  var scriptDirectory = '';\n\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory);\n    }\n    return scriptDirectory + path;\n  }\n\n  var readBinary;\n  {\n    if (typeof document != 'undefined' && document.currentScript) {\n      scriptDirectory = document.currentScript.src;\n    }\n    if (_scriptDir) {\n      scriptDirectory = _scriptDir;\n    }\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n      );\n    } else {\n      scriptDirectory = '';\n    }\n  }\n  var out = Module['print'] || console.log.bind(console);\n  var err = Module['printErr'] || console.warn.bind(console);\n  Object.assign(Module, moduleOverrides);\n  moduleOverrides = null;\n  if (Module['arguments']) Module['arguments'];\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n  if (Module['quit']) quit_ = Module['quit'];\n  var wasmBinary;\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n  var noExitRuntime = Module['noExitRuntime'] || true;\n  if (typeof WebAssembly != 'object') {\n    abort('no native wasm support detected');\n  }\n  var wasmMemory;\n  var ABORT = false;\n\n  var UTF8Decoder =\n    typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead;\n    var endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    var str = '';\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      var u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\n        continue;\n      }\n      var u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 =\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n      }\n    }\n    return str;\n  }\n\n  var buffer, HEAP8, HEAPU8, HEAPU32;\n\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n    Module['HEAP16'] = new Int16Array(buf);\n    Module['HEAP32'] = new Int32Array(buf);\n    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n    Module['HEAPU16'] = new Uint16Array(buf);\n    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n    Module['HEAPF32'] = new Float32Array(buf);\n    Module['HEAPF64'] = new Float64Array(buf);\n  }\n\n  Module['INITIAL_MEMORY'] || 16777216;\n  var __ATPRERUN__ = [];\n  var __ATINIT__ = [];\n  var __ATPOSTRUN__ = [];\n\n  function keepRuntimeAlive() {\n    return noExitRuntime;\n  }\n\n  function preRun() {\n    if (Module['preRun']) {\n      if (typeof Module['preRun'] == 'function')\n        Module['preRun'] = [Module['preRun']];\n      while (Module['preRun'].length) {\n        addOnPreRun(Module['preRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function initRuntime() {\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function postRun() {\n    if (Module['postRun']) {\n      if (typeof Module['postRun'] == 'function')\n        Module['postRun'] = [Module['postRun']];\n      while (Module['postRun'].length) {\n        addOnPostRun(Module['postRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  }\n\n  var runDependencies = 0;\n  var dependenciesFulfilled = null;\n\n  function addRunDependency(id) {\n    runDependencies++;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n    if (runDependencies == 0) {\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  }\n\n  function abort(what) {\n    {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n    }\n    what = 'Aborted(' + what + ')';\n    err(what);\n    ABORT = true;\n    what += '. Build with -sASSERTIONS for more info.';\n    var e = new WebAssembly.RuntimeError(what);\n    readyPromiseReject(e);\n    throw e;\n  }\n\n  var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix);\n  }\n\n  var wasmBinaryFile;\n  wasmBinaryFile = 'tflite-simd.wasm';\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n\n  function getBinary(file) {\n    try {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) ;\n      throw 'both async and sync fetching of the wasm failed';\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n    } catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB )) {\n      if (typeof fetch == 'function') {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' })\n          .then(function (response) {\n            if (!response['ok']) {\n              throw (\n                \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n              );\n            }\n            return response['arrayBuffer']();\n          })\n          .catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n      }\n    }\n    return Promise.resolve().then(function () {\n      return getBinary(wasmBinaryFile);\n    });\n  }\n\n  function createWasm() {\n    var info = {\n      env: asmLibraryArg,\n      wasi_snapshot_preview1: asmLibraryArg,\n    };\n\n    function receiveInstance(instance, module) {\n      var exports = instance.exports;\n      Module['asm'] = exports;\n      wasmMemory = Module['asm']['memory'];\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      Module['asm']['__indirect_function_table'];\n      addOnInit(Module['asm']['__wasm_call_ctors']);\n      removeRunDependency();\n    }\n\n    addRunDependency();\n\n    function receiveInstantiationResult(result) {\n      receiveInstance(result['instance']);\n    }\n\n    function instantiateArrayBuffer(receiver) {\n      return getBinaryPromise()\n        .then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        })\n        .then(function (instance) {\n          return instance;\n        })\n        .then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync() {\n      if (\n        !wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(\n          function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          },\n        );\n      } else {\n        return instantiateArrayBuffer(receiveInstantiationResult);\n      }\n    }\n\n    if (Module['instantiateWasm']) {\n      try {\n        var exports = Module['instantiateWasm'](info, receiveInstance);\n        return exports;\n      } catch (e) {\n        err('Module.instantiateWasm callback failed with error: ' + e);\n        readyPromiseReject(e);\n      }\n    }\n    instantiateAsync().catch(readyPromiseReject);\n    return {};\n  }\n\n  function ExitStatus(status) {\n    this.name = 'ExitStatus';\n    this.message = 'Program terminated with exit(' + status + ')';\n    this.status = status;\n  }\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module);\n    }\n  }\n\n  function __dlinit(main_dso_handle) {}\n\n  var dlopenMissingError =\n    'To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking';\n\n  function __dlopen_js(filename, flag) {\n    abort(dlopenMissingError);\n  }\n\n  function __dlsym_js(handle, symbol) {\n    abort(dlopenMissingError);\n  }\n\n  var nowIsMonotonic = true;\n\n  function __emscripten_get_now_is_monotonic() {\n    return nowIsMonotonic;\n  }\n\n  function __mmap_js(len, prot, flags, fd, off, allocated) {\n    return -52;\n  }\n\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\n\n  function _abort() {\n    abort('');\n  }\n\n  function _emscripten_date_now() {\n    return Date.now();\n  }\n\n  function getHeapMax() {\n    return 2147483648;\n  }\n\n  function _emscripten_get_heap_max() {\n    return getHeapMax();\n  }\n\n  var _emscripten_get_now;\n  _emscripten_get_now = () => performance.now();\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num);\n  }\n\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch (e) {}\n  }\n\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    var maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(\n        overGrownHeapSize,\n        requestedSize + 100663296,\n      );\n      var newSize = Math.min(\n        maxHeapSize,\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),\n      );\n      var replacement = emscripten_realloc_buffer(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var ENV = {};\n\n  function getExecutableName() {\n    return thisProgram || './this.program';\n  }\n\n  function getEnvStrings() {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == 'object' &&\n            navigator.languages &&\n            navigator.languages[0]) ||\n          'C'\n        ).replace('-', '_') + '.UTF-8';\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName(),\n      };\n      for (var x in ENV) {\n        if (ENV[x] === undefined) delete env[x];\n        else env[x] = ENV[x];\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(x + '=' + env[x]);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    }\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n  }\n\n  function _environ_get(__environ, environ_buf) {\n    var bufSize = 0;\n    getEnvStrings().forEach(function (string, i) {\n      var ptr = environ_buf + bufSize;\n      HEAPU32[(__environ + i * 4) >> 2] = ptr;\n      writeAsciiToMemory(string, ptr);\n      bufSize += string.length + 1;\n    });\n    return 0;\n  }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n    var strings = getEnvStrings();\n    HEAPU32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    strings.forEach(function (string) {\n      bufSize += string.length + 1;\n    });\n    HEAPU32[penviron_buf_size >> 2] = bufSize;\n    return 0;\n  }\n\n  function _proc_exit(code) {\n    if (!keepRuntimeAlive()) {\n      if (Module['onExit']) Module['onExit'](code);\n      ABORT = true;\n    }\n    quit_(code, new ExitStatus(code));\n  }\n\n  function exitJS(status, implicit) {\n    _proc_exit(status);\n  }\n\n  var _exit = exitJS;\n\n  function _fd_close(fd) {\n    return 52;\n  }\n\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n    return 70;\n  }\n\n  var printCharBuffers = [null, [], []];\n\n  function printChar(stream, curr) {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    var buffer = printCharBuffers[stream];\n    if (curr === 0 || curr === 10) {\n      (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n      buffer.length = 0;\n    } else {\n      buffer.push(curr);\n    }\n  }\n\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    var num = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[(iov + 4) >> 2];\n      iov += 8;\n      for (var j = 0; j < len; j++) {\n        printChar(fd, HEAPU8[ptr + j]);\n      }\n      num += len;\n    }\n    HEAPU32[pnum >> 2] = num;\n    return 0;\n  }\n\n  function getRandomDevice() {\n    if (\n      typeof crypto == 'object' &&\n      typeof crypto['getRandomValues'] == 'function'\n    ) {\n      var randomBuffer = new Uint8Array(1);\n      return () => {\n        crypto.getRandomValues(randomBuffer);\n        return randomBuffer[0];\n      };\n    } else return () => abort('randomDevice');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _getentropy(buffer, size) {\n    if (!_getentropy.randomDevice) {\n      _getentropy.randomDevice = getRandomDevice();\n    }\n    for (var i = 0; i < size; i++) {\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\n    }\n    return 0;\n  }\n\n  var asmLibraryArg = {\n    _dlinit: __dlinit,\n    _dlopen_js: __dlopen_js,\n    _dlsym_js: __dlsym_js,\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n    _mmap_js: __mmap_js,\n    _munmap_js: __munmap_js,\n    abort: _abort,\n    emscripten_date_now: _emscripten_date_now,\n    emscripten_get_heap_max: _emscripten_get_heap_max,\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    environ_get: _environ_get,\n    environ_sizes_get: _environ_sizes_get,\n    exit: _exit,\n    fd_close: _fd_close,\n    fd_seek: _fd_seek,\n    fd_write: _fd_write,\n    getentropy: _getentropy,\n  };\n  createWasm();\n  (Module['___wasm_call_ctors'] = function () {\n    return (Module['___wasm_call_ctors'] =\n      Module['asm']['__wasm_call_ctors']).apply(null, arguments);\n  });\n  (Module['_getModelBufferMemoryOffset'] =\n    function () {\n      return (Module[\n        '_getModelBufferMemoryOffset'\n      ] =\n        Module['asm']['getModelBufferMemoryOffset']).apply(null, arguments);\n    });\n  (Module['_getInputMemoryOffset'] = function () {\n    return (Module['_getInputMemoryOffset'] =\n      Module['asm']['getInputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getInputHeight'] = function () {\n    return (Module['_getInputHeight'] =\n      Module['asm']['getInputHeight']).apply(null, arguments);\n  });\n  (Module['_getInputWidth'] = function () {\n    return (Module['_getInputWidth'] =\n      Module['asm']['getInputWidth']).apply(null, arguments);\n  });\n  (Module['_getInputChannelCount'] = function () {\n    return (Module['_getInputChannelCount'] =\n      Module['asm']['getInputChannelCount']).apply(null, arguments);\n  });\n  (Module['_getOutputMemoryOffset'] = function () {\n    return (Module['_getOutputMemoryOffset'] =\n      Module['asm']['getOutputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getOutputHeight'] = function () {\n    return (Module['_getOutputHeight'] =\n      Module['asm']['getOutputHeight']).apply(null, arguments);\n  });\n  (Module['_getOutputWidth'] = function () {\n    return (Module['_getOutputWidth'] =\n      Module['asm']['getOutputWidth']).apply(null, arguments);\n  });\n  (Module['_getOutputChannelCount'] = function () {\n    return (Module['_getOutputChannelCount'] =\n      Module['asm']['getOutputChannelCount']).apply(null, arguments);\n  });\n  (Module['_loadModel'] = function () {\n    return (Module['_loadModel'] =\n      Module['asm']['loadModel']).apply(null, arguments);\n  });\n  (Module['_runInference'] = function () {\n    return (Module['_runInference'] =\n      Module['asm']['runInference']).apply(null, arguments);\n  });\n  (Module['_malloc'] = function () {\n    return (Module['_malloc'] = Module['asm']['malloc']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['___errno_location'] = function () {\n    return (Module['___errno_location'] =\n      Module['asm']['__errno_location']).apply(null, arguments);\n  });\n  (Module['___dl_seterr'] = function () {\n    return (Module['___dl_seterr'] =\n      Module['asm']['__dl_seterr']).apply(null, arguments);\n  });\n  (Module['stackSave'] = function () {\n    return (Module['stackSave'] = Module['asm']['stackSave']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['stackRestore'] = function () {\n    return (Module['stackRestore'] =\n      Module['asm']['stackRestore']).apply(null, arguments);\n  });\n  (Module['stackAlloc'] = function () {\n    return (Module['stackAlloc'] =\n      Module['asm']['stackAlloc']).apply(null, arguments);\n  });\n  (Module['dynCall_jjj'] = function () {\n    return (Module['dynCall_jjj'] =\n      Module['asm']['dynCall_jjj']).apply(null, arguments);\n  });\n  (Module['dynCall_jiii'] = function () {\n    return (Module['dynCall_jiii'] =\n      Module['asm']['dynCall_jiii']).apply(null, arguments);\n  });\n  (Module['dynCall_iiiijj'] = function () {\n    return (Module['dynCall_iiiijj'] =\n      Module['asm']['dynCall_iiiijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viijj'] = function () {\n    return (Module['dynCall_viijj'] =\n      Module['asm']['dynCall_viijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viiijjj'] = function () {\n    return (Module['dynCall_viiijjj'] =\n      Module['asm']['dynCall_viiijjj']).apply(null, arguments);\n  });\n  (Module['dynCall_iijjiiii'] = function () {\n    return (Module['dynCall_iijjiiii'] =\n      Module['asm']['dynCall_iijjiiii']).apply(null, arguments);\n  });\n  (Module['dynCall_jiji'] = function () {\n    return (Module['dynCall_jiji'] =\n      Module['asm']['dynCall_jiji']).apply(null, arguments);\n  });\n  var calledRun;\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run();\n    if (!calledRun) dependenciesFulfilled = runCaller;\n  };\n\n  function run(args) {\n    if (runDependencies > 0) {\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      return;\n    }\n\n    function doRun() {\n      if (calledRun) return;\n      calledRun = true;\n      Module['calledRun'] = true;\n      if (ABORT) return;\n      initRuntime();\n      readyPromiseResolve(Module);\n      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n      postRun();\n    }\n\n    if (Module['setStatus']) {\n      Module['setStatus']('Running...');\n      setTimeout(function () {\n        setTimeout(function () {\n          Module['setStatus']('');\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function')\n      Module['preInit'] = [Module['preInit']];\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].pop()();\n    }\n  }\n  run();\n\n  return __Module.ready;\n};\n\nconst version = \"0.1.0\" ;\nconst packageName = \"@stream-io/video-filters-web\" ;\n\n// @ts-expect-error - module is not declared\n// This is a WebAssembly module compiled from the TensorFlow Lite C++ library.\nconst createTFLite = createTFLiteSIMDModule;\nconst loadTFLite = async (options = {}) => {\n    const { basePath = `https://unpkg.com/${packageName}@${version}/tf`, tfFilePath = `${basePath}/tflite/tflite-simd.wasm`, modelFilePath = `${basePath}/models/segm_full_v679.tflite`, } = options;\n    const [tfLite, model] = await Promise.all([\n        createTFLite({ locateFile: () => tfFilePath }),\n        fetchModel(modelFilePath),\n    ]);\n    const modelBufferOffset = tfLite._getModelBufferMemoryOffset();\n    tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);\n    tfLite._loadModel(model.byteLength);\n    return tfLite;\n};\nlet lastModelFilePath = '';\nlet modelFileCache;\nconst fetchModel = async (modelFilePath) => {\n    const model = modelFilePath === lastModelFilePath && modelFileCache\n        ? modelFileCache\n        : await fetch(modelFilePath).then((r) => r.arrayBuffer());\n    // Cache the model file for future use.\n    modelFileCache = model;\n    lastModelFilePath = modelFilePath;\n    return model;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0cmVhbS1pbyt2aWRlby1maWx0ZXJzLXdlYkAwLjAuMS9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1maWx0ZXJzLXdlYi9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFJLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhCQUE4QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBdUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQsWUFBWSx1REFBdUQ7QUFDbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFlBQVksZ0hBQWdIO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsWUFBWSxnQ0FBZ0MsWUFBWSxHQUFHLFFBQVEsc0JBQXNCLFNBQVMsOENBQThDLFNBQVMsa0NBQWtDO0FBQzNMO0FBQ0EsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThFO0FBQzlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veW9vbS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3RyZWFtLWlvK3ZpZGVvLWZpbHRlcnMtd2ViQDAuMC4xL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLWZpbHRlcnMtd2ViL2Rpc3QvaW5kZXguZXMuanM/OThkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaW1kIH0gZnJvbSAnd2FzbS1mZWF0dXJlLWRldGVjdCc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHBsYXRmb3JtIGlzIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBTZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jyb3dzZXJfZGV0ZWN0aW9uX3VzaW5nX3RoZV91c2VyX2FnZW50XG4gKi9cbmNvbnN0IGlzTW9iaWxlID0gKCkgPT4gL01vYmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLyoqXG4gKiBSdW5zIGEgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHBsYXRmb3JtIHN1cHBvcnRzXG4gKiB0aGUgbmVjZXNzYXJ5IEFQSXMgcmVxdWlyZWQgZm9yIHRoZSB2aWRlbyBmaWx0ZXJzLlxuICovXG5jb25zdCBpc1BsYXRmb3JtU3VwcG9ydGVkID0gYXN5bmMgKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAhaXNNb2JpbGUoKSAmJiAvLyB3ZSBkb24ndCBzdXBwb3J0IG1vYmlsZSBkZXZpY2VzIHlldCBkdWUgdG8gcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICEhd2luZG93LldlYkdMMlJlbmRlcmluZ0NvbnRleHQgJiYgLy8gV2ViR0wyIGlzIHJlcXVpcmVkIGZvciB0aGUgdmlkZW8gZmlsdGVyc1xuICAgICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnd2ViZ2wyJykgJiZcbiAgICAoYXdhaXQgc2ltZCgpKTsgLy8gU0lNRCBpcyByZXF1aXJlZCBmb3IgdGhlIHdhc20gbW9kdWxlXG5cbi8qKlxuICogVXNlIGl0IGFsb25nIHdpdGggYm95c3dhbi5nbHNsLWxpdGVyYWwgVlNDb2RlIGV4dGVuc2lvblxuICogdG8gZ2V0IEdMU0wgc3ludGF4IGhpZ2hsaWdodGluZy5cbiAqIGh0dHBzOi8vbWFya2V0cGxhY2UudmlzdWFsc3R1ZGlvLmNvbS9pdGVtcz9pdGVtTmFtZT1ib3lzd2FuLmdsc2wtbGl0ZXJhbFxuICpcbiAqIE9uIFZTQ29kZSBPU1MsIGJveXN3YW4uZ2xzbC1saXRlcmFsIHJlcXVpcmVzIHNsZXZlc3F1ZS5zaGFkZXIgZXh0ZW5zaW9uXG4gKiB0byBiZSBpbnN0YWxsZWQgYXMgd2VsbC5cbiAqIGh0dHBzOi8vbWFya2V0cGxhY2UudmlzdWFsc3R1ZGlvLmNvbS9pdGVtcz9pdGVtTmFtZT1zbGV2ZXNxdWUuc2hhZGVyXG4gKi9cbmNvbnN0IGdsc2wgPSBTdHJpbmcucmF3O1xuZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVTdGFnZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlcikge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBjb25zdCB0ZXhDb29yZEF0dHJpYnV0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGV4Q29vcmQnKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZEF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRBdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsaW5rIFdlYkdMIHByb2dyYW06ICR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgc2hhZGVyVHlwZSwgc2hhZGVyU291cmNlKSB7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNvbXBpbGUgc2hhZGVyOiAke2dsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNULCBtYWdGaWx0ZXIgPSBnbC5ORUFSRVNUKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcbiAgICBnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgaW50ZXJuYWxmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZFBpeGVsc0FzeW5jKGdsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIGRlc3QpIHtcbiAgICBjb25zdCBidWYgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWYpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuUElYRUxfUEFDS19CVUZGRVIsIGRlc3QuYnl0ZUxlbmd0aCwgZ2wuU1RSRUFNX1JFQUQpO1xuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCAwKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICBhd2FpdCBnZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wsIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWYsIDAsIGRlc3QpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcihidWYpO1xuICAgIHJldHVybiBkZXN0O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QnVmZmVyU3ViRGF0YUFzeW5jKGdsLCB0YXJnZXQsIGJ1ZmZlciwgc3JjQnl0ZU9mZnNldCwgZHN0QnVmZmVyLCBkc3RPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHN5bmMgPSBnbC5mZW5jZVN5bmMoZ2wuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDApO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50V2FpdEFzeW5jKGdsLCBzeW5jKTtcbiAgICBnbC5kZWxldGVTeW5jKHN5bmMpO1xuICAgIGlmIChyZXMgIT09IGdsLldBSVRfRkFJTEVEKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuICAgICAgICBnbC5nZXRCdWZmZXJTdWJEYXRhKHRhcmdldCwgc3JjQnl0ZU9mZnNldCwgZHN0QnVmZmVyLCBkc3RPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRXYWl0QXN5bmMoZ2wsIHN5bmMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGdsLmNsaWVudFdhaXRTeW5jKHN5bmMsIDAsIDApO1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gZ2wuV0FJVF9GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gZ2wuVElNRU9VVF9FWFBJUkVEKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCh0ZXN0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCYWNrZ3JvdW5kQmx1clN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKSB7XG4gICAgY29uc3QgYmx1clBhc3MgPSBidWlsZEJsdXJQYXNzKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKTtcbiAgICBjb25zdCBibGVuZFBhc3MgPSBidWlsZEJsZW5kUGFzcyhnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBjYW52YXMpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgYmx1clBhc3MucmVuZGVyKCk7XG4gICAgICAgIGJsZW5kUGFzcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgYmxlbmRQYXNzLnVwZGF0ZUNvdmVyYWdlKGNvdmVyYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgYmxlbmRQYXNzLmNsZWFuVXAoKTtcbiAgICAgICAgYmx1clBhc3MuY2xlYW5VcCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIHVwZGF0ZUNvdmVyYWdlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEJsdXJQYXNzKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IGJsdXJMZXZlbCA9PT0gJ2xvdydcbiAgICAgICAgPyBbMC4yMjcwMjcwMjcsIDAuMTU0NTk0NTk0NiwgMC4xMDE2MjE2MjE2LCAwLjAzNDA1NDA1NDEsIDAuMDE0MjE2MjE2Ml1cbiAgICAgICAgOiBibHVyTGV2ZWwgPT09ICdtZWRpdW0nXG4gICAgICAgICAgICA/IFswLjMyNzAyNzAyNywgMC4xOTQ1OTQ1OTQ2LCAwLjEyMTYyMTYyMTYsIDAuMDU0MDU0MDU0MSwgMC4wMTYyMTYyMTYyXVxuICAgICAgICAgICAgOiBbMC42MjcwMjcwMjcsIDAuMzQ0NTk0NTk0NiwgMC4yMjE2MjE2MjE2LCAwLjA1NDA1NDA1NDEsIDAuMDE2MjE2MjE2Ml07XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BlcnNvbk1hc2s7XG4gICAgdW5pZm9ybSB2ZWMyIHVfdGV4ZWxTaXplO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgY29uc3QgZmxvYXQgb2Zmc2V0WzVdID0gZmxvYXRbXSgwLjAsIDEuMCwgMi4wLCAzLjAsIDQuMCk7XG4gICAgY29uc3QgZmxvYXQgd2VpZ2h0WzVdID0gZmxvYXRbXShcbiAgICAgICR7d2VpZ2h0cy5qb2luKCcsJyl9XG4gICAgKTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY2VudGVyQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdl90ZXhDb29yZCk7XG4gICAgICBmbG9hdCBwZXJzb25NYXNrID0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHZfdGV4Q29vcmQpLmE7XG5cbiAgICAgIHZlYzQgZnJhbWVDb2xvciA9IGNlbnRlckNvbG9yICogd2VpZ2h0WzBdICogKDEuMCAtIHBlcnNvbk1hc2spO1xuXG4gICAgICBmb3IgKGludCBpID0gMTsgaSA8IDU7IGkrKykge1xuICAgICAgICB2ZWMyIG9mZnNldCA9IHZlYzIob2Zmc2V0W2ldKSAqIHVfdGV4ZWxTaXplO1xuXG4gICAgICAgIHZlYzIgdGV4Q29vcmQgPSB2X3RleENvb3JkICsgb2Zmc2V0O1xuICAgICAgICBmcmFtZUNvbG9yICs9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB0ZXhDb29yZClcbiAgICAgICAgICAgKiB3ZWlnaHRbaV1cbiAgICAgICAgICAgKiAoMS4wIC0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHRleENvb3JkKS5hKTtcblxuICAgICAgICB0ZXhDb29yZCA9IHZfdGV4Q29vcmQgLSBvZmZzZXQ7XG4gICAgICAgIGZyYW1lQ29sb3IgKz0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHRleENvb3JkKVxuICAgICAgICAgICogd2VpZ2h0W2ldXG4gICAgICAgICAgKiAoMS4wIC0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHRleENvb3JkKS5hKTtcbiAgICAgIH1cbiAgICAgIG91dENvbG9yID0gdmVjNChmcmFtZUNvbG9yLnJnYiArICgxLjAgLSBmcmFtZUNvbG9yLmEpICogY2VudGVyQ29sb3IucmdiLCAxLjApO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCBzY2FsZSA9IDAuNTtcbiAgICBjb25zdCBvdXRwdXRXaWR0aCA9IGNhbnZhcy53aWR0aCAqIHNjYWxlO1xuICAgIGNvbnN0IG91dHB1dEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKiBzY2FsZTtcbiAgICBjb25zdCB0ZXhlbFdpZHRoID0gMSAvIG91dHB1dFdpZHRoO1xuICAgIGNvbnN0IHRleGVsSGVpZ2h0ID0gMSAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9wZXJzb25NYXNrJyk7XG4gICAgY29uc3QgdGV4ZWxTaXplTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4ZWxTaXplJyk7XG4gICAgY29uc3QgdGV4dHVyZTEgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuTkVBUkVTVCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlcyBhcmUgaW5jb21wbGV0ZVxuICAgIGdsLkxJTkVBUik7XG4gICAgY29uc3QgdGV4dHVyZTIgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuTkVBUkVTVCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlcyBhcmUgaW5jb21wbGV0ZVxuICAgIGdsLkxJTkVBUik7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIxID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyMSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlMSwgMCk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyMik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlMiwgMCk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkocGVyc29uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBlcnNvbk1hc2tUZXh0dXJlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZih0ZXhlbFNpemVMb2NhdGlvbiwgMCwgdGV4ZWxIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcjEpO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUyKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUxKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDIpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHRleGVsU2l6ZUxvY2F0aW9uLCB0ZXhlbFdpZHRoLCAwKTtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIyKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyMik7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyMSk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZTIpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUxKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEJsZW5kUGFzcyhnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBjYW52YXMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIGluIHZlYzIgYV9wb3NpdGlvbjtcbiAgICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XG5cbiAgICBvdXQgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gRmxpcHBpbmcgWSBpcyByZXF1aXJlZCB3aGVuIHJlbmRlcmluZyB0byBjYW52YXNcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7XG4gICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BlcnNvbk1hc2s7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9ibHVycmVkSW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHZlYzIgdV9jb3ZlcmFnZTtcblxuICAgIGluIHZlYzIgdl90ZXhDb29yZDtcblxuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMyBjb2xvciA9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB2X3RleENvb3JkKS5yZ2I7XG4gICAgICB2ZWMzIGJsdXJyZWRDb2xvciA9IHRleHR1cmUodV9ibHVycmVkSW5wdXRGcmFtZSwgdl90ZXhDb29yZCkucmdiO1xuICAgICAgZmxvYXQgcGVyc29uTWFzayA9IHRleHR1cmUodV9wZXJzb25NYXNrLCB2X3RleENvb3JkKS5hO1xuICAgICAgcGVyc29uTWFzayA9IHNtb290aHN0ZXAodV9jb3ZlcmFnZS54LCB1X2NvdmVyYWdlLnksIHBlcnNvbk1hc2spO1xuICAgICAgb3V0Q29sb3IgPSB2ZWM0KG1peChibHVycmVkQ29sb3IsIGNvbG9yLCBwZXJzb25NYXNrKSwgMS4wKTtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgeyB3aWR0aDogb3V0cHV0V2lkdGgsIGhlaWdodDogb3V0cHV0SGVpZ2h0IH0gPSBjYW52YXM7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9wZXJzb25NYXNrJyk7XG4gICAgY29uc3QgYmx1cnJlZElucHV0RnJhbWUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYmx1cnJlZElucHV0RnJhbWUnKTtcbiAgICBjb25zdCBjb3ZlcmFnZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2NvdmVyYWdlJyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkocGVyc29uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBnbC51bmlmb3JtMWkoYmx1cnJlZElucHV0RnJhbWUsIDIpO1xuICAgIGdsLnVuaWZvcm0yZihjb3ZlcmFnZUxvY2F0aW9uLCAwLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIGNvdmVyYWdlWzBdLCBjb3ZlcmFnZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIHVwZGF0ZUNvdmVyYWdlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQmFja2dyb3VuZEltYWdlU3RhZ2UoZ2wsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGJhY2tncm91bmRJbWFnZSwgY2FudmFzKSB7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICB1bmlmb3JtIHZlYzIgdV9iYWNrZ3JvdW5kU2NhbGU7XG4gICAgdW5pZm9ybSB2ZWMyIHVfYmFja2dyb3VuZE9mZnNldDtcblxuICAgIGluIHZlYzIgYV9wb3NpdGlvbjtcbiAgICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XG5cbiAgICBvdXQgdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWMyIHZfYmFja2dyb3VuZENvb3JkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gRmxpcHBpbmcgWSBpcyByZXF1aXJlZCB3aGVuIHJlbmRlcmluZyB0byBjYW52YXNcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7XG4gICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICAgIHZfYmFja2dyb3VuZENvb3JkID0gYV90ZXhDb29yZCAqIHVfYmFja2dyb3VuZFNjYWxlICsgdV9iYWNrZ3JvdW5kT2Zmc2V0O1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfcGVyc29uTWFzaztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2JhY2tncm91bmQ7XG4gICAgdW5pZm9ybSB2ZWMyIHVfY292ZXJhZ2U7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2xpZ2h0V3JhcHBpbmc7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2JsZW5kTW9kZTtcblxuICAgIGluIHZlYzIgdl90ZXhDb29yZDtcbiAgICBpbiB2ZWMyIHZfYmFja2dyb3VuZENvb3JkO1xuXG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2ZWMzIHNjcmVlbih2ZWMzIGEsIHZlYzMgYikge1xuICAgICAgcmV0dXJuIDEuMCAtICgxLjAgLSBhKSAqICgxLjAgLSBiKTtcbiAgICB9XG5cbiAgICB2ZWMzIGxpbmVhckRvZGdlKHZlYzMgYSwgdmVjMyBiKSB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMyBmcmFtZUNvbG9yID0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHZfdGV4Q29vcmQpLnJnYjtcbiAgICAgIHZlYzMgYmFja2dyb3VuZENvbG9yID0gdGV4dHVyZSh1X2JhY2tncm91bmQsIHZfYmFja2dyb3VuZENvb3JkKS5yZ2I7XG4gICAgICBmbG9hdCBwZXJzb25NYXNrID0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHZfdGV4Q29vcmQpLmE7XG4gICAgICBmbG9hdCBsaWdodFdyYXBNYXNrID0gMS4wIC0gbWF4KDAuMCwgcGVyc29uTWFzayAtIHVfY292ZXJhZ2UueSkgLyAoMS4wIC0gdV9jb3ZlcmFnZS55KTtcbiAgICAgIHZlYzMgbGlnaHRXcmFwID0gdV9saWdodFdyYXBwaW5nICogbGlnaHRXcmFwTWFzayAqIGJhY2tncm91bmRDb2xvcjtcblxuICAgICAgZnJhbWVDb2xvciA9IHVfYmxlbmRNb2RlICogbGluZWFyRG9kZ2UoZnJhbWVDb2xvciwgbGlnaHRXcmFwKVxuICAgICAgICArICgxLjAgLSB1X2JsZW5kTW9kZSkgKiBzY3JlZW4oZnJhbWVDb2xvciwgbGlnaHRXcmFwKTtcbiAgICAgIHBlcnNvbk1hc2sgPSBzbW9vdGhzdGVwKHVfY292ZXJhZ2UueCwgdV9jb3ZlcmFnZS55LCBwZXJzb25NYXNrKTtcbiAgICAgIG91dENvbG9yID0gdmVjNChmcmFtZUNvbG9yICogcGVyc29uTWFzayArIGJhY2tncm91bmRDb2xvciAqICgxLjAgLSBwZXJzb25NYXNrKSwgMS4wKTtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgeyB3aWR0aDogb3V0cHV0V2lkdGgsIGhlaWdodDogb3V0cHV0SGVpZ2h0IH0gPSBjYW52YXM7XG4gICAgY29uc3Qgb3V0cHV0UmF0aW8gPSBvdXRwdXRXaWR0aCAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGJhY2tncm91bmRTY2FsZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2JhY2tncm91bmRTY2FsZScpO1xuICAgIGNvbnN0IGJhY2tncm91bmRPZmZzZXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9iYWNrZ3JvdW5kT2Zmc2V0Jyk7XG4gICAgY29uc3QgaW5wdXRGcmFtZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2lucHV0RnJhbWUnKTtcbiAgICBjb25zdCBwZXJzb25NYXNrTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcGVyc29uTWFzaycpO1xuICAgIGNvbnN0IGJhY2tncm91bmRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9iYWNrZ3JvdW5kJyk7XG4gICAgY29uc3QgY292ZXJhZ2VMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9jb3ZlcmFnZScpO1xuICAgIGNvbnN0IGxpZ2h0V3JhcHBpbmdMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodFdyYXBwaW5nJyk7XG4gICAgY29uc3QgYmxlbmRNb2RlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYmxlbmRNb2RlJyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMmYoYmFja2dyb3VuZFNjYWxlTG9jYXRpb24sIDEsIDEpO1xuICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kT2Zmc2V0TG9jYXRpb24sIDAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDApO1xuICAgIGdsLnVuaWZvcm0xaShwZXJzb25NYXNrTG9jYXRpb24sIDEpO1xuICAgIGdsLnVuaWZvcm0yZihjb3ZlcmFnZUxvY2F0aW9uLCAwLCAxKTtcbiAgICBnbC51bmlmb3JtMWYobGlnaHRXcmFwcGluZ0xvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWYoYmxlbmRNb2RlTG9jYXRpb24sIDApO1xuICAgIGxldCBiYWNrZ3JvdW5kVGV4dHVyZSA9IG51bGw7XG4gICAgLy8gVE9ETyBGaW5kIGEgYmV0dGVyIHRvIGhhbmRsZSBiYWNrZ3JvdW5kIGJlaW5nIGxvYWRlZFxuICAgIGlmIChiYWNrZ3JvdW5kSW1hZ2U/LmNvbXBsZXRlKSB7XG4gICAgICAgIHVwZGF0ZUJhY2tncm91bmRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUJhY2tncm91bmRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGVyc29uTWFza1RleHR1cmUpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYmFja2dyb3VuZFRleHR1cmUpO1xuICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgY29ycmVjdGx5IHRoZSBiYWNrZ3JvdW5kIG5vdCBsb2FkZWQgeWV0XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoYmFja2dyb3VuZExvY2F0aW9uLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQmFja2dyb3VuZEltYWdlKGJnSW1hZ2UpIHtcbiAgICAgICAgYmFja2dyb3VuZFRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgYmdJbWFnZS5uYXR1cmFsV2lkdGgsIGJnSW1hZ2UubmF0dXJhbEhlaWdodCwgXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZXMgYXJlIGluY29tcGxldGVcbiAgICAgICAgZ2wuTElORUFSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGJnSW1hZ2UubmF0dXJhbFdpZHRoLCBiZ0ltYWdlLm5hdHVyYWxIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJnSW1hZ2UpO1xuICAgICAgICBsZXQgeE9mZnNldCA9IDA7XG4gICAgICAgIGxldCB5T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGJhY2tncm91bmRXaWR0aCA9IGJnSW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICBsZXQgYmFja2dyb3VuZEhlaWdodCA9IGJnSW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZFJhdGlvID0gYmFja2dyb3VuZFdpZHRoIC8gYmFja2dyb3VuZEhlaWdodDtcbiAgICAgICAgaWYgKGJhY2tncm91bmRSYXRpbyA8IG91dHB1dFJhdGlvKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSGVpZ2h0ID0gYmFja2dyb3VuZFdpZHRoIC8gb3V0cHV0UmF0aW87XG4gICAgICAgICAgICB5T2Zmc2V0ID0gKGJnSW1hZ2UubmF0dXJhbEhlaWdodCAtIGJhY2tncm91bmRIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRXaWR0aCA9IGJhY2tncm91bmRIZWlnaHQgKiBvdXRwdXRSYXRpbztcbiAgICAgICAgICAgIHhPZmZzZXQgPSAoYmdJbWFnZS5uYXR1cmFsV2lkdGggLSBiYWNrZ3JvdW5kV2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4U2NhbGUgPSBiYWNrZ3JvdW5kV2lkdGggLyBiZ0ltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgY29uc3QgeVNjYWxlID0gYmFja2dyb3VuZEhlaWdodCAvIGJnSW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgeE9mZnNldCAvPSBiZ0ltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgeU9mZnNldCAvPSBiZ0ltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kU2NhbGVMb2NhdGlvbiwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICBnbC51bmlmb3JtMmYoYmFja2dyb3VuZE9mZnNldExvY2F0aW9uLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIGNvdmVyYWdlWzBdLCBjb3ZlcmFnZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxpZ2h0V3JhcHBpbmcobGlnaHRXcmFwcGluZykge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYobGlnaHRXcmFwcGluZ0xvY2F0aW9uLCBsaWdodFdyYXBwaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoYmxlbmRNb2RlTG9jYXRpb24sIGJsZW5kTW9kZSA9PT0gJ3NjcmVlbicgPyAwIDogMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoYmFja2dyb3VuZFRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICB1cGRhdGVDb3ZlcmFnZSxcbiAgICAgICAgdXBkYXRlTGlnaHRXcmFwcGluZyxcbiAgICAgICAgdXBkYXRlQmxlbmRNb2RlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSm9pbnRCaWxhdGVyYWxGaWx0ZXJTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIGlucHV0VGV4dHVyZSwgb3V0cHV0VGV4dHVyZSwgY2FudmFzLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfc2VnbWVudGF0aW9uTWFzaztcbiAgICB1bmlmb3JtIHZlYzIgdV90ZXhlbFNpemU7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3N0ZXA7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHVfb2Zmc2V0O1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zaWdtYVRleGVsO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zaWdtYUNvbG9yO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgZmxvYXQgZ2F1c3NpYW4oZmxvYXQgeCwgZmxvYXQgc2lnbWEpIHtcbiAgICAgIGZsb2F0IGNvZWZmID0gLTAuNSAvIChzaWdtYSAqIHNpZ21hICogNC4wICsgMS4wZS02KTtcbiAgICAgIHJldHVybiBleHAoKHggKiB4KSAqIGNvZWZmKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGNlbnRlckNvb3JkID0gdl90ZXhDb29yZDtcbiAgICAgIHZlYzMgY2VudGVyQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgY2VudGVyQ29vcmQpLnJnYjtcbiAgICAgIGZsb2F0IG5ld1ZhbCA9IDAuMDtcblxuICAgICAgZmxvYXQgc3BhY2VXZWlnaHQgPSAwLjA7XG4gICAgICBmbG9hdCBjb2xvcldlaWdodCA9IDAuMDtcbiAgICAgIGZsb2F0IHRvdGFsV2VpZ2h0ID0gMC4wO1xuXG4gICAgICAvLyBTdWJzYW1wbGUga2VybmVsIHNwYWNlLlxuICAgICAgZm9yIChmbG9hdCBpID0gLXVfcmFkaXVzICsgdV9vZmZzZXQ7IGkgPD0gdV9yYWRpdXM7IGkgKz0gdV9zdGVwKSB7XG4gICAgICAgIGZvciAoZmxvYXQgaiA9IC11X3JhZGl1cyArIHVfb2Zmc2V0OyBqIDw9IHVfcmFkaXVzOyBqICs9IHVfc3RlcCkge1xuICAgICAgICAgIHZlYzIgc2hpZnQgPSB2ZWMyKGosIGkpICogdV90ZXhlbFNpemU7XG4gICAgICAgICAgdmVjMiBjb29yZCA9IHZlYzIoY2VudGVyQ29vcmQgKyBzaGlmdCk7XG4gICAgICAgICAgdmVjMyBmcmFtZUNvbG9yID0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIGNvb3JkKS5yZ2I7XG4gICAgICAgICAgZmxvYXQgb3V0VmFsID0gdGV4dHVyZSh1X3NlZ21lbnRhdGlvbk1hc2ssIGNvb3JkKS5hO1xuXG4gICAgICAgICAgc3BhY2VXZWlnaHQgPSBnYXVzc2lhbihkaXN0YW5jZShjZW50ZXJDb29yZCwgY29vcmQpLCB1X3NpZ21hVGV4ZWwpO1xuICAgICAgICAgIGNvbG9yV2VpZ2h0ID0gZ2F1c3NpYW4oZGlzdGFuY2UoY2VudGVyQ29sb3IsIGZyYW1lQ29sb3IpLCB1X3NpZ21hQ29sb3IpO1xuICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHNwYWNlV2VpZ2h0ICogY29sb3JXZWlnaHQ7XG5cbiAgICAgICAgICBuZXdWYWwgKz0gc3BhY2VXZWlnaHQgKiBjb2xvcldlaWdodCAqIG91dFZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3VmFsIC89IHRvdGFsV2VpZ2h0O1xuXG4gICAgICBvdXRDb2xvciA9IHZlYzQodmVjMygwLjApLCBuZXdWYWwpO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCB7IHdpZHRoOiBzZWdtZW50YXRpb25XaWR0aCwgaGVpZ2h0OiBzZWdtZW50YXRpb25IZWlnaHQgfSA9IHNlZ21lbnRhdGlvbkNvbmZpZztcbiAgICBjb25zdCB7IHdpZHRoOiBvdXRwdXRXaWR0aCwgaGVpZ2h0OiBvdXRwdXRIZWlnaHQgfSA9IGNhbnZhcztcbiAgICBjb25zdCB0ZXhlbFdpZHRoID0gMSAvIG91dHB1dFdpZHRoO1xuICAgIGNvbnN0IHRleGVsSGVpZ2h0ID0gMSAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHNlZ21lbnRhdGlvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zZWdtZW50YXRpb25NYXNrJyk7XG4gICAgY29uc3QgdGV4ZWxTaXplTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4ZWxTaXplJyk7XG4gICAgY29uc3Qgc3RlcExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3N0ZXAnKTtcbiAgICBjb25zdCByYWRpdXNMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYWRpdXMnKTtcbiAgICBjb25zdCBvZmZzZXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9vZmZzZXQnKTtcbiAgICBjb25zdCBzaWdtYVRleGVsTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2lnbWFUZXhlbCcpO1xuICAgIGNvbnN0IHNpZ21hQ29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zaWdtYUNvbG9yJyk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3V0cHV0VGV4dHVyZSwgMCk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkoc2VnbWVudGF0aW9uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBnbC51bmlmb3JtMmYodGV4ZWxTaXplTG9jYXRpb24sIHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0KTtcbiAgICAvLyBFbnN1cmVzIGRlZmF1bHQgdmFsdWVzIGFyZSBjb25maWd1cmVkIHRvIHByZXZlbnQgaW5maW5pdGVcbiAgICAvLyBsb29wIGluIGZyYWdtZW50IHNoYWRlclxuICAgIHVwZGF0ZVNpZ21hU3BhY2UoMCk7XG4gICAgdXBkYXRlU2lnbWFDb2xvcigwKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaWdtYVNwYWNlKHNpZ21hU3BhY2UpIHtcbiAgICAgICAgc2lnbWFTcGFjZSAqPSBNYXRoLm1heChvdXRwdXRXaWR0aCAvIHNlZ21lbnRhdGlvbldpZHRoLCBvdXRwdXRIZWlnaHQgLyBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgICAgICBjb25zdCBrU3BhcnNpdHlGYWN0b3IgPSAwLjY2OyAvLyBIaWdoZXIgaXMgc3BhcnNlci5cbiAgICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguc3FydChzaWdtYVNwYWNlKSAqIGtTcGFyc2l0eUZhY3Rvcik7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHNpZ21hU3BhY2U7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0ZXAgPiAxID8gc3RlcCAqIDAuNSA6IDA7XG4gICAgICAgIGNvbnN0IHNpZ21hVGV4ZWwgPSBNYXRoLm1heCh0ZXhlbFdpZHRoLCB0ZXhlbEhlaWdodCkgKiBzaWdtYVNwYWNlO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc3RlcExvY2F0aW9uLCBzdGVwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHJhZGl1c0xvY2F0aW9uLCByYWRpdXMpO1xuICAgICAgICBnbC51bmlmb3JtMWYob2Zmc2V0TG9jYXRpb24sIG9mZnNldCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaWdtYVRleGVsTG9jYXRpb24sIHNpZ21hVGV4ZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaWdtYUNvbG9yKHNpZ21hQ29sb3IpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNpZ21hQ29sb3JMb2NhdGlvbiwgc2lnbWFDb2xvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCB1cGRhdGVTaWdtYVNwYWNlLCB1cGRhdGVTaWdtYUNvbG9yLCBjbGVhblVwIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVzaXppbmdTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0RnJhbWU7XG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdl90ZXhDb29yZCk7XG4gICAgfVxuICBgO1xuICAgIC8vIFRGTGl0ZSBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCBhcyBmbG9hdDMyXG4gICAgY29uc3QgdGZsaXRlSW5wdXRNZW1vcnlPZmZzZXQgPSB0ZmxpdGUuX2dldElucHV0TWVtb3J5T2Zmc2V0KCkgLyA0O1xuICAgIGNvbnN0IHsgd2lkdGg6IG91dHB1dFdpZHRoLCBoZWlnaHQ6IG91dHB1dEhlaWdodCB9ID0gc2VnbWVudGF0aW9uQ29uZmlnO1xuICAgIGNvbnN0IG91dHB1dFBpeGVsQ291bnQgPSBvdXRwdXRXaWR0aCAqIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3V0cHV0VGV4dHVyZSwgMCk7XG4gICAgY29uc3Qgb3V0cHV0UGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0UGl4ZWxDb3VudCAqIDQpO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZ2wudW5pZm9ybTFpKGlucHV0RnJhbWVMb2NhdGlvbiwgMCk7XG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICAvLyBEb3dubG9hZHMgcGl4ZWxzIGFzeW5jaHJvbm91c2x5IGZyb20gR1BVIHdoaWxlIHJlbmRlcmluZyB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgLy8gVGhlIHBpeGVscyB3aWxsIGJlIGF2YWlsYWJsZSBpbiB0aGUgbmV4dCBmcmFtZSByZW5kZXIgd2hpY2ggcmVzdWx0c1xuICAgICAgICAvLyBpbiBvZmZzZXRzIGluIHRoZSBzZWdtZW50YXRpb24gb3V0cHV0IGJ1dCBpbmNyZWFzZXMgdGhlIGZyYW1lIHJhdGUuXG4gICAgICAgIHJlYWRQaXhlbHNBc3luYyhnbCwgMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgb3V0cHV0UGl4ZWxzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRQaXhlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRmbGl0ZUluZGV4ID0gdGZsaXRlSW5wdXRNZW1vcnlPZmZzZXQgKyBpICogMztcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICB0ZmxpdGUuSEVBUEYzMlt0ZmxpdGVJbmRleF0gPSBvdXRwdXRQaXhlbHNbb3V0cHV0SW5kZXhdIC8gMjU1O1xuICAgICAgICAgICAgdGZsaXRlLkhFQVBGMzJbdGZsaXRlSW5kZXggKyAxXSA9IG91dHB1dFBpeGVsc1tvdXRwdXRJbmRleCArIDFdIC8gMjU1O1xuICAgICAgICAgICAgdGZsaXRlLkhFQVBGMzJbdGZsaXRlSW5kZXggKyAyXSA9IG91dHB1dFBpeGVsc1tvdXRwdXRJbmRleCArIDJdIC8gMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShvdXRwdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCBjbGVhblVwIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU29mdG1heFN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgdGZsaXRlLCBvdXRwdXRUZXh0dXJlLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dFNlZ21lbnRhdGlvbjtcbiAgICBpbiB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHNlZ21lbnRhdGlvbiA9IHRleHR1cmUodV9pbnB1dFNlZ21lbnRhdGlvbiwgdl90ZXhDb29yZCkucmc7XG4gICAgICBmbG9hdCBzaGlmdCA9IG1heChzZWdtZW50YXRpb24uciwgc2VnbWVudGF0aW9uLmcpO1xuICAgICAgZmxvYXQgYmFja2dyb3VuZEV4cCA9IGV4cChzZWdtZW50YXRpb24uciAtIHNoaWZ0KTtcbiAgICAgIGZsb2F0IHBlcnNvbkV4cCA9IGV4cChzZWdtZW50YXRpb24uZyAtIHNoaWZ0KTtcbiAgICAgIG91dENvbG9yID0gdmVjNCh2ZWMzKDAuMCksIHBlcnNvbkV4cCAvIChiYWNrZ3JvdW5kRXhwICsgcGVyc29uRXhwKSk7XG4gICAgfVxuICBgO1xuICAgIC8vIFRGTGl0ZSBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCBhcyBmbG9hdDMyXG4gICAgY29uc3QgdGZsaXRlT3V0cHV0TWVtb3J5T2Zmc2V0ID0gdGZsaXRlLl9nZXRPdXRwdXRNZW1vcnlPZmZzZXQoKSAvIDQ7XG4gICAgY29uc3QgeyB3aWR0aDogc2VnbWVudGF0aW9uV2lkdGgsIGhlaWdodDogc2VnbWVudGF0aW9uSGVpZ2h0IH0gPSBzZWdtZW50YXRpb25Db25maWc7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUGlwZWxpbmVTdGFnZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgY29uc3QgaW5wdXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dFNlZ21lbnRhdGlvbicpO1xuICAgIGNvbnN0IGlucHV0VGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHMzJGLCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0KTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBvdXRwdXRUZXh0dXJlLCAwKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dExvY2F0aW9uLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNlZ21lbnRhdGlvbldpZHRoLCBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0LCBnbC5SRywgZ2wuRkxPQVQsIHRmbGl0ZS5IRUFQRjMyLCB0ZmxpdGVPdXRwdXRNZW1vcnlPZmZzZXQpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShpbnB1dFRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXIsIGNsZWFuVXAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRXZWJHTDJQaXBlbGluZSh2aWRlb1NvdXJjZSwgYmFja2dyb3VuZEltYWdlLCBibHVyTGV2ZWwsIGJhY2tncm91bmRGaWx0ZXIsIGNhbnZhcywgdGZsaXRlLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoIWdsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3QgeyB3aWR0aDogZnJhbWVXaWR0aCwgaGVpZ2h0OiBmcmFtZUhlaWdodCB9ID0gdmlkZW9Tb3VyY2U7XG4gICAgY29uc3QgeyB3aWR0aDogc2VnbWVudGF0aW9uV2lkdGgsIGhlaWdodDogc2VnbWVudGF0aW9uSGVpZ2h0IH0gPSBzZWdtZW50YXRpb25Db25maWc7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICBpbiB2ZWMyIGFfcG9zaXRpb247XG4gICAgaW4gdmVjMiBhX3RleENvb3JkO1xuICAgIG91dCB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XG4gICAgfVxuICBgO1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgdmVydGV4QXJyYXkgPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2ZXJ0ZXhBcnJheSk7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFstMS4wLCAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGNvbnN0IHRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMS4wLCAxLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIC8vIFdlIGRvbid0IHVzZSB0ZXhTdG9yYWdlMkQgaGVyZSBiZWNhdXNlIHRleEltYWdlMkQgc2VlbXMgZmFzdGVyXG4gICAgLy8gdG8gdXBsb2FkIHZpZGVvIHRleHR1cmUgdGhhbiB0ZXhTdWJJbWFnZTJEIGV2ZW4gdGhvdWdoIHRoZSBsYXR0ZXJcbiAgICAvLyBpcyBzdXBwb3NlZCB0byBiZSB0aGUgcmVjb21tZW5kZWQgd2F5OlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTF9BUEkvV2ViR0xfYmVzdF9wcmFjdGljZXMjdXNlX3RleHN0b3JhZ2VfdG9fY3JlYXRlX3RleHR1cmVzXG4gICAgY29uc3QgaW5wdXRGcmFtZVRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRGcmFtZVRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgLy8gVE9ETyBSZW5hbWUgc2VnbWVudGF0aW9uIGFuZCBwZXJzb24gbWFzayB0byBiZSBtb3JlIHNwZWNpZmljXG4gICAgY29uc3Qgc2VnbWVudGF0aW9uVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0KTtcbiAgICBjb25zdCBwZXJzb25NYXNrVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCk7XG4gICAgY29uc3QgcmVzaXppbmdTdGFnZSA9IGJ1aWxkUmVzaXppbmdTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBsb2FkU2VnbWVudGF0aW9uU3RhZ2UgPSBidWlsZFNvZnRtYXhTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uVGV4dHVyZSwgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlID0gYnVpbGRKb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgc2VnbWVudGF0aW9uVGV4dHVyZSwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kU3RhZ2UgPSBiYWNrZ3JvdW5kRmlsdGVyID09PSAnYmx1cidcbiAgICAgICAgPyBidWlsZEJhY2tncm91bmRCbHVyU3RhZ2UoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBibHVyTGV2ZWwgfHwgJ2hpZ2gnKVxuICAgICAgICA6IGJ1aWxkQmFja2dyb3VuZEltYWdlU3RhZ2UoZ2wsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGJhY2tncm91bmRJbWFnZSwgY2FudmFzKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dEZyYW1lVGV4dHVyZSk7XG4gICAgICAgIC8vIHRleEltYWdlMkQgc2VlbXMgZmFzdGVyIHRoYW4gdGV4U3ViSW1hZ2UyRCB0byB1cGxvYWRcbiAgICAgICAgLy8gdmlkZW8gdGV4dHVyZVxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHZpZGVvU291cmNlKTtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZlcnRleEFycmF5KTtcbiAgICAgICAgcmVzaXppbmdTdGFnZS5yZW5kZXIoKTtcbiAgICAgICAgdGZsaXRlLl9ydW5JbmZlcmVuY2UoKTtcbiAgICAgICAgbG9hZFNlZ21lbnRhdGlvblN0YWdlLnJlbmRlcigpO1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLnJlbmRlcigpO1xuICAgICAgICBiYWNrZ3JvdW5kU3RhZ2UucmVuZGVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc3RQcm9jZXNzaW5nQ29uZmlnKCkge1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLnVwZGF0ZVNpZ21hU3BhY2UoMSk7XG4gICAgICAgIGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UudXBkYXRlU2lnbWFDb2xvcigwLjEpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEltYWdlU3RhZ2UgPSBiYWNrZ3JvdW5kU3RhZ2U7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVDb3ZlcmFnZShbMC41LCAwLjc1XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVMaWdodFdyYXBwaW5nKDAuMyk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVCbGVuZE1vZGUoJ3NjcmVlbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEJsdXJTdGFnZSA9IGJhY2tncm91bmRTdGFnZTtcbiAgICAgICAgICAgIGJhY2tncm91bmRCbHVyU3RhZ2UudXBkYXRlQ292ZXJhZ2UoWzAuNSwgMC43NV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgbm8gYmFja2dyb3VuZCBpbiBhIHNlcGFyYXRlIHBpcGVsaW5lIHBhdGhcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRJbWFnZVN0YWdlID0gYmFja2dyb3VuZFN0YWdlO1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlU3RhZ2UudXBkYXRlQ292ZXJhZ2UoWzAsIDAuOTk5OV0pO1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlU3RhZ2UudXBkYXRlTGlnaHRXcmFwcGluZygwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICBiYWNrZ3JvdW5kU3RhZ2UuY2xlYW5VcCgpO1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLmNsZWFuVXAoKTtcbiAgICAgICAgbG9hZFNlZ21lbnRhdGlvblN0YWdlLmNsZWFuVXAoKTtcbiAgICAgICAgcmVzaXppbmdTdGFnZS5jbGVhblVwKCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGVyc29uTWFza1RleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHNlZ21lbnRhdGlvblRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGlucHV0RnJhbWVUZXh0dXJlKTtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRleENvb3JkQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHBvc2l0aW9uQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmVydGV4QXJyYXkpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCB1cGRhdGVQb3N0UHJvY2Vzc2luZ0NvbmZpZywgY2xlYW5VcCB9O1xufVxuXG52YXIgU2VnbWVudGF0aW9uTGV2ZWw7XG4oZnVuY3Rpb24gKFNlZ21lbnRhdGlvbkxldmVsKSB7XG4gICAgU2VnbWVudGF0aW9uTGV2ZWxbXCJMT1dcIl0gPSBcImxvd1wiO1xuICAgIFNlZ21lbnRhdGlvbkxldmVsW1wiSElHSFwiXSA9IFwiaGlnaFwiO1xufSkoU2VnbWVudGF0aW9uTGV2ZWwgfHwgKFNlZ21lbnRhdGlvbkxldmVsID0ge30pKTtcbmNvbnN0IGdldFNlZ21lbnRhdGlvblBhcmFtcyA9IChsZXZlbCkgPT4ge1xuICAgIGlmIChsZXZlbCA9PT0gU2VnbWVudGF0aW9uTGV2ZWwuSElHSCkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDE0NCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogMTYwLCBoZWlnaHQ6IDk2IH07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcih0ZmxpdGUsIHZpZGVvU291cmNlLCB0YXJnZXRDYW52YXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmRGaWx0ZXIsIGJhY2tncm91bmRJbWFnZSwgYmFja2dyb3VuZEJsdXJMZXZlbCwgc2VnbWVudGF0aW9uTGV2ZWwgPSBTZWdtZW50YXRpb25MZXZlbC5ISUdILCBmcHMgPSAzMCwgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdpbWFnZScgJiYgIWJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhY2tncm91bmRJbWFnZSBlbGVtZW50IGlzIHJlcXVpcmVkIHdoZW4gYmFja2dyb3VuZEZpbHRlciBpcyBpbWFnZWApO1xuICAgIH1cbiAgICBjb25zdCBwaXBlbGluZSA9IGJ1aWxkV2ViR0wyUGlwZWxpbmUodmlkZW9Tb3VyY2UsIGJhY2tncm91bmRJbWFnZSwgYmFja2dyb3VuZEJsdXJMZXZlbCwgYmFja2dyb3VuZEZpbHRlciwgdGFyZ2V0Q2FudmFzLCB0ZmxpdGUsIGdldFNlZ21lbnRhdGlvblBhcmFtcyhzZWdtZW50YXRpb25MZXZlbCkpO1xuICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBwaXBlbGluZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHBpcGVsaW5lLnVwZGF0ZVBvc3RQcm9jZXNzaW5nQ29uZmlnKCk7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwIC8gKGZwcyA8PSAwID8gMzAgOiBmcHMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBwaXBlbGluZS5jbGVhblVwKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVURkxpdGVTSU1ETW9kdWxlID0gKF9fTW9kdWxlKSA9PiB7XG4gIF9fTW9kdWxlID0gX19Nb2R1bGUgfHwge307XG5cbiAgdmFyIF9zY3JpcHREaXIgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdFxuICAgICAgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIE1vZHVsZSA9IHR5cGVvZiBfX01vZHVsZSAhPSAndW5kZWZpbmVkJyA/IF9fTW9kdWxlIDoge307XG4gIHZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG4gIE1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcbiAgdmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbiAgdmFyIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICAgIHRocm93IHRvVGhyb3c7XG4gIH07XG4gIHZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlO1xuICB2YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG5cbiAgZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG4gIH1cblxuICB2YXIgcmVhZEJpbmFyeTtcbiAge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgfVxuICAgIGlmIChfc2NyaXB0RGlyKSB7XG4gICAgICBzY3JpcHREaXJlY3RvcnkgPSBfc2NyaXB0RGlyO1xuICAgIH1cbiAgICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoXG4gICAgICAgIDAsXG4gICAgICAgIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCAnJykubGFzdEluZGV4T2YoJy8nKSArIDEsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgICB9XG4gIH1cbiAgdmFyIG91dCA9IE1vZHVsZVsncHJpbnQnXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICB2YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICBPYmplY3QuYXNzaWduKE1vZHVsZSwgbW9kdWxlT3ZlcnJpZGVzKTtcbiAgbW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcbiAgaWYgKE1vZHVsZVsnYXJndW1lbnRzJ10pIE1vZHVsZVsnYXJndW1lbnRzJ107XG4gIGlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuICBpZiAoTW9kdWxlWydxdWl0J10pIHF1aXRfID0gTW9kdWxlWydxdWl0J107XG4gIHZhciB3YXNtQmluYXJ5O1xuICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbiAgdmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCB0cnVlO1xuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gICAgYWJvcnQoJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcbiAgfVxuICB2YXIgd2FzbU1lbW9yeTtcbiAgdmFyIEFCT1JUID0gZmFsc2U7XG5cbiAgdmFyIFVURjhEZWNvZGVyID1cbiAgICB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuICAgIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiAgICB2YXIgZW5kUHRyID0gaWR4O1xuICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKTtcbiAgICB9XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMTI4KSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMjI0KSA9PSAxOTIpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCh1MCAmIDMxKSA8PCA2KSB8IHUxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyNDApID09IDIyNCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1MCA9XG4gICAgICAgICAgKCh1MCAmIDcpIDw8IDE4KSB8ICh1MSA8PCAxMikgfCAodTIgPDwgNikgfCAoaGVhcE9yQXJyYXlbaWR4KytdICYgNjMpO1xuICAgICAgfVxuICAgICAgaWYgKHUwIDwgNjU1MzYpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoY2ggPj4gMTApLCA1NjMyMCB8IChjaCAmIDEwMjMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBidWZmZXIsIEhFQVA4LCBIRUFQVTgsIEhFQVBVMzI7XG5cbiAgZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKSB7XG4gICAgYnVmZmVyID0gYnVmO1xuICAgIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUDE2J10gPSBuZXcgSW50MTZBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUDMyJ10gPSBuZXcgSW50MzJBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUFUxNiddID0gbmV3IFVpbnQxNkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQVTMyJ10gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQRjMyJ10gPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQRjY0J10gPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG4gIH1cblxuICBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG4gIHZhciBfX0FUUFJFUlVOX18gPSBbXTtcbiAgdmFyIF9fQVRJTklUX18gPSBbXTtcbiAgdmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxuICBmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuICAgIHJldHVybiBub0V4aXRSdW50aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlUnVuKCkge1xuICAgIGlmIChNb2R1bGVbJ3ByZVJ1biddKSB7XG4gICAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgICBhZGRPblByZVJ1bihNb2R1bGVbJ3ByZVJ1biddLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0UnVuKCkge1xuICAgIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3Bvc3RSdW4nXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XG4gICAgICB3aGlsZSAoTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XG4gICAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuICAgIF9fQVRJTklUX18udW5zaGlmdChjYik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xuICB9XG5cbiAgdmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG4gIHZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICBydW5EZXBlbmRlbmNpZXMrKztcbiAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcbiAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gICAge1xuICAgICAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XG4gICAgICAgIE1vZHVsZVsnb25BYm9ydCddKHdoYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGF0ID0gJ0Fib3J0ZWQoJyArIHdoYXQgKyAnKSc7XG4gICAgZXJyKHdoYXQpO1xuICAgIEFCT1JUID0gdHJ1ZTtcbiAgICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcbiAgICB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICAgIHRocm93IGU7XG4gIH1cblxuICB2YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJztcblxuICBmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbiAgfVxuXG4gIHZhciB3YXNtQmluYXJ5RmlsZTtcbiAgd2FzbUJpbmFyeUZpbGUgPSAndGZsaXRlLXNpbWQud2FzbSc7XG4gIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICAgIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkQmluYXJ5KSA7XG4gICAgICB0aHJvdyAnYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQnO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGFib3J0KGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcbiAgICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiApKSB7XG4gICAgICBpZiAodHlwZW9mIGZldGNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIGVudjogYXNtTGlicmFyeUFyZyxcbiAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IGFzbUxpYnJhcnlBcmcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgICBNb2R1bGVbJ2FzbSddID0gZXhwb3J0cztcbiAgICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ2FzbSddWydtZW1vcnknXTtcbiAgICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtcbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUnXTtcbiAgICAgIGFkZE9uSW5pdChNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKTtcbiAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koKTtcbiAgICB9XG5cbiAgICBhZGRSdW5EZXBlbmRlbmN5KCk7XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlY2VpdmVyLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgZXJyKCdmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAnICsgcmVhc29uKTtcbiAgICAgICAgICBhYm9ydChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCkge1xuICAgICAgaWYgKFxuICAgICAgICAhd2FzbUJpbmFyeSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbmZvKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICBlcnIoJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcbiAgICAgICAgICAgICAgZXJyKCdmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbicpO1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZXhwb3J0cyA9IE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycignTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xuICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5uYW1lID0gJ0V4aXRTdGF0dXMnO1xuICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19kbGluaXQobWFpbl9kc29faGFuZGxlKSB7fVxuXG4gIHZhciBkbG9wZW5NaXNzaW5nRXJyb3IgPVxuICAgICdUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZyc7XG5cbiAgZnVuY3Rpb24gX19kbG9wZW5fanMoZmlsZW5hbWUsIGZsYWcpIHtcbiAgICBhYm9ydChkbG9wZW5NaXNzaW5nRXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gX19kbHN5bV9qcyhoYW5kbGUsIHN5bWJvbCkge1xuICAgIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG4gIH1cblxuICB2YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYygpIHtcbiAgICByZXR1cm4gbm93SXNNb25vdG9uaWM7XG4gIH1cblxuICBmdW5jdGlvbiBfX21tYXBfanMobGVuLCBwcm90LCBmbGFncywgZmQsIG9mZiwgYWxsb2NhdGVkKSB7XG4gICAgcmV0dXJuIC01MjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9fbXVubWFwX2pzKGFkZHIsIGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmZzZXQpIHt9XG5cbiAgZnVuY3Rpb24gX2Fib3J0KCkge1xuICAgIGFib3J0KCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2RhdGVfbm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgICByZXR1cm4gMjE0NzQ4MzY0ODtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpIHtcbiAgICByZXR1cm4gZ2V0SGVhcE1heCgpO1xuICB9XG5cbiAgdmFyIF9lbXNjcmlwdGVuX2dldF9ub3c7XG4gIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7XG4gICAgSEVBUFU4LmNvcHlXaXRoaW4oZGVzdCwgc3JjLCBzcmMgKyBudW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHdhc21NZW1vcnkuZ3Jvdygoc2l6ZSAtIGJ1ZmZlci5ieXRlTGVuZ3RoICsgNjU1MzUpID4+PiAxNik7XG4gICAgICB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcik7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiAgICByZXF1ZXN0ZWRTaXplID0gcmVxdWVzdGVkU2l6ZSA+Pj4gMDtcbiAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYWxpZ25VcCA9ICh4LCBtdWx0aXBsZSkgPT4geCArICgobXVsdGlwbGUgLSAoeCAlIG11bHRpcGxlKSkgJSBtdWx0aXBsZSk7XG4gICAgZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTtcbiAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4oXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplLFxuICAgICAgICByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2LFxuICAgICAgKTtcbiAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4oXG4gICAgICAgIG1heEhlYXBTaXplLFxuICAgICAgICBhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpLFxuICAgICAgKTtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7XG4gICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBFTlYgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRFeGVjdXRhYmxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgaWYgKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3MpIHtcbiAgICAgIHZhciBsYW5nID1cbiAgICAgICAgKFxuICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAgICdDJ1xuICAgICAgICApLnJlcGxhY2UoJy0nLCAnXycpICsgJy5VVEYtOCc7XG4gICAgICB2YXIgZW52ID0ge1xuICAgICAgICBVU0VSOiAnd2ViX3VzZXInLFxuICAgICAgICBMT0dOQU1FOiAnd2ViX3VzZXInLFxuICAgICAgICBQQVRIOiAnLycsXG4gICAgICAgIFBXRDogJy8nLFxuICAgICAgICBIT01FOiAnL2hvbWUvd2ViX3VzZXInLFxuICAgICAgICBMQU5HOiBsYW5nLFxuICAgICAgICBfOiBnZXRFeGVjdXRhYmxlTmFtZSgpLFxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICAgICAgIGlmIChFTlZbeF0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIGVudlt4XTtcbiAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICB9XG4gICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHggKyAnPScgKyBlbnZbeF0pO1xuICAgICAgfVxuICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG4gICAgcmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5ncztcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgSEVBUDhbYnVmZmVyKysgPj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sIGVudmlyb25fYnVmKSB7XG4gICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgIGdldEVudlN0cmluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICBIRUFQVTMyWyhfX2Vudmlyb24gKyBpICogNCkgPj4gMl0gPSBwdHI7XG4gICAgICB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyaW5nLCBwdHIpO1xuICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICB9KTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICB2YXIgc3RyaW5ncyA9IGdldEVudlN0cmluZ3MoKTtcbiAgICBIRUFQVTMyW3BlbnZpcm9uX2NvdW50ID4+IDJdID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuICAgIH0pO1xuICAgIEhFQVBVMzJbcGVudmlyb25fYnVmX3NpemUgPj4gMl0gPSBidWZTaXplO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gICAgaWYgKCFrZWVwUnVudGltZUFsaXZlKCkpIHtcbiAgICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKGNvZGUpO1xuICAgICAgQUJPUlQgPSB0cnVlO1xuICAgIH1cbiAgICBxdWl0Xyhjb2RlLCBuZXcgRXhpdFN0YXR1cyhjb2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBleGl0SlMoc3RhdHVzLCBpbXBsaWNpdCkge1xuICAgIF9wcm9jX2V4aXQoc3RhdHVzKTtcbiAgfVxuXG4gIHZhciBfZXhpdCA9IGV4aXRKUztcblxuICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgICByZXR1cm4gNTI7XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XG4gICAgcmV0dXJuIDcwO1xuICB9XG5cbiAgdmFyIHByaW50Q2hhckJ1ZmZlcnMgPSBbbnVsbCwgW10sIFtdXTtcblxuICBmdW5jdGlvbiBwcmludENoYXIoc3RyZWFtLCBjdXJyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICB2YXIgYnVmZmVyID0gcHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO1xuICAgIGlmIChjdXJyID09PSAwIHx8IGN1cnIgPT09IDEwKSB7XG4gICAgICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKGlvdiArIDQpID4+IDJdO1xuICAgICAgaW92ICs9IDg7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHByaW50Q2hhcihmZCwgSEVBUFU4W3B0ciArIGpdKTtcbiAgICAgIH1cbiAgICAgIG51bSArPSBsZW47XG4gICAgfVxuICAgIEhFQVBVMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhbmRvbURldmljZSgpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiByYW5kb21CdWZmZXJbMF07XG4gICAgICB9O1xuICAgIH0gZWxzZSByZXR1cm4gKCkgPT4gYWJvcnQoJ3JhbmRvbURldmljZScpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgZnVuY3Rpb24gX2dldGVudHJvcHkoYnVmZmVyLCBzaXplKSB7XG4gICAgaWYgKCFfZ2V0ZW50cm9weS5yYW5kb21EZXZpY2UpIHtcbiAgICAgIF9nZXRlbnRyb3B5LnJhbmRvbURldmljZSA9IGdldFJhbmRvbURldmljZSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgSEVBUDhbKGJ1ZmZlciArIGkpID4+IDBdID0gX2dldGVudHJvcHkucmFuZG9tRGV2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGFzbUxpYnJhcnlBcmcgPSB7XG4gICAgX2RsaW5pdDogX19kbGluaXQsXG4gICAgX2Rsb3Blbl9qczogX19kbG9wZW5fanMsXG4gICAgX2Rsc3ltX2pzOiBfX2Rsc3ltX2pzLFxuICAgIF9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljOiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXG4gICAgX21tYXBfanM6IF9fbW1hcF9qcyxcbiAgICBfbXVubWFwX2pzOiBfX211bm1hcF9qcyxcbiAgICBhYm9ydDogX2Fib3J0LFxuICAgIGVtc2NyaXB0ZW5fZGF0ZV9ub3c6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuICAgIGVtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4OiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gICAgZW1zY3JpcHRlbl9nZXRfbm93OiBfZW1zY3JpcHRlbl9nZXRfbm93LFxuICAgIGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcbiAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICBlbnZpcm9uX2dldDogX2Vudmlyb25fZ2V0LFxuICAgIGVudmlyb25fc2l6ZXNfZ2V0OiBfZW52aXJvbl9zaXplc19nZXQsXG4gICAgZXhpdDogX2V4aXQsXG4gICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgICBmZF9zZWVrOiBfZmRfc2VlayxcbiAgICBmZF93cml0ZTogX2ZkX3dyaXRlLFxuICAgIGdldGVudHJvcHk6IF9nZXRlbnRyb3B5LFxuICB9O1xuICBjcmVhdGVXYXNtKCk7XG4gIChNb2R1bGVbJ19fX3dhc21fY2FsbF9jdG9ycyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX193YXNtX2NhbGxfY3RvcnMnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J10gPVxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoTW9kdWxlW1xuICAgICAgICAnX2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIChNb2R1bGVbJ19nZXRJbnB1dE1lbW9yeU9mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRNZW1vcnlPZmZzZXQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRJbnB1dE1lbW9yeU9mZnNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldElucHV0SGVpZ2h0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRJbnB1dEhlaWdodCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0SGVpZ2h0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0SW5wdXRXaWR0aCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRXaWR0aCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0V2lkdGgnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRJbnB1dENoYW5uZWxDb3VudCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRDaGFubmVsQ291bnQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRJbnB1dENoYW5uZWxDb3VudCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE91dHB1dE1lbW9yeU9mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0TWVtb3J5T2Zmc2V0J10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0T3V0cHV0TWVtb3J5T2Zmc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0T3V0cHV0SGVpZ2h0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRPdXRwdXRIZWlnaHQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRIZWlnaHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRPdXRwdXRXaWR0aCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0V2lkdGgnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRXaWR0aCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE91dHB1dENoYW5uZWxDb3VudCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0Q2hhbm5lbENvdW50J10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0T3V0cHV0Q2hhbm5lbENvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfbG9hZE1vZGVsJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19sb2FkTW9kZWwnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydsb2FkTW9kZWwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19ydW5JbmZlcmVuY2UnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnX3J1bkluZmVyZW5jZSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ3J1bkluZmVyZW5jZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX21hbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfbWFsbG9jJ10gPSBNb2R1bGVbJ2FzbSddWydtYWxsb2MnXSkuYXBwbHkoXG4gICAgICBudWxsLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gIH0pO1xuICAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19fZXJybm9fbG9jYXRpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19fX2RsX3NldGVyciddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX19kbF9zZXRlcnInXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydfX2RsX3NldGVyciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tTYXZlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ3N0YWNrU2F2ZSddID0gTW9kdWxlWydhc20nXVsnc3RhY2tTYXZlJ10pLmFwcGx5KFxuICAgICAgbnVsbCxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ3N0YWNrUmVzdG9yZSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ3N0YWNrUmVzdG9yZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tBbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydzdGFja0FsbG9jJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnc3RhY2tBbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qamonXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9qamonXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2pqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qaWlpJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfamlpaSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfamlpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9paWlpamonXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9paWlpamonXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpaWlqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF92aWlqaiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX3ZpaWpqJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF92aWlpampqJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWpqaiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWpqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9paWpqaWlpaSddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX2lpamppaWlpJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWpqaWlpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qaWppJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfamlqaSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfamlqaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgdmFyIGNhbGxlZFJ1bjtcbiAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAgIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgICBpZiAoIWNhbGxlZFJ1bikgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJ1bihhcmdzKSB7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlUnVuKCk7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb1J1bigpIHtcbiAgICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gdHJ1ZTtcbiAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xuICAgICAgaW5pdFJ1bnRpbWUoKTtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgICAgIGlmIChNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSgpO1xuICAgICAgcG9zdFJ1bigpO1xuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICBkb1J1bigpO1xuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvUnVuKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XG4gICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xuICAgIH1cbiAgfVxuICBydW4oKTtcblxuICByZXR1cm4gX19Nb2R1bGUucmVhZHk7XG59O1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjEuMFwiIDtcbmNvbnN0IHBhY2thZ2VOYW1lID0gXCJAc3RyZWFtLWlvL3ZpZGVvLWZpbHRlcnMtd2ViXCIgO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yIC0gbW9kdWxlIGlzIG5vdCBkZWNsYXJlZFxuLy8gVGhpcyBpcyBhIFdlYkFzc2VtYmx5IG1vZHVsZSBjb21waWxlZCBmcm9tIHRoZSBUZW5zb3JGbG93IExpdGUgQysrIGxpYnJhcnkuXG5jb25zdCBjcmVhdGVURkxpdGUgPSBjcmVhdGVURkxpdGVTSU1ETW9kdWxlO1xuY29uc3QgbG9hZFRGTGl0ZSA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGJhc2VQYXRoID0gYGh0dHBzOi8vdW5wa2cuY29tLyR7cGFja2FnZU5hbWV9QCR7dmVyc2lvbn0vdGZgLCB0ZkZpbGVQYXRoID0gYCR7YmFzZVBhdGh9L3RmbGl0ZS90ZmxpdGUtc2ltZC53YXNtYCwgbW9kZWxGaWxlUGF0aCA9IGAke2Jhc2VQYXRofS9tb2RlbHMvc2VnbV9mdWxsX3Y2NzkudGZsaXRlYCwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgW3RmTGl0ZSwgbW9kZWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjcmVhdGVURkxpdGUoeyBsb2NhdGVGaWxlOiAoKSA9PiB0ZkZpbGVQYXRoIH0pLFxuICAgICAgICBmZXRjaE1vZGVsKG1vZGVsRmlsZVBhdGgpLFxuICAgIF0pO1xuICAgIGNvbnN0IG1vZGVsQnVmZmVyT2Zmc2V0ID0gdGZMaXRlLl9nZXRNb2RlbEJ1ZmZlck1lbW9yeU9mZnNldCgpO1xuICAgIHRmTGl0ZS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KG1vZGVsKSwgbW9kZWxCdWZmZXJPZmZzZXQpO1xuICAgIHRmTGl0ZS5fbG9hZE1vZGVsKG1vZGVsLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0ZkxpdGU7XG59O1xubGV0IGxhc3RNb2RlbEZpbGVQYXRoID0gJyc7XG5sZXQgbW9kZWxGaWxlQ2FjaGU7XG5jb25zdCBmZXRjaE1vZGVsID0gYXN5bmMgKG1vZGVsRmlsZVBhdGgpID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IG1vZGVsRmlsZVBhdGggPT09IGxhc3RNb2RlbEZpbGVQYXRoICYmIG1vZGVsRmlsZUNhY2hlXG4gICAgICAgID8gbW9kZWxGaWxlQ2FjaGVcbiAgICAgICAgOiBhd2FpdCBmZXRjaChtb2RlbEZpbGVQYXRoKS50aGVuKChyKSA9PiByLmFycmF5QnVmZmVyKCkpO1xuICAgIC8vIENhY2hlIHRoZSBtb2RlbCBmaWxlIGZvciBmdXR1cmUgdXNlLlxuICAgIG1vZGVsRmlsZUNhY2hlID0gbW9kZWw7XG4gICAgbGFzdE1vZGVsRmlsZVBhdGggPSBtb2RlbEZpbGVQYXRoO1xuICAgIHJldHVybiBtb2RlbDtcbn07XG5cbmV4cG9ydCB7IFNlZ21lbnRhdGlvbkxldmVsLCBjcmVhdGVSZW5kZXJlciwgaXNQbGF0Zm9ybVN1cHBvcnRlZCwgbG9hZFRGTGl0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stream-io+video-filters-web@0.0.1/node_modules/@stream-io/video-filters-web/dist/index.es.js\n");

/***/ })

};
;