"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io+video-client@0.6.10";
exports.ids = ["vendor-chunks/@stream-io+video-client@0.6.10"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@stream-io+video-client@0.6.10/node_modules/@stream-io/video-client/dist/index.es.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stream-io+video-client@0.6.10/node_modules/@stream-io/video-client/dist/index.es.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   AxiosError: () => (/* reexport safe */ axios__WEBPACK_IMPORTED_MODULE_1__.AxiosError),\n/* harmony export */   Browsers: () => (/* binding */ browsers),\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   CallState: () => (/* binding */ CallState),\n/* harmony export */   CallType: () => (/* binding */ CallType),\n/* harmony export */   CallTypes: () => (/* binding */ CallTypes),\n/* harmony export */   CallingState: () => (/* binding */ CallingState),\n/* harmony export */   CameraManager: () => (/* binding */ CameraManager),\n/* harmony export */   CameraManagerState: () => (/* binding */ CameraManagerState),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DebounceType: () => (/* binding */ DebounceType),\n/* harmony export */   DynascaleManager: () => (/* binding */ DynascaleManager),\n/* harmony export */   ErrorFromResponse: () => (/* binding */ ErrorFromResponse),\n/* harmony export */   InputMediaDeviceManager: () => (/* binding */ InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* binding */ InputMediaDeviceManagerState),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   LayoutSettingsRequestNameEnum: () => (/* binding */ LayoutSettingsRequestNameEnum),\n/* harmony export */   MicrophoneManager: () => (/* binding */ MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* binding */ MicrophoneManagerState),\n/* harmony export */   OwnCapability: () => (/* binding */ OwnCapability),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* binding */ RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* binding */ RecordSettingsRequestQualityEnum),\n/* harmony export */   RxUtils: () => (/* binding */ rxUtils),\n/* harmony export */   ScreenShareManager: () => (/* binding */ ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* binding */ ScreenShareState),\n/* harmony export */   SfuEvents: () => (/* binding */ events),\n/* harmony export */   SfuModels: () => (/* binding */ models),\n/* harmony export */   SpeakerManager: () => (/* binding */ SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* binding */ SpeakerState),\n/* harmony export */   StreamSfuClient: () => (/* binding */ StreamSfuClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* binding */ StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoServerClient: () => (/* binding */ StreamVideoServerClient),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* binding */ StreamVideoWriteableStateStore),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* binding */ TranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* binding */ ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* binding */ VisibilityState),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* binding */ checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* binding */ combineComparators),\n/* harmony export */   conditional: () => (/* binding */ conditional),\n/* harmony export */   createSoundDetector: () => (/* binding */ createSoundDetector),\n/* harmony export */   defaultSortPreset: () => (/* binding */ defaultSortPreset),\n/* harmony export */   descending: () => (/* binding */ descending),\n/* harmony export */   deviceIds$: () => (/* binding */ deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* binding */ disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* binding */ dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* binding */ getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* binding */ getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* binding */ getAudioStream),\n/* harmony export */   getClientDetails: () => (/* binding */ getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* binding */ getDeviceInfo),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   getOSInfo: () => (/* binding */ getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* binding */ getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* binding */ getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* binding */ getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* binding */ getVideoStream),\n/* harmony export */   getWebRTCInfo: () => (/* binding */ getWebRTCInfo),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* binding */ livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* binding */ logLevels),\n/* harmony export */   logToConsole: () => (/* binding */ logToConsole),\n/* harmony export */   name: () => (/* binding */ name),\n/* harmony export */   noopComparator: () => (/* binding */ noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* binding */ paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* binding */ pinned),\n/* harmony export */   publishingAudio: () => (/* binding */ publishingAudio),\n/* harmony export */   publishingVideo: () => (/* binding */ publishingVideo),\n/* harmony export */   reactionType: () => (/* binding */ reactionType),\n/* harmony export */   role: () => (/* binding */ role),\n/* harmony export */   screenSharing: () => (/* binding */ screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* binding */ setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   setOSInfo: () => (/* binding */ setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* binding */ setSdkInfo),\n/* harmony export */   setWebRTCInfo: () => (/* binding */ setWebRTCInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* binding */ speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* binding */ speaking)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/.pnpm/webrtc-adapter@8.2.3/node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime@2.9.4/node_modules/@protobuf-ts/runtime/build/es2015/message-type.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime@2.9.4/node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime@2.9.4/node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime@2.9.4/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime@2.9.4/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.9.4/node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+runtime-rpc@2.9.4/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/.pnpm/axios@1.6.8/node_modules/axios/index.js\");\n/* harmony import */ var _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @protobuf-ts/twirp-transport */ \"(ssr)/./node_modules/.pnpm/@protobuf-ts+twirp-transport@2.9.4/node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/pairwise.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/debounce.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ \"(ssr)/./node_modules/.pnpm/sdp-transform@2.14.2/node_modules/sdp-transform/lib/index.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ua-parser-js */ \"(ssr)/./node_modules/.pnpm/ua-parser-js@1.0.37/node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! isomorphic-ws */ \"(ssr)/./node_modules/.pnpm/isomorphic-ws@5.0.0_ws@8.17.0/node_modules/isomorphic-ws/node.js\");\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jsonwebtoken */ \"(ssr)/./node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @export\n */ const AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const AudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: \"firebase\",\n    APN: \"apn\",\n    HUAWEI: \"huawei\",\n    XIAOMI: \"xiaomi\"\n};\n/**\n * @export\n */ const LayoutSettingsNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * @export\n */ const LayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * All possibility of string to use\n * @export\n */ const OwnCapability = {\n    BLOCK_USERS: \"block-users\",\n    CREATE_CALL: \"create-call\",\n    CREATE_REACTION: \"create-reaction\",\n    END_CALL: \"end-call\",\n    JOIN_BACKSTAGE: \"join-backstage\",\n    JOIN_CALL: \"join-call\",\n    JOIN_ENDED_CALL: \"join-ended-call\",\n    MUTE_USERS: \"mute-users\",\n    PIN_FOR_EVERYONE: \"pin-for-everyone\",\n    READ_CALL: \"read-call\",\n    REMOVE_CALL_MEMBER: \"remove-call-member\",\n    SCREENSHARE: \"screenshare\",\n    SEND_AUDIO: \"send-audio\",\n    SEND_VIDEO: \"send-video\",\n    START_BROADCAST_CALL: \"start-broadcast-call\",\n    START_RECORD_CALL: \"start-record-call\",\n    START_TRANSCRIPTION_CALL: \"start-transcription-call\",\n    STOP_BROADCAST_CALL: \"stop-broadcast-call\",\n    STOP_RECORD_CALL: \"stop-record-call\",\n    STOP_TRANSCRIPTION_CALL: \"stop-transcription-call\",\n    UPDATE_CALL: \"update-call\",\n    UPDATE_CALL_MEMBER: \"update-call-member\",\n    UPDATE_CALL_PERMISSIONS: \"update-call-permissions\",\n    UPDATE_CALL_SETTINGS: \"update-call-settings\"\n};\n/**\n * @export\n */ const RecordSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const RecordSettingsRequestQualityEnum = {\n    _360P: \"360p\",\n    _480P: \"480p\",\n    _720P: \"720p\",\n    _1080P: \"1080p\",\n    _1440P: \"1440p\"\n};\n/**\n * @export\n */ const TranscriptionSettingsModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const TranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const VideoSettingsCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\n/**\n * @export\n */ const VideoSettingsRequestCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\nclass ErrorFromResponse extends Error {\n}\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n *  The JSON representation for `NullValue` is JSON `null`.\n *\n * @generated from protobuf enum google.protobuf.NullValue\n */ var NullValue;\n(function(NullValue) {\n    /**\n     * Null value.\n     *\n     * @generated from protobuf enum value: NULL_VALUE = 0;\n     */ NullValue[NullValue[\"NULL_VALUE\"] = 0] = \"NULL_VALUE\";\n})(NullValue || (NullValue = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass Struct$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Struct\", [\n            {\n                no: 1,\n                name: \"fields\",\n                kind: \"map\",\n                K: 9 /*ScalarType.STRING*/ ,\n                V: {\n                    kind: \"message\",\n                    T: ()=>Value\n                }\n            }\n        ]);\n    }\n    /**\n     * Encode `Struct` to JSON object.\n     */ internalJsonWrite(message, options) {\n        let json = {};\n        for (let [k, v] of Object.entries(message.fields)){\n            json[k] = Value.toJson(v);\n        }\n        return json;\n    }\n    /**\n     * Decode `Struct` from JSON object.\n     */ internalJsonRead(json, options, target) {\n        if (!(0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.isJsonObject)(json)) throw new globalThis.Error(\"Unable to parse message \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        if (!target) target = this.create();\n        for (let [k, v] of globalThis.Object.entries(json)){\n            target.fields[k] = Value.fromJson(v);\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fields = {};\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* map<string, google.protobuf.Value> fields */ 1:\n                    this.binaryReadMap1(message.fields, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    binaryReadMap1(map, reader, options) {\n        let len = reader.uint32(), end = reader.pos + len, key, val;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = Value.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default:\n                    throw new globalThis.Error(\"unknown map entry field for field google.protobuf.Struct.fields\");\n            }\n        }\n        map[key ?? \"\"] = val ?? Value.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* map<string, google.protobuf.Value> fields = 1; */ for (let k of globalThis.Object.keys(message.fields)){\n            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork().tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(k);\n            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            Value.internalBinaryWrite(message.fields[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Struct\n */ const Struct = new Struct$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Value$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Value\", [\n            {\n                no: 1,\n                name: \"null_value\",\n                kind: \"enum\",\n                oneof: \"kind\",\n                T: ()=>[\n                        \"google.protobuf.NullValue\",\n                        NullValue\n                    ]\n            },\n            {\n                no: 2,\n                name: \"number_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 1 /*ScalarType.DOUBLE*/ \n            },\n            {\n                no: 3,\n                name: \"string_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"bool_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 5,\n                name: \"struct_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"list_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>ListValue\n            }\n        ]);\n    }\n    /**\n     * Encode `Value` to JSON value.\n     */ internalJsonWrite(message, options) {\n        if (message.kind.oneofKind === undefined) throw new globalThis.Error();\n        switch(message.kind.oneofKind){\n            case undefined:\n                throw new globalThis.Error();\n            case \"boolValue\":\n                return message.kind.boolValue;\n            case \"nullValue\":\n                return null;\n            case \"numberValue\":\n                let numberValue = message.kind.numberValue;\n                if (typeof numberValue == \"number\" && !Number.isFinite(numberValue)) throw new globalThis.Error();\n                return numberValue;\n            case \"stringValue\":\n                return message.kind.stringValue;\n            case \"listValue\":\n                let listValueField = this.fields.find((f)=>f.no === 6);\n                if (listValueField?.kind !== \"message\") throw new globalThis.Error();\n                return listValueField.T().toJson(message.kind.listValue);\n            case \"structValue\":\n                let structValueField = this.fields.find((f)=>f.no === 5);\n                if (structValueField?.kind !== \"message\") throw new globalThis.Error();\n                return structValueField.T().toJson(message.kind.structValue);\n        }\n    }\n    /**\n     * Decode `Value` from JSON value.\n     */ internalJsonRead(json, options, target) {\n        if (!target) target = this.create();\n        switch(typeof json){\n            case \"number\":\n                target.kind = {\n                    oneofKind: \"numberValue\",\n                    numberValue: json\n                };\n                break;\n            case \"string\":\n                target.kind = {\n                    oneofKind: \"stringValue\",\n                    stringValue: json\n                };\n                break;\n            case \"boolean\":\n                target.kind = {\n                    oneofKind: \"boolValue\",\n                    boolValue: json\n                };\n                break;\n            case \"object\":\n                if (json === null) {\n                    target.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: NullValue.NULL_VALUE\n                    };\n                } else if (globalThis.Array.isArray(json)) {\n                    target.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.fromJson(json)\n                    };\n                } else {\n                    target.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.fromJson(json)\n                    };\n                }\n                break;\n            default:\n                throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.kind = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* google.protobuf.NullValue null_value */ 1:\n                    message.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: reader.int32()\n                    };\n                    break;\n                case /* double number_value */ 2:\n                    message.kind = {\n                        oneofKind: \"numberValue\",\n                        numberValue: reader.double()\n                    };\n                    break;\n                case /* string string_value */ 3:\n                    message.kind = {\n                        oneofKind: \"stringValue\",\n                        stringValue: reader.string()\n                    };\n                    break;\n                case /* bool bool_value */ 4:\n                    message.kind = {\n                        oneofKind: \"boolValue\",\n                        boolValue: reader.bool()\n                    };\n                    break;\n                case /* google.protobuf.Struct struct_value */ 5:\n                    message.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.internalBinaryRead(reader, reader.uint32(), options, message.kind.structValue)\n                    };\n                    break;\n                case /* google.protobuf.ListValue list_value */ 6:\n                    message.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.internalBinaryRead(reader, reader.uint32(), options, message.kind.listValue)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* google.protobuf.NullValue null_value = 1; */ if (message.kind.oneofKind === \"nullValue\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.kind.nullValue);\n        /* double number_value = 2; */ if (message.kind.oneofKind === \"numberValue\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit64).double(message.kind.numberValue);\n        /* string string_value = 3; */ if (message.kind.oneofKind === \"stringValue\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.kind.stringValue);\n        /* bool bool_value = 4; */ if (message.kind.oneofKind === \"boolValue\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.kind.boolValue);\n        /* google.protobuf.Struct struct_value = 5; */ if (message.kind.oneofKind === \"structValue\") Struct.internalBinaryWrite(message.kind.structValue, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.ListValue list_value = 6; */ if (message.kind.oneofKind === \"listValue\") ListValue.internalBinaryWrite(message.kind.listValue, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Value\n */ const Value = new Value$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ListValue$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.ListValue\", [\n            {\n                no: 1,\n                name: \"values\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Value\n            }\n        ]);\n    }\n    /**\n     * Encode `ListValue` to JSON array.\n     */ internalJsonWrite(message, options) {\n        return message.values.map((v)=>Value.toJson(v));\n    }\n    /**\n     * Decode `ListValue` from JSON array.\n     */ internalJsonRead(json, options, target) {\n        if (!globalThis.Array.isArray(json)) throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        if (!target) target = this.create();\n        let values = json.map((v)=>Value.fromJson(v));\n        target.values.push(...values);\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.values = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated google.protobuf.Value values */ 1:\n                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated google.protobuf.Value values = 1; */ for(let i = 0; i < message.values.length; i++)Value.internalBinaryWrite(message.values[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.ListValue\n */ const ListValue = new ListValue$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Timestamp\", [\n            {\n                no: 1,\n                name: \"seconds\",\n                kind: \"scalar\",\n                T: 3 /*ScalarType.INT64*/ \n            },\n            {\n                no: 2,\n                name: \"nanos\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */ now() {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */ toDate(message) {\n        return new Date(_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */ fromDate(date) {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonWrite(message, options) {\n        let ms = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0) throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\") z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonRead(json, options, target) {\n        if (typeof json !== \"string\") throw new Error(\"Unable to parse Timestamp from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target) target = this.create();\n        target.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(ms / 1000).toString();\n        target.nanos = 0;\n        if (matches[7]) target.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.seconds = \"0\";\n        message.nanos = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toString();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int64 seconds = 1; */ if (message.seconds !== \"0\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */ if (message.nanos !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */ const Timestamp = new Timestamp$Type();\n/**\n * @generated from protobuf enum stream.video.sfu.models.PeerType\n */ var PeerType;\n(function(PeerType) {\n    /**\n     * todo fix me (marcelo)\n     *\n     * @generated from protobuf enum value: PEER_TYPE_PUBLISHER_UNSPECIFIED = 0;\n     */ PeerType[PeerType[\"PUBLISHER_UNSPECIFIED\"] = 0] = \"PUBLISHER_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PEER_TYPE_SUBSCRIBER = 1;\n     */ PeerType[PeerType[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(PeerType || (PeerType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ConnectionQuality\n */ var ConnectionQuality;\n(function(ConnectionQuality) {\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_UNSPECIFIED = 0;\n     */ ConnectionQuality[ConnectionQuality[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_POOR = 1;\n     */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 1] = \"POOR\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_GOOD = 2;\n     */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 2] = \"GOOD\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_EXCELLENT = 3;\n     */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 3] = \"EXCELLENT\";\n})(ConnectionQuality || (ConnectionQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_LOW_UNSPECIFIED = 0;\n     */ VideoQuality[VideoQuality[\"LOW_UNSPECIFIED\"] = 0] = \"LOW_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_MID = 1;\n     */ VideoQuality[VideoQuality[\"MID\"] = 1] = \"MID\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_HIGH = 2;\n     */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_OFF = 3;\n     */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_UNSPECIFIED = 0;\n     */ TrackType[TrackType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_AUDIO = 1;\n     */ TrackType[TrackType[\"AUDIO\"] = 1] = \"AUDIO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_VIDEO = 2;\n     */ TrackType[TrackType[\"VIDEO\"] = 2] = \"VIDEO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE = 3;\n     */ TrackType[TrackType[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE_AUDIO = 4;\n     */ TrackType[TrackType[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackType || (TrackType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ErrorCode\n */ var ErrorCode;\n(function(ErrorCode) {\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;\n     */ ErrorCode[ErrorCode[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_NOT_FOUND = 100;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_NOT_FOUND\"] = 100] = \"PUBLISH_TRACK_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACKS_MISMATCH = 101;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACKS_MISMATCH\"] = 101] = \"PUBLISH_TRACKS_MISMATCH\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER = 102;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_OUT_OF_ORDER\"] = 102] = \"PUBLISH_TRACK_OUT_OF_ORDER\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND = 103;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\"] = 103] = \"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_LIVE_ENDED = 104;\n     */ ErrorCode[ErrorCode[\"LIVE_ENDED\"] = 104] = \"LIVE_ENDED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_NOT_FOUND = 200;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_NOT_FOUND\"] = 200] = \"PARTICIPANT_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING_OUT = 201;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING_OUT\"] = 201] = \"PARTICIPANT_MIGRATING_OUT\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATION_FAILED = 202;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATION_FAILED\"] = 202] = \"PARTICIPANT_MIGRATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING = 203;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING\"] = 203] = \"PARTICIPANT_MIGRATING\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_RECONNECT_FAILED = 204;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_RECONNECT_FAILED\"] = 204] = \"PARTICIPANT_RECONNECT_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MEDIA_TRANSPORT_FAILURE = 205;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\"] = 205] = \"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_CALL_NOT_FOUND = 300;\n     */ ErrorCode[ErrorCode[\"CALL_NOT_FOUND\"] = 300] = \"CALL_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_REQUEST_VALIDATION_FAILED = 400;\n     */ ErrorCode[ErrorCode[\"REQUEST_VALIDATION_FAILED\"] = 400] = \"REQUEST_VALIDATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNAUTHENTICATED = 401;\n     */ ErrorCode[ErrorCode[\"UNAUTHENTICATED\"] = 401] = \"UNAUTHENTICATED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PERMISSION_DENIED = 403;\n     */ ErrorCode[ErrorCode[\"PERMISSION_DENIED\"] = 403] = \"PERMISSION_DENIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_TOO_MANY_REQUESTS = 429;\n     */ ErrorCode[ErrorCode[\"TOO_MANY_REQUESTS\"] = 429] = \"TOO_MANY_REQUESTS\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_INTERNAL_SERVER_ERROR = 500;\n     */ ErrorCode[ErrorCode[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_SHUTTING_DOWN = 600;\n     */ ErrorCode[ErrorCode[\"SFU_SHUTTING_DOWN\"] = 600] = \"SFU_SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_FULL = 700;\n     */ ErrorCode[ErrorCode[\"SFU_FULL\"] = 700] = \"SFU_FULL\";\n})(ErrorCode || (ErrorCode = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.SdkType\n */ var SdkType;\n(function(SdkType) {\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNSPECIFIED = 0;\n     */ SdkType[SdkType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT = 1;\n     */ SdkType[SdkType[\"REACT\"] = 1] = \"REACT\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANGULAR = 2;\n     */ SdkType[SdkType[\"ANGULAR\"] = 2] = \"ANGULAR\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANDROID = 3;\n     */ SdkType[SdkType[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_IOS = 4;\n     */ SdkType[SdkType[\"IOS\"] = 4] = \"IOS\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_FLUTTER = 5;\n     */ SdkType[SdkType[\"FLUTTER\"] = 5] = \"FLUTTER\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT_NATIVE = 6;\n     */ SdkType[SdkType[\"REACT_NATIVE\"] = 6] = \"REACT_NATIVE\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNITY = 7;\n     */ SdkType[SdkType[\"UNITY\"] = 7] = \"UNITY\";\n})(SdkType || (SdkType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackUnpublishReason\n */ var TrackUnpublishReason;\n(function(TrackUnpublishReason) {\n    /**\n     * Default value which is used when the specific reason\n     * for muting the track is not known.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_UNSPECIFIED = 0;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * Represents user muting their tracks.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_USER_MUTED = 1;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"USER_MUTED\"] = 1] = \"USER_MUTED\";\n    /**\n     * Represents muting the track because the permission to\n     * publish the track has been revoked.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_PERMISSION_REVOKED = 2;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"PERMISSION_REVOKED\"] = 2] = \"PERMISSION_REVOKED\";\n    /**\n     * Represents muting the track due to moderation actions.\n     * This is different from permission revoked because the\n     * participant can unmute themselves here whereas in case\n     * of \"permission revoke\" it is not possible until the\n     * call permissions are updated.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_MODERATION = 3;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"MODERATION\"] = 3] = \"MODERATION\";\n})(TrackUnpublishReason || (TrackUnpublishReason = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.GoAwayReason\n */ var GoAwayReason;\n(function(GoAwayReason) {\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_UNSPECIFIED = 0;\n     */ GoAwayReason[GoAwayReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_SHUTTING_DOWN = 1;\n     */ GoAwayReason[GoAwayReason[\"SHUTTING_DOWN\"] = 1] = \"SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_REBALANCE = 2;\n     */ GoAwayReason[GoAwayReason[\"REBALANCE\"] = 2] = \"REBALANCE\";\n})(GoAwayReason || (GoAwayReason = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallState\", [\n            {\n                no: 1,\n                name: \"participants\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Participant\n            },\n            {\n                no: 2,\n                name: \"started_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 3,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            },\n            {\n                no: 4,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.participants = [];\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Participant participants */ 1:\n                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* google.protobuf.Timestamp started_at */ 2:\n                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);\n                    break;\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 3:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                case /* repeated stream.video.sfu.models.Pin pins */ 4:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Participant participants = 1; */ for(let i = 0; i < message.participants.length; i++)Participant.internalBinaryWrite(message.participants[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp started_at = 2; */ if (message.startedAt) Timestamp.internalBinaryWrite(message.startedAt, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ParticipantCount participant_count = 3; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.models.Pin pins = 4; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallState\n */ const CallState$1 = new CallState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ParticipantCount\", [\n            {\n                no: 1,\n                name: \"total\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"anonymous\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.total = 0;\n        message.anonymous = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 total */ 1:\n                    message.total = reader.uint32();\n                    break;\n                case /* uint32 anonymous */ 2:\n                    message.anonymous = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 total = 1; */ if (message.total !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.total);\n        /* uint32 anonymous = 2; */ if (message.anonymous !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.anonymous);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ParticipantCount\n */ const ParticipantCount = new ParticipantCount$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pin$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Pin\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Pin\n */ const Pin = new Pin$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Participant$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Participant\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"published_tracks\",\n                kind: \"enum\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"joined_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 5,\n                name: \"track_lookup_prefix\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            },\n            {\n                no: 7,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"is_dominant_speaker\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"audio_level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 10,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 11,\n                name: \"image\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 12,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 13,\n                name: \"roles\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.publishedTracks = [];\n        message.trackLookupPrefix = \"\";\n        message.connectionQuality = 0;\n        message.isSpeaking = false;\n        message.isDominantSpeaker = false;\n        message.audioLevel = 0;\n        message.name = \"\";\n        message.image = \"\";\n        message.roles = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackType published_tracks */ 3:\n                    if (wireType === _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited) for(let e = reader.int32() + reader.pos; reader.pos < e;)message.publishedTracks.push(reader.int32());\n                    else message.publishedTracks.push(reader.int32());\n                    break;\n                case /* google.protobuf.Timestamp joined_at */ 4:\n                    message.joinedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joinedAt);\n                    break;\n                case /* string track_lookup_prefix */ 5:\n                    message.trackLookupPrefix = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 6:\n                    message.connectionQuality = reader.int32();\n                    break;\n                case /* bool is_speaking */ 7:\n                    message.isSpeaking = reader.bool();\n                    break;\n                case /* bool is_dominant_speaker */ 8:\n                    message.isDominantSpeaker = reader.bool();\n                    break;\n                case /* float audio_level */ 9:\n                    message.audioLevel = reader.float();\n                    break;\n                case /* string name */ 10:\n                    message.name = reader.string();\n                    break;\n                case /* string image */ 11:\n                    message.image = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 12:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* repeated string roles */ 13:\n                    message.roles.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackType published_tracks = 3; */ if (message.publishedTracks.length) {\n            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            for(let i = 0; i < message.publishedTracks.length; i++)writer.int32(message.publishedTracks[i]);\n            writer.join();\n        }\n        /* google.protobuf.Timestamp joined_at = 4; */ if (message.joinedAt) Timestamp.internalBinaryWrite(message.joinedAt, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string track_lookup_prefix = 5; */ if (message.trackLookupPrefix !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackLookupPrefix);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 6; */ if (message.connectionQuality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        /* bool is_speaking = 7; */ if (message.isSpeaking !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        /* bool is_dominant_speaker = 8; */ if (message.isDominantSpeaker !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isDominantSpeaker);\n        /* float audio_level = 9; */ if (message.audioLevel !== 0) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.audioLevel);\n        /* string name = 10; */ if (message.name !== \"\") writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string image = 11; */ if (message.image !== \"\") writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.image);\n        /* google.protobuf.Struct custom = 12; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated string roles = 13; */ for(let i = 0; i < message.roles.length; i++)writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.roles[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Participant\n */ const Participant = new Participant$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass StreamQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.StreamQuality\", [\n            {\n                no: 1,\n                name: \"video_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.videoQuality = 0;\n        message.userId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.VideoQuality video_quality */ 1:\n                    message.videoQuality = reader.int32();\n                    break;\n                case /* string user_id */ 2:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.VideoQuality video_quality = 1; */ if (message.videoQuality !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.videoQuality);\n        /* string user_id = 2; */ if (message.userId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.StreamQuality\n */ const StreamQuality = new StreamQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoDimension$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoDimension\", [\n            {\n                no: 1,\n                name: \"width\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"height\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.width = 0;\n        message.height = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 width */ 1:\n                    message.width = reader.uint32();\n                    break;\n                case /* uint32 height */ 2:\n                    message.height = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 width = 1; */ if (message.width !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.width);\n        /* uint32 height = 2; */ if (message.height !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.height);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoDimension\n */ const VideoDimension = new VideoDimension$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoLayer\", [\n            {\n                no: 1,\n                name: \"rid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"video_dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            },\n            {\n                no: 4,\n                name: \"bitrate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"fps\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 6,\n                name: \"quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.rid = \"\";\n        message.bitrate = 0;\n        message.fps = 0;\n        message.quality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string rid */ 1:\n                    message.rid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension video_dimension */ 2:\n                    message.videoDimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.videoDimension);\n                    break;\n                case /* uint32 bitrate */ 4:\n                    message.bitrate = reader.uint32();\n                    break;\n                case /* uint32 fps */ 5:\n                    message.fps = reader.uint32();\n                    break;\n                case /* stream.video.sfu.models.VideoQuality quality */ 6:\n                    message.quality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string rid = 1; */ if (message.rid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.rid);\n        /* stream.video.sfu.models.VideoDimension video_dimension = 2; */ if (message.videoDimension) VideoDimension.internalBinaryWrite(message.videoDimension, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 bitrate = 4; */ if (message.bitrate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.bitrate);\n        /* uint32 fps = 5; */ if (message.fps !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.fps);\n        /* stream.video.sfu.models.VideoQuality quality = 6; */ if (message.quality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.quality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoLayer\n */ const VideoLayer = new VideoLayer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Codec$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Codec\", [\n            {\n                no: 1,\n                name: \"payload_type\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"fmtp_line\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"clock_rate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"encoding_parameters\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"feedbacks\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.payloadType = 0;\n        message.name = \"\";\n        message.fmtpLine = \"\";\n        message.clockRate = 0;\n        message.encodingParameters = \"\";\n        message.feedbacks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 payload_type */ 1:\n                    message.payloadType = reader.uint32();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string fmtp_line */ 3:\n                    message.fmtpLine = reader.string();\n                    break;\n                case /* uint32 clock_rate */ 4:\n                    message.clockRate = reader.uint32();\n                    break;\n                case /* string encoding_parameters */ 5:\n                    message.encodingParameters = reader.string();\n                    break;\n                case /* repeated string feedbacks */ 6:\n                    message.feedbacks.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 payload_type = 1; */ if (message.payloadType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.payloadType);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string fmtp_line = 3; */ if (message.fmtpLine !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fmtpLine);\n        /* uint32 clock_rate = 4; */ if (message.clockRate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.clockRate);\n        /* string encoding_parameters = 5; */ if (message.encodingParameters !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.encodingParameters);\n        /* repeated string feedbacks = 6; */ for(let i = 0; i < message.feedbacks.length; i++)writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.feedbacks[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Codec\n */ const Codec = new Codec$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet ICETrickle$Type$1 = class ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ICETrickle\n */ const ICETrickle$1 = new ICETrickle$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.TrackInfo\", [\n            {\n                no: 1,\n                name: \"track_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayer\n            },\n            {\n                no: 6,\n                name: \"mid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 7,\n                name: \"dtx\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"stereo\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"red\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackId = \"\";\n        message.trackType = 0;\n        message.layers = [];\n        message.mid = \"\";\n        message.dtx = false;\n        message.stereo = false;\n        message.red = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string track_id */ 1:\n                    message.trackId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 2:\n                    message.trackType = reader.int32();\n                    break;\n                case /* repeated stream.video.sfu.models.VideoLayer layers */ 5:\n                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* string mid */ 6:\n                    message.mid = reader.string();\n                    break;\n                case /* bool dtx */ 7:\n                    message.dtx = reader.bool();\n                    break;\n                case /* bool stereo */ 8:\n                    message.stereo = reader.bool();\n                    break;\n                case /* bool red */ 9:\n                    message.red = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string track_id = 1; */ if (message.trackId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackId);\n        /* stream.video.sfu.models.TrackType track_type = 2; */ if (message.trackType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* repeated stream.video.sfu.models.VideoLayer layers = 5; */ for(let i = 0; i < message.layers.length; i++)VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string mid = 6; */ if (message.mid !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.mid);\n        /* bool dtx = 7; */ if (message.dtx !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.dtx);\n        /* bool stereo = 8; */ if (message.stereo !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.stereo);\n        /* bool red = 9; */ if (message.red !== false) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.red);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.TrackInfo\n */ const TrackInfo = new TrackInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Call$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Call\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"created_by_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"host_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"created_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 7,\n                name: \"updated_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = \"\";\n        message.id = \"\";\n        message.createdByUserId = \"\";\n        message.hostUserId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string type */ 1:\n                    message.type = reader.string();\n                    break;\n                case /* string id */ 2:\n                    message.id = reader.string();\n                    break;\n                case /* string created_by_user_id */ 3:\n                    message.createdByUserId = reader.string();\n                    break;\n                case /* string host_user_id */ 4:\n                    message.hostUserId = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 5:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* google.protobuf.Timestamp created_at */ 6:\n                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);\n                    break;\n                case /* google.protobuf.Timestamp updated_at */ 7:\n                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string type = 1; */ if (message.type !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.type);\n        /* string id = 2; */ if (message.id !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.id);\n        /* string created_by_user_id = 3; */ if (message.createdByUserId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.createdByUserId);\n        /* string host_user_id = 4; */ if (message.hostUserId !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.hostUserId);\n        /* google.protobuf.Struct custom = 5; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp created_at = 6; */ if (message.createdAt) Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp updated_at = 7; */ if (message.updatedAt) Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Call\n */ const Call$1 = new Call$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet Error$Type$1 = class Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Error\", [\n            {\n                no: 1,\n                name: \"code\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ErrorCode\",\n                        ErrorCode,\n                        \"ERROR_CODE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"should_retry\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.code = 0;\n        message.message = \"\";\n        message.shouldRetry = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ErrorCode code */ 1:\n                    message.code = reader.int32();\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                case /* bool should_retry */ 3:\n                    message.shouldRetry = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ErrorCode code = 1; */ if (message.code !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.code);\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        /* bool should_retry = 3; */ if (message.shouldRetry !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.shouldRetry);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Error\n */ const Error$2 = new Error$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ClientDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ClientDetails\", [\n            {\n                no: 1,\n                name: \"sdk\",\n                kind: \"message\",\n                T: ()=>Sdk\n            },\n            {\n                no: 2,\n                name: \"os\",\n                kind: \"message\",\n                T: ()=>OS\n            },\n            {\n                no: 3,\n                name: \"browser\",\n                kind: \"message\",\n                T: ()=>Browser\n            },\n            {\n                no: 4,\n                name: \"device\",\n                kind: \"message\",\n                T: ()=>Device\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Sdk sdk */ 1:\n                    message.sdk = Sdk.internalBinaryRead(reader, reader.uint32(), options, message.sdk);\n                    break;\n                case /* stream.video.sfu.models.OS os */ 2:\n                    message.os = OS.internalBinaryRead(reader, reader.uint32(), options, message.os);\n                    break;\n                case /* stream.video.sfu.models.Browser browser */ 3:\n                    message.browser = Browser.internalBinaryRead(reader, reader.uint32(), options, message.browser);\n                    break;\n                case /* stream.video.sfu.models.Device device */ 4:\n                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Sdk sdk = 1; */ if (message.sdk) Sdk.internalBinaryWrite(message.sdk, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.OS os = 2; */ if (message.os) OS.internalBinaryWrite(message.os, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Browser browser = 3; */ if (message.browser) Browser.internalBinaryWrite(message.browser, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Device device = 4; */ if (message.device) Device.internalBinaryWrite(message.device, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ClientDetails\n */ const ClientDetails = new ClientDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Sdk$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Sdk\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.SdkType\",\n                        SdkType,\n                        \"SDK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"major\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"minor\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"patch\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = 0;\n        message.major = \"\";\n        message.minor = \"\";\n        message.patch = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.SdkType type */ 1:\n                    message.type = reader.int32();\n                    break;\n                case /* string major */ 2:\n                    message.major = reader.string();\n                    break;\n                case /* string minor */ 3:\n                    message.minor = reader.string();\n                    break;\n                case /* string patch */ 4:\n                    message.patch = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.SdkType type = 1; */ if (message.type !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* string major = 2; */ if (message.major !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.major);\n        /* string minor = 3; */ if (message.minor !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.minor);\n        /* string patch = 4; */ if (message.patch !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.patch);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Sdk\n */ const Sdk = new Sdk$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass OS$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.OS\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"architecture\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        message.architecture = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                case /* string architecture */ 3:\n                    message.architecture = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        /* string architecture = 3; */ if (message.architecture !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.architecture);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.OS\n */ const OS = new OS$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Browser$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Browser\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Browser\n */ const Browser = new Browser$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Device$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Device\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Device\n */ const Device = new Device$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrants$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallGrants\", [\n            {\n                no: 1,\n                name: \"can_publish_audio\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"can_publish_video\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"can_screenshare\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.canPublishAudio = false;\n        message.canPublishVideo = false;\n        message.canScreenshare = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool can_publish_audio */ 1:\n                    message.canPublishAudio = reader.bool();\n                    break;\n                case /* bool can_publish_video */ 2:\n                    message.canPublishVideo = reader.bool();\n                    break;\n                case /* bool can_screenshare */ 3:\n                    message.canScreenshare = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool can_publish_audio = 1; */ if (message.canPublishAudio !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishAudio);\n        /* bool can_publish_video = 2; */ if (message.canPublishVideo !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishVideo);\n        /* bool can_screenshare = 3; */ if (message.canScreenshare !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canScreenshare);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallGrants\n */ const CallGrants = new CallGrants$Type();\nvar models = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Browser: Browser,\n    Call: Call$1,\n    CallGrants: CallGrants,\n    CallState: CallState$1,\n    ClientDetails: ClientDetails,\n    Codec: Codec,\n    get ConnectionQuality () {\n        return ConnectionQuality;\n    },\n    Device: Device,\n    Error: Error$2,\n    get ErrorCode () {\n        return ErrorCode;\n    },\n    get GoAwayReason () {\n        return GoAwayReason;\n    },\n    ICETrickle: ICETrickle$1,\n    OS: OS,\n    Participant: Participant,\n    ParticipantCount: ParticipantCount,\n    get PeerType () {\n        return PeerType;\n    },\n    Pin: Pin,\n    Sdk: Sdk,\n    get SdkType () {\n        return SdkType;\n    },\n    StreamQuality: StreamQuality,\n    TrackInfo: TrackInfo,\n    get TrackType () {\n        return TrackType;\n    },\n    get TrackUnpublishReason () {\n        return TrackUnpublishReason;\n    },\n    VideoDimension: VideoDimension,\n    VideoLayer: VideoLayer,\n    get VideoQuality () {\n        return VideoQuality;\n    }\n});\n/* eslint-disable */ // @generated by protobuf-ts 2.9.3 with parameter long_type_string,client_generic,server_none,eslint_disable\n// @generated from protobuf file \"video/sfu/signal_rpc/signal.proto\" (package \"stream.video.sfu.signal\", syntax proto3)\n// tslint:disable\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"subscriber_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"publisher_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"webrtc_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"sdk\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"sdk_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.subscriberStats = \"\";\n        message.publisherStats = \"\";\n        message.webrtcVersion = \"\";\n        message.sdk = \"\";\n        message.sdkVersion = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_stats */ 2:\n                    message.subscriberStats = reader.string();\n                    break;\n                case /* string publisher_stats */ 3:\n                    message.publisherStats = reader.string();\n                    break;\n                case /* string webrtc_version */ 4:\n                    message.webrtcVersion = reader.string();\n                    break;\n                case /* string sdk */ 5:\n                    message.sdk = reader.string();\n                    break;\n                case /* string sdk_version */ 6:\n                    message.sdkVersion = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_stats = 2; */ if (message.subscriberStats !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.subscriberStats);\n        /* string publisher_stats = 3; */ if (message.publisherStats !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.publisherStats);\n        /* string webrtc_version = 4; */ if (message.webrtcVersion !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.webrtcVersion);\n        /* string sdk = 5; */ if (message.sdk !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdk);\n        /* string sdk_version = 6; */ if (message.sdkVersion !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdkVersion);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsRequest\n */ const SendStatsRequest = new SendStatsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsResponse\n */ const SendStatsResponse = new SendStatsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.PeerType peer_type */ 2:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.PeerType peer_type = 2; */ if (message.peerType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartRequest\n */ const ICERestartRequest = new ICERestartRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartResponse\n */ const ICERestartResponse = new ICERestartResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"mute_states\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackMuteState\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.muteStates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackMuteState mute_states */ 3:\n                    message.muteStates.push(TrackMuteState.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackMuteState mute_states = 3; */ for(let i = 0; i < message.muteStates.length; i++)TrackMuteState.internalBinaryWrite(message.muteStates[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesRequest\n */ const UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesResponse\n */ const UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackMuteState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackMuteState\", [\n            {\n                no: 1,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackType = 0;\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.TrackType track_type */ 1:\n                    message.trackType = reader.int32();\n                    break;\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.TrackType track_type = 1; */ if (message.trackType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackMuteState\n */ const TrackMuteState = new TrackMuteState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.AudioMuteChanged\", [\n            {\n                no: 1,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 1:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 1; */ if (message.muted !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.AudioMuteChanged\n */ new AudioMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.VideoMuteChanged\", [\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.VideoMuteChanged\n */ new VideoMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsRequest\", [\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks */ 3:\n                    message.tracks.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsRequest\n */ const UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsResponse\n */ const UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackSubscriptionDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackSubscriptionDetails\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.trackType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 3:\n                    message.trackType = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension dimension */ 4:\n                    message.dimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.dimension);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType track_type = 3; */ if (message.trackType !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* stream.video.sfu.models.VideoDimension dimension = 4; */ if (message.dimension) VideoDimension.internalBinaryWrite(message.dimension, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackSubscriptionDetails\n */ const TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerRequest\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerRequest\n */ const SendAnswerRequest = new SendAnswerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerResponse\n */ const SendAnswerResponse = new SendAnswerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickleResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICETrickleResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICETrickleResponse\n */ const ICETrickleResponse = new ICETrickleResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherRequest\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo tracks */ 3:\n                    message.tracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackInfo tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackInfo.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherRequest\n */ const SetPublisherRequest = new SetPublisherRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherResponse\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.iceRestart = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* bool ice_restart */ 3:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* bool ice_restart = 3; */ if (message.iceRestart !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherResponse\n */ const SetPublisherResponse = new SetPublisherResponse$Type();\n/**\n * @generated ServiceType for protobuf service stream.video.sfu.signal.SignalServer\n */ const SignalServer = new _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__.ServiceType(\"stream.video.sfu.signal.SignalServer\", [\n    {\n        name: \"SetPublisher\",\n        options: {},\n        I: SetPublisherRequest,\n        O: SetPublisherResponse\n    },\n    {\n        name: \"SendAnswer\",\n        options: {},\n        I: SendAnswerRequest,\n        O: SendAnswerResponse\n    },\n    {\n        name: \"IceTrickle\",\n        options: {},\n        I: ICETrickle$1,\n        O: ICETrickleResponse\n    },\n    {\n        name: \"UpdateSubscriptions\",\n        options: {},\n        I: UpdateSubscriptionsRequest,\n        O: UpdateSubscriptionsResponse\n    },\n    {\n        name: \"UpdateMuteStates\",\n        options: {},\n        I: UpdateMuteStatesRequest,\n        O: UpdateMuteStatesResponse\n    },\n    {\n        name: \"IceRestart\",\n        options: {},\n        I: ICERestartRequest,\n        O: ICERestartResponse\n    },\n    {\n        name: \"SendStats\",\n        options: {},\n        I: SendStatsRequest,\n        O: SendStatsResponse\n    }\n]);\n/**\n * @generated from protobuf enum stream.video.sfu.event.VideoLayerSetting.Priority\n */ var VideoLayerSetting_Priority;\n(function(VideoLayerSetting_Priority) {\n    /**\n     * @generated from protobuf enum value: PRIORITY_HIGH_UNSPECIFIED = 0;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"HIGH_UNSPECIFIED\"] = 0] = \"HIGH_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_LOW = 1;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"LOW\"] = 1] = \"LOW\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_MEDIUM = 2;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_VERY_LOW = 3;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"VERY_LOW\"] = 3] = \"VERY_LOW\";\n})(VideoLayerSetting_Priority || (VideoLayerSetting_Priority = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuEvent$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuEvent\", [\n            {\n                no: 1,\n                name: \"subscriber_offer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>SubscriberOffer\n            },\n            {\n                no: 2,\n                name: \"publisher_answer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PublisherAnswer\n            },\n            {\n                no: 3,\n                name: \"connection_quality_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ConnectionQualityChanged\n            },\n            {\n                no: 4,\n                name: \"audio_level_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>AudioLevelChanged\n            },\n            {\n                no: 5,\n                name: \"ice_trickle\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICETrickle$1\n            },\n            {\n                no: 6,\n                name: \"change_publish_quality\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ChangePublishQuality\n            },\n            {\n                no: 10,\n                name: \"participant_joined\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantJoined\n            },\n            {\n                no: 11,\n                name: \"participant_left\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantLeft\n            },\n            {\n                no: 12,\n                name: \"dominant_speaker_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>DominantSpeakerChanged\n            },\n            {\n                no: 13,\n                name: \"join_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>JoinResponse\n            },\n            {\n                no: 14,\n                name: \"health_check_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>HealthCheckResponse\n            },\n            {\n                no: 16,\n                name: \"track_published\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackPublished\n            },\n            {\n                no: 17,\n                name: \"track_unpublished\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackUnpublished\n            },\n            {\n                no: 18,\n                name: \"error\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>Error$1\n            },\n            {\n                no: 19,\n                name: \"call_grants_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>CallGrantsUpdated\n            },\n            {\n                no: 20,\n                name: \"go_away\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>GoAway\n            },\n            {\n                no: 21,\n                name: \"ice_restart\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICERestart\n            },\n            {\n                no: 22,\n                name: \"pins_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PinsChanged\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.eventPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.SubscriberOffer subscriber_offer */ 1:\n                    message.eventPayload = {\n                        oneofKind: \"subscriberOffer\",\n                        subscriberOffer: SubscriberOffer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.subscriberOffer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PublisherAnswer publisher_answer */ 2:\n                    message.eventPayload = {\n                        oneofKind: \"publisherAnswer\",\n                        publisherAnswer: PublisherAnswer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.publisherAnswer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed */ 3:\n                    message.eventPayload = {\n                        oneofKind: \"connectionQualityChanged\",\n                        connectionQualityChanged: ConnectionQualityChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.connectionQualityChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.AudioLevelChanged audio_level_changed */ 4:\n                    message.eventPayload = {\n                        oneofKind: \"audioLevelChanged\",\n                        audioLevelChanged: AudioLevelChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.audioLevelChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.models.ICETrickle ice_trickle */ 5:\n                    message.eventPayload = {\n                        oneofKind: \"iceTrickle\",\n                        iceTrickle: ICETrickle$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceTrickle)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ChangePublishQuality change_publish_quality */ 6:\n                    message.eventPayload = {\n                        oneofKind: \"changePublishQuality\",\n                        changePublishQuality: ChangePublishQuality.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.changePublishQuality)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantJoined participant_joined */ 10:\n                    message.eventPayload = {\n                        oneofKind: \"participantJoined\",\n                        participantJoined: ParticipantJoined.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantJoined)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantLeft participant_left */ 11:\n                    message.eventPayload = {\n                        oneofKind: \"participantLeft\",\n                        participantLeft: ParticipantLeft.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantLeft)\n                    };\n                    break;\n                case /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed */ 12:\n                    message.eventPayload = {\n                        oneofKind: \"dominantSpeakerChanged\",\n                        dominantSpeakerChanged: DominantSpeakerChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.dominantSpeakerChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.JoinResponse join_response */ 13:\n                    message.eventPayload = {\n                        oneofKind: \"joinResponse\",\n                        joinResponse: JoinResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.joinResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckResponse health_check_response */ 14:\n                    message.eventPayload = {\n                        oneofKind: \"healthCheckResponse\",\n                        healthCheckResponse: HealthCheckResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.healthCheckResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackPublished track_published */ 16:\n                    message.eventPayload = {\n                        oneofKind: \"trackPublished\",\n                        trackPublished: TrackPublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackPublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackUnpublished track_unpublished */ 17:\n                    message.eventPayload = {\n                        oneofKind: \"trackUnpublished\",\n                        trackUnpublished: TrackUnpublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackUnpublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.Error error */ 18:\n                    message.eventPayload = {\n                        oneofKind: \"error\",\n                        error: Error$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.error)\n                    };\n                    break;\n                case /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated */ 19:\n                    message.eventPayload = {\n                        oneofKind: \"callGrantsUpdated\",\n                        callGrantsUpdated: CallGrantsUpdated.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.callGrantsUpdated)\n                    };\n                    break;\n                case /* stream.video.sfu.event.GoAway go_away */ 20:\n                    message.eventPayload = {\n                        oneofKind: \"goAway\",\n                        goAway: GoAway.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.goAway)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ICERestart ice_restart */ 21:\n                    message.eventPayload = {\n                        oneofKind: \"iceRestart\",\n                        iceRestart: ICERestart.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceRestart)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PinsChanged pins_updated */ 22:\n                    message.eventPayload = {\n                        oneofKind: \"pinsUpdated\",\n                        pinsUpdated: PinsChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.pinsUpdated)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.SubscriberOffer subscriber_offer = 1; */ if (message.eventPayload.oneofKind === \"subscriberOffer\") SubscriberOffer.internalBinaryWrite(message.eventPayload.subscriberOffer, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PublisherAnswer publisher_answer = 2; */ if (message.eventPayload.oneofKind === \"publisherAnswer\") PublisherAnswer.internalBinaryWrite(message.eventPayload.publisherAnswer, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed = 3; */ if (message.eventPayload.oneofKind === \"connectionQualityChanged\") ConnectionQualityChanged.internalBinaryWrite(message.eventPayload.connectionQualityChanged, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.AudioLevelChanged audio_level_changed = 4; */ if (message.eventPayload.oneofKind === \"audioLevelChanged\") AudioLevelChanged.internalBinaryWrite(message.eventPayload.audioLevelChanged, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ICETrickle ice_trickle = 5; */ if (message.eventPayload.oneofKind === \"iceTrickle\") ICETrickle$1.internalBinaryWrite(message.eventPayload.iceTrickle, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ChangePublishQuality change_publish_quality = 6; */ if (message.eventPayload.oneofKind === \"changePublishQuality\") ChangePublishQuality.internalBinaryWrite(message.eventPayload.changePublishQuality, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantJoined participant_joined = 10; */ if (message.eventPayload.oneofKind === \"participantJoined\") ParticipantJoined.internalBinaryWrite(message.eventPayload.participantJoined, writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantLeft participant_left = 11; */ if (message.eventPayload.oneofKind === \"participantLeft\") ParticipantLeft.internalBinaryWrite(message.eventPayload.participantLeft, writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed = 12; */ if (message.eventPayload.oneofKind === \"dominantSpeakerChanged\") DominantSpeakerChanged.internalBinaryWrite(message.eventPayload.dominantSpeakerChanged, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.JoinResponse join_response = 13; */ if (message.eventPayload.oneofKind === \"joinResponse\") JoinResponse.internalBinaryWrite(message.eventPayload.joinResponse, writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckResponse health_check_response = 14; */ if (message.eventPayload.oneofKind === \"healthCheckResponse\") HealthCheckResponse.internalBinaryWrite(message.eventPayload.healthCheckResponse, writer.tag(14, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackPublished track_published = 16; */ if (message.eventPayload.oneofKind === \"trackPublished\") TrackPublished.internalBinaryWrite(message.eventPayload.trackPublished, writer.tag(16, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackUnpublished track_unpublished = 17; */ if (message.eventPayload.oneofKind === \"trackUnpublished\") TrackUnpublished.internalBinaryWrite(message.eventPayload.trackUnpublished, writer.tag(17, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Error error = 18; */ if (message.eventPayload.oneofKind === \"error\") Error$1.internalBinaryWrite(message.eventPayload.error, writer.tag(18, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated = 19; */ if (message.eventPayload.oneofKind === \"callGrantsUpdated\") CallGrantsUpdated.internalBinaryWrite(message.eventPayload.callGrantsUpdated, writer.tag(19, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.GoAway go_away = 20; */ if (message.eventPayload.oneofKind === \"goAway\") GoAway.internalBinaryWrite(message.eventPayload.goAway, writer.tag(20, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ICERestart ice_restart = 21; */ if (message.eventPayload.oneofKind === \"iceRestart\") ICERestart.internalBinaryWrite(message.eventPayload.iceRestart, writer.tag(21, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PinsChanged pins_updated = 22; */ if (message.eventPayload.oneofKind === \"pinsUpdated\") PinsChanged.internalBinaryWrite(message.eventPayload.pinsUpdated, writer.tag(22, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuEvent\n */ const SfuEvent = new SfuEvent$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PinsChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PinsChanged\", [\n            {\n                no: 1,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Pin pins */ 1:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Pin pins = 1; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PinsChanged\n */ const PinsChanged = new PinsChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Error\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Error\n */ const Error$1 = new Error$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICETrickle\n */ const ICETrickle = new ICETrickle$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestart$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICERestart\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICERestart\n */ const ICERestart = new ICERestart$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuRequest\", [\n            {\n                no: 1,\n                name: \"join_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>JoinRequest\n            },\n            {\n                no: 2,\n                name: \"health_check_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>HealthCheckRequest\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.requestPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.JoinRequest join_request */ 1:\n                    message.requestPayload = {\n                        oneofKind: \"joinRequest\",\n                        joinRequest: JoinRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.joinRequest)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckRequest health_check_request */ 2:\n                    message.requestPayload = {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.healthCheckRequest)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.JoinRequest join_request = 1; */ if (message.requestPayload.oneofKind === \"joinRequest\") JoinRequest.internalBinaryWrite(message.requestPayload.joinRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckRequest health_check_request = 2; */ if (message.requestPayload.oneofKind === \"healthCheckRequest\") HealthCheckRequest.internalBinaryWrite(message.requestPayload.healthCheckRequest, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuRequest\n */ const SfuRequest = new SfuRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckRequest\", []);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckRequest\n */ const HealthCheckRequest = new HealthCheckRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckResponse\", [\n            {\n                no: 1,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 1:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ParticipantCount participant_count = 1; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckResponse\n */ const HealthCheckResponse = new HealthCheckResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackPublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackPublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 4:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.Participant participant = 4; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackPublished\n */ const TrackPublished = new TrackPublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackUnpublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackUnpublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"cause\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackUnpublishReason\",\n                        TrackUnpublishReason,\n                        \"TRACK_UNPUBLISH_REASON_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        message.cause = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.TrackUnpublishReason cause */ 4:\n                    message.cause = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 5:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.TrackUnpublishReason cause = 4; */ if (message.cause !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.cause);\n        /* stream.video.sfu.models.Participant participant = 5; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackUnpublished\n */ const TrackUnpublished = new TrackUnpublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinRequest\", [\n            {\n                no: 1,\n                name: \"token\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"subscriber_sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"client_details\",\n                kind: \"message\",\n                T: ()=>ClientDetails\n            },\n            {\n                no: 5,\n                name: \"migration\",\n                kind: \"message\",\n                T: ()=>Migration\n            },\n            {\n                no: 6,\n                name: \"fast_reconnect\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.token = \"\";\n        message.sessionId = \"\";\n        message.subscriberSdp = \"\";\n        message.fastReconnect = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string token */ 1:\n                    message.token = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_sdp */ 3:\n                    message.subscriberSdp = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ClientDetails client_details */ 4:\n                    message.clientDetails = ClientDetails.internalBinaryRead(reader, reader.uint32(), options, message.clientDetails);\n                    break;\n                case /* stream.video.sfu.event.Migration migration */ 5:\n                    message.migration = Migration.internalBinaryRead(reader, reader.uint32(), options, message.migration);\n                    break;\n                case /* bool fast_reconnect */ 6:\n                    message.fastReconnect = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string token = 1; */ if (message.token !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.token);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_sdp = 3; */ if (message.subscriberSdp !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.subscriberSdp);\n        /* stream.video.sfu.models.ClientDetails client_details = 4; */ if (message.clientDetails) ClientDetails.internalBinaryWrite(message.clientDetails, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Migration migration = 5; */ if (message.migration) Migration.internalBinaryWrite(message.migration, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool fast_reconnect = 6; */ if (message.fastReconnect !== false) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.fastReconnect);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinRequest\n */ const JoinRequest = new JoinRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Migration$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Migration\", [\n            {\n                no: 1,\n                name: \"from_sfu_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"announced_tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            },\n            {\n                no: 3,\n                name: \"subscriptions\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fromSfuId = \"\";\n        message.announcedTracks = [];\n        message.subscriptions = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string from_sfu_id */ 1:\n                    message.fromSfuId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo announced_tracks */ 2:\n                    message.announcedTracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions */ 3:\n                    message.subscriptions.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string from_sfu_id = 1; */ if (message.fromSfuId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fromSfuId);\n        /* repeated stream.video.sfu.models.TrackInfo announced_tracks = 2; */ for(let i = 0; i < message.announcedTracks.length; i++)TrackInfo.internalBinaryWrite(message.announcedTracks[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions = 3; */ for(let i = 0; i < message.subscriptions.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.subscriptions[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Migration\n */ const Migration = new Migration$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinResponse\", [\n            {\n                no: 1,\n                name: \"call_state\",\n                kind: \"message\",\n                T: ()=>CallState$1\n            },\n            {\n                no: 2,\n                name: \"reconnected\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reconnected = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallState call_state */ 1:\n                    message.callState = CallState$1.internalBinaryRead(reader, reader.uint32(), options, message.callState);\n                    break;\n                case /* bool reconnected */ 2:\n                    message.reconnected = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallState call_state = 1; */ if (message.callState) CallState$1.internalBinaryWrite(message.callState, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool reconnected = 2; */ if (message.reconnected !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.reconnected);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinResponse\n */ const JoinResponse = new JoinResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantJoined$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantJoined\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantJoined\n */ const ParticipantJoined = new ParticipantJoined$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantLeft$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantLeft\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantLeft\n */ const ParticipantLeft = new ParticipantLeft$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscriberOffer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SubscriberOffer\", [\n            {\n                no: 1,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.iceRestart = false;\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool ice_restart */ 1:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool ice_restart = 1; */ if (message.iceRestart !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SubscriberOffer\n */ const SubscriberOffer = new SubscriberOffer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublisherAnswer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PublisherAnswer\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PublisherAnswer\n */ const PublisherAnswer = new PublisherAnswer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityChanged\", [\n            {\n                no: 1,\n                name: \"connection_quality_updates\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>ConnectionQualityInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.connectionQualityUpdates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates */ 1:\n                    message.connectionQualityUpdates.push(ConnectionQualityInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates = 1; */ for(let i = 0; i < message.connectionQualityUpdates.length; i++)ConnectionQualityInfo.internalBinaryWrite(message.connectionQualityUpdates[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityChanged\n */ const ConnectionQualityChanged = new ConnectionQualityChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityInfo\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.connectionQuality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 3:\n                    message.connectionQuality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 3; */ if (message.connectionQuality !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityInfo\n */ const ConnectionQualityInfo = new ConnectionQualityInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DominantSpeakerChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.DominantSpeakerChanged\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.DominantSpeakerChanged\n */ const DominantSpeakerChanged = new DominantSpeakerChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevel$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevel\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 4,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.level = 0;\n        message.isSpeaking = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* float level */ 3:\n                    message.level = reader.float();\n                    break;\n                case /* bool is_speaking */ 4:\n                    message.isSpeaking = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* float level = 3; */ if (message.level !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.level);\n        /* bool is_speaking = 4; */ if (message.isSpeaking !== false) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevel\n */ const AudioLevel = new AudioLevel$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevelChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevelChanged\", [\n            {\n                no: 1,\n                name: \"audio_levels\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioLevel\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioLevels = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioLevel audio_levels */ 1:\n                    message.audioLevels.push(AudioLevel.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioLevel audio_levels = 1; */ for(let i = 0; i < message.audioLevels.length; i++)AudioLevel.internalBinaryWrite(message.audioLevels[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevelChanged\n */ const AudioLevelChanged = new AudioLevelChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioMediaRequest\", [\n            {\n                no: 1,\n                name: \"channel_count\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.channelCount = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 channel_count */ 1:\n                    message.channelCount = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 channel_count = 1; */ if (message.channelCount !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.channelCount);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioMediaRequest\n */ const AudioMediaRequest = new AudioMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>AudioMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.AudioMediaRequest media_request */ 1:\n                    message.mediaRequest = AudioMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.AudioMediaRequest media_request = 1; */ if (message.mediaRequest) AudioMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioSender\n */ const AudioSender = new AudioSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoMediaRequest\", [\n            {\n                no: 1,\n                name: \"ideal_height\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 2,\n                name: \"ideal_width\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 3,\n                name: \"ideal_frame_rate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.idealHeight = 0;\n        message.idealWidth = 0;\n        message.idealFrameRate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 ideal_height */ 1:\n                    message.idealHeight = reader.int32();\n                    break;\n                case /* int32 ideal_width */ 2:\n                    message.idealWidth = reader.int32();\n                    break;\n                case /* int32 ideal_frame_rate */ 3:\n                    message.idealFrameRate = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 ideal_height = 1; */ if (message.idealHeight !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealHeight);\n        /* int32 ideal_width = 2; */ if (message.idealWidth !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealWidth);\n        /* int32 ideal_frame_rate = 3; */ if (message.idealFrameRate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealFrameRate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoMediaRequest\n */ const VideoMediaRequest = new VideoMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayerSetting$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoLayerSetting\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"active\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"max_bitrate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 4,\n                name: \"scale_resolution_down_by\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 5,\n                name: \"priority\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.event.VideoLayerSetting.Priority\",\n                        VideoLayerSetting_Priority,\n                        \"PRIORITY_\"\n                    ]\n            },\n            {\n                no: 6,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 7,\n                name: \"max_framerate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.active = false;\n        message.maxBitrate = 0;\n        message.scaleResolutionDownBy = 0;\n        message.priority = 0;\n        message.maxFramerate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* bool active */ 2:\n                    message.active = reader.bool();\n                    break;\n                case /* int32 max_bitrate */ 3:\n                    message.maxBitrate = reader.int32();\n                    break;\n                case /* float scale_resolution_down_by */ 4:\n                    message.scaleResolutionDownBy = reader.float();\n                    break;\n                case /* stream.video.sfu.event.VideoLayerSetting.Priority priority */ 5:\n                    message.priority = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 6:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* uint32 max_framerate */ 7:\n                    message.maxFramerate = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* bool active = 2; */ if (message.active !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.active);\n        /* int32 max_bitrate = 3; */ if (message.maxBitrate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.maxBitrate);\n        /* float scale_resolution_down_by = 4; */ if (message.scaleResolutionDownBy !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.scaleResolutionDownBy);\n        /* stream.video.sfu.event.VideoLayerSetting.Priority priority = 5; */ if (message.priority !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.priority);\n        /* stream.video.sfu.models.Codec codec = 6; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 max_framerate = 7; */ if (message.maxFramerate !== 0) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.maxFramerate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoLayerSetting\n */ const VideoLayerSetting = new VideoLayerSetting$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>VideoMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 3,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayerSetting\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.layers = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.VideoMediaRequest media_request */ 1:\n                    message.mediaRequest = VideoMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* repeated stream.video.sfu.event.VideoLayerSetting layers */ 3:\n                    message.layers.push(VideoLayerSetting.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.VideoMediaRequest media_request = 1; */ if (message.mediaRequest) VideoMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoLayerSetting layers = 3; */ for(let i = 0; i < message.layers.length; i++)VideoLayerSetting.internalBinaryWrite(message.layers[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoSender\n */ const VideoSender = new VideoSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ChangePublishQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ChangePublishQuality\", [\n            {\n                no: 1,\n                name: \"audio_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioSender\n            },\n            {\n                no: 2,\n                name: \"video_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoSender\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioSenders = [];\n        message.videoSenders = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioSender audio_senders */ 1:\n                    message.audioSenders.push(AudioSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.event.VideoSender video_senders */ 2:\n                    message.videoSenders.push(VideoSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioSender audio_senders = 1; */ for(let i = 0; i < message.audioSenders.length; i++)AudioSender.internalBinaryWrite(message.audioSenders[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoSender video_senders = 2; */ for(let i = 0; i < message.videoSenders.length; i++)VideoSender.internalBinaryWrite(message.videoSenders[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ChangePublishQuality\n */ const ChangePublishQuality = new ChangePublishQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrantsUpdated$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.CallGrantsUpdated\", [\n            {\n                no: 1,\n                name: \"current_grants\",\n                kind: \"message\",\n                T: ()=>CallGrants\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.message = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallGrants current_grants */ 1:\n                    message.currentGrants = CallGrants.internalBinaryRead(reader, reader.uint32(), options, message.currentGrants);\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallGrants current_grants = 1; */ if (message.currentGrants) CallGrants.internalBinaryWrite(message.currentGrants, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.CallGrantsUpdated\n */ const CallGrantsUpdated = new CallGrantsUpdated$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GoAway$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.GoAway\", [\n            {\n                no: 1,\n                name: \"reason\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.GoAwayReason\",\n                        GoAwayReason,\n                        \"GO_AWAY_REASON_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reason = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.GoAwayReason reason */ 1:\n                    message.reason = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.GoAwayReason reason = 1; */ if (message.reason !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.reason);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.GoAway\n */ const GoAway = new GoAway$Type();\nvar events = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AudioLevel: AudioLevel,\n    AudioLevelChanged: AudioLevelChanged,\n    AudioMediaRequest: AudioMediaRequest,\n    AudioSender: AudioSender,\n    CallGrantsUpdated: CallGrantsUpdated,\n    ChangePublishQuality: ChangePublishQuality,\n    ConnectionQualityChanged: ConnectionQualityChanged,\n    ConnectionQualityInfo: ConnectionQualityInfo,\n    DominantSpeakerChanged: DominantSpeakerChanged,\n    Error: Error$1,\n    GoAway: GoAway,\n    HealthCheckRequest: HealthCheckRequest,\n    HealthCheckResponse: HealthCheckResponse,\n    ICERestart: ICERestart,\n    ICETrickle: ICETrickle,\n    JoinRequest: JoinRequest,\n    JoinResponse: JoinResponse,\n    Migration: Migration,\n    ParticipantJoined: ParticipantJoined,\n    ParticipantLeft: ParticipantLeft,\n    PinsChanged: PinsChanged,\n    PublisherAnswer: PublisherAnswer,\n    SfuEvent: SfuEvent,\n    SfuRequest: SfuRequest,\n    SubscriberOffer: SubscriberOffer,\n    TrackPublished: TrackPublished,\n    TrackUnpublished: TrackUnpublished,\n    VideoLayerSetting: VideoLayerSetting,\n    get VideoLayerSetting_Priority () {\n        return VideoLayerSetting_Priority;\n    },\n    VideoMediaRequest: VideoMediaRequest,\n    VideoSender: VideoSender\n});\nvar VisibilityState;\n(function(VisibilityState) {\n    VisibilityState[\"UNKNOWN\"] = \"UNKNOWN\";\n    VisibilityState[\"VISIBLE\"] = \"VISIBLE\";\n    VisibilityState[\"INVISIBLE\"] = \"INVISIBLE\";\n})(VisibilityState || (VisibilityState = {}));\nvar DebounceType;\n(function(DebounceType) {\n    DebounceType[DebounceType[\"IMMEDIATE\"] = 20] = \"IMMEDIATE\";\n    DebounceType[DebounceType[\"FAST\"] = 100] = \"FAST\";\n    DebounceType[DebounceType[\"MEDIUM\"] = 600] = \"MEDIUM\";\n    DebounceType[DebounceType[\"SLOW\"] = 1200] = \"SLOW\";\n})(DebounceType || (DebounceType = {}));\n/**\n * @generated from protobuf service stream.video.sfu.signal.SignalServer\n */ class SignalServerClient {\n    constructor(_transport){\n        this._transport = _transport;\n        this.typeName = SignalServer.typeName;\n        this.methods = SignalServer.methods;\n        this.options = SignalServer.options;\n    }\n    /**\n     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V\n     *\n     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);\n     */ setPublisher(input, options) {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * answer is sent by the client to the SFU after receiving a subscriber_offer.\n     *\n     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);\n     */ sendAnswer(input, options) {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * SendICECandidate sends an ICE candidate to the client\n     *\n     * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);\n     */ iceTrickle(input, options) {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions\n     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user\n     *\n     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);\n     */ updateSubscriptions(input, options) {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);\n     */ updateMuteStates(input, options) {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);\n     */ iceRestart(input, options) {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: SendStats(stream.video.sfu.signal.SendStatsRequest) returns (stream.video.sfu.signal.SendStatsResponse);\n     */ sendStats(input, options) {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n}\nconst defaultOptions = {\n    baseUrl: \"\",\n    sendJson: true,\n    timeout: 5 * 1000,\n    jsonOptions: {\n        ignoreUnknownFields: true\n    }\n};\nconst withHeaders = (headers)=>{\n    return {\n        interceptUnary (next, method, input, options) {\n            options.meta = {\n                ...options.meta,\n                ...headers\n            };\n            return next(method, input, options);\n        }\n    };\n};\n/**\n * Creates new SignalServerClient instance.\n *\n * @param options the twirp options.\n */ const createSignalClient = (options)=>{\n    const transport = new _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__.TwirpFetchTransport({\n        ...defaultOptions,\n        ...options\n    });\n    return new SignalServerClient(transport);\n};\n/**\n * Checks whether we are using React Native\n */ const isReactNative = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.product?.toLowerCase() === \"reactnative\";\n};\n// log levels, sorted by verbosity\nconst logLevels = Object.freeze({\n    trace: 0,\n    debug: 1,\n    info: 2,\n    warn: 3,\n    error: 4\n});\nlet logger$4;\nlet level = \"info\";\nconst logToConsole = (logLevel, message, ...args)=>{\n    let logMethod;\n    switch(logLevel){\n        case \"error\":\n            logMethod = console.error;\n            break;\n        case \"warn\":\n            if (isReactNative()) {\n                message = `WARN: ${message}`;\n                logMethod = console.info;\n                break;\n            }\n            logMethod = console.warn;\n            break;\n        case \"info\":\n            logMethod = console.info;\n            break;\n        case \"trace\":\n            logMethod = console.trace;\n            break;\n        default:\n            logMethod = console.log;\n            break;\n    }\n    logMethod(message, ...args);\n};\nconst setLogger = (l, lvl)=>{\n    logger$4 = l;\n    if (lvl) {\n        setLogLevel(lvl);\n    }\n};\nconst setLogLevel = (l)=>{\n    level = l;\n};\nconst getLogger = (withTags)=>{\n    const loggerMethod = logger$4 || logToConsole;\n    const tags = (withTags || []).join(\":\");\n    const result = (logLevel, message, ...args)=>{\n        if (logLevels[logLevel] >= logLevels[level]) {\n            loggerMethod(logLevel, `[${tags}]: ${message}`, ...args);\n        }\n    };\n    return result;\n};\nconst getPreferredCodecs = (kind, preferredCodec, codecToRemove)=>{\n    const logger = getLogger([\n        \"codecs\"\n    ]);\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        logger?.(\"warn\", \"RTCRtpSender.getCapabilities is not supported\");\n        return;\n    }\n    const cap = RTCRtpSender.getCapabilities(kind);\n    if (!cap) return;\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c)=>{\n        const codec = c.mimeType.toLowerCase();\n        logger?.(\"debug\", `Found supported codec: ${codec}`);\n        const shouldRemoveCodec = codecToRemove && codec === `${kind}/${codecToRemove.toLowerCase()}`;\n        if (shouldRemoveCodec) return;\n        const matchesCodec = codec === `${kind}/${preferredCodec.toLowerCase()}`;\n        if (!matchesCodec) {\n            unmatched.push(c);\n            return;\n        }\n        // for h264 codecs that have sdpFmtpLine available, use only if the\n        // profile-level-id is 42e01f for cross-browser compatibility\n        if (codec === \"h264\") {\n            if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                matched.push(c);\n            } else {\n                partialMatched.push(c);\n            }\n            return;\n        }\n        matched.push(c);\n    });\n    const result = [\n        ...matched,\n        ...partialMatched,\n        ...unmatched\n    ];\n    logger?.(\"info\", `Preffered codecs: `, result);\n    return result;\n};\nconst getGenericSdp = async (direction)=>{\n    const tempPc = new RTCPeerConnection();\n    tempPc.addTransceiver(\"video\", {\n        direction\n    });\n    tempPc.addTransceiver(\"audio\", {\n        direction\n    });\n    const offer = await tempPc.createOffer();\n    let sdp = offer.sdp ?? \"\";\n    tempPc.getTransceivers().forEach((t)=>{\n        t.stop();\n    });\n    tempPc.close();\n    return sdp;\n};\nconst sfuEventKinds = {\n    subscriberOffer: undefined,\n    publisherAnswer: undefined,\n    connectionQualityChanged: undefined,\n    audioLevelChanged: undefined,\n    iceTrickle: undefined,\n    changePublishQuality: undefined,\n    participantJoined: undefined,\n    participantLeft: undefined,\n    dominantSpeakerChanged: undefined,\n    joinResponse: undefined,\n    healthCheckResponse: undefined,\n    trackPublished: undefined,\n    trackUnpublished: undefined,\n    error: undefined,\n    callGrantsUpdated: undefined,\n    goAway: undefined,\n    iceRestart: undefined,\n    pinsUpdated: undefined\n};\nconst isSfuEvent = (eventName)=>{\n    return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);\n};\nclass Dispatcher {\n    constructor(){\n        this.logger = getLogger([\n            \"Dispatcher\"\n        ]);\n        this.subscribers = {};\n        this.dispatch = (message)=>{\n            const eventKind = message.eventPayload.oneofKind;\n            if (!eventKind) return;\n            const payload = message.eventPayload[eventKind];\n            this.logger(\"debug\", `Dispatching ${eventKind}`, payload);\n            const listeners = this.subscribers[eventKind];\n            if (!listeners) return;\n            for (const fn of listeners){\n                try {\n                    fn(payload);\n                } catch (e) {\n                    this.logger(\"warn\", \"Listener failed with error\", e);\n                }\n            }\n        };\n        this.on = (eventName, fn)=>{\n            var _a;\n            ((_a = this.subscribers)[eventName] ?? (_a[eventName] = [])).push(fn);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        this.off = (eventName, fn)=>{\n            this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f)=>f !== fn);\n        };\n        this.offAll = (eventName)=>{\n            if (eventName) {\n                this.subscribers[eventName] = [];\n            } else {\n                this.subscribers = {};\n            }\n        };\n    }\n}\n/**\n * A buffer for ICE Candidates. Used for ICE Trickle:\n * - https://bloggeek.me/webrtcglossary/trickle-ice/\n */ class IceTrickleBuffer {\n    constructor(){\n        this.subscriberCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.publisherCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        this.push = (iceTrickle)=>{\n            if (iceTrickle.peerType === PeerType.SUBSCRIBER) {\n                this.subscriberCandidates.next(iceTrickle);\n            } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {\n                this.publisherCandidates.next(iceTrickle);\n            } else {\n                this.logger(\"warn\", `ICETrickle, Unknown peer type`, iceTrickle);\n            }\n        };\n    }\n}\nfunction getIceCandidate(candidate) {\n    if (!candidate.usernameFragment) {\n        // react-native-webrtc doesn't include usernameFragment in the candidate\n        const splittedCandidate = candidate.candidate.split(\" \");\n        const ufragIndex = splittedCandidate.findIndex((s)=>s === \"ufrag\") + 1;\n        const usernameFragment = splittedCandidate[ufragIndex];\n        return JSON.stringify({\n            ...candidate,\n            usernameFragment\n        });\n    } else {\n        return JSON.stringify(candidate.toJSON());\n    }\n}\nlet sdkInfo;\nlet osInfo;\nlet deviceInfo;\nlet webRtcInfo;\nconst setSdkInfo = (info)=>{\n    sdkInfo = info;\n};\nconst getSdkInfo = ()=>{\n    return sdkInfo;\n};\nconst setOSInfo = (info)=>{\n    osInfo = info;\n};\nconst getOSInfo = ()=>{\n    return osInfo;\n};\nconst setDeviceInfo = (info)=>{\n    deviceInfo = info;\n};\nconst getDeviceInfo = ()=>{\n    return deviceInfo;\n};\nconst getWebRTCInfo = ()=>{\n    return webRtcInfo;\n};\nconst setWebRTCInfo = (info)=>{\n    webRtcInfo = info;\n};\nconst getClientDetails = ()=>{\n    if (isReactNative()) {\n        // Since RN doesn't support web, sharing browser info is not required\n        return {\n            sdk: getSdkInfo(),\n            os: getOSInfo(),\n            device: getDeviceInfo()\n        };\n    }\n    const userAgent = new ua_parser_js__WEBPACK_IMPORTED_MODULE_3__.UAParser(navigator.userAgent);\n    const { browser, os, device, cpu } = userAgent.getResult();\n    return {\n        sdk: getSdkInfo(),\n        browser: {\n            name: browser.name || navigator.userAgent,\n            version: browser.version || \"\"\n        },\n        os: {\n            name: os.name || \"\",\n            version: os.version || \"\",\n            architecture: cpu.architecture || \"\"\n        },\n        device: {\n            name: [\n                device.vendor,\n                device.model,\n                device.type\n            ].filter(Boolean).join(\" \"),\n            version: \"\"\n        }\n    };\n};\nconst DEFAULT_BITRATE = 1250000;\nconst defaultTargetResolution = {\n    bitrate: DEFAULT_BITRATE,\n    width: 1280,\n    height: 720\n};\n/**\n * Determines the most optimal video layers for simulcasting\n * for the given track.\n *\n * @param videoTrack the video track to find optimal layers for.\n * @param targetResolution the expected target resolution.\n */ const findOptimalVideoLayers = (videoTrack, targetResolution = defaultTargetResolution)=>{\n    const optimalVideoLayers = [];\n    const settings = videoTrack.getSettings();\n    const { width: w = 0, height: h = 0 } = settings;\n    const isRNIos = isReactNative() && getOSInfo()?.name.toLowerCase() === \"ios\";\n    const maxBitrate = getComputedMaxBitrate(targetResolution, w, h);\n    let downscaleFactor = 1;\n    [\n        \"f\",\n        \"h\",\n        \"q\"\n    ].forEach((rid)=>{\n        // Reversing the order [f, h, q] to [q, h, f] as Chrome uses encoding index\n        // when deciding which layer to disable when CPU or bandwidth is constrained.\n        // Encodings should be ordered in increasing spatial resolution order.\n        optimalVideoLayers.unshift({\n            active: true,\n            rid,\n            width: Math.round(w / downscaleFactor),\n            height: Math.round(h / downscaleFactor),\n            maxBitrate: Math.round(maxBitrate / downscaleFactor),\n            scaleResolutionDownBy: downscaleFactor,\n            // Simulcast on iOS React-Native requires all encodings to share the same framerate\n            maxFramerate: {\n                f: 30,\n                h: isRNIos ? 30 : 25,\n                q: isRNIos ? 30 : 20\n            }[rid]\n        });\n        downscaleFactor *= 2;\n    });\n    // for simplicity, we start with all layers enabled, then this function\n    // will clear/reassign the layers that are not needed\n    return withSimulcastConstraints(settings, optimalVideoLayers);\n};\n/**\n * Computes the maximum bitrate for a given resolution.\n * If the current resolution is lower than the target resolution,\n * we want to proportionally reduce the target bitrate.\n * If the current resolution is higher than the target resolution,\n * we want to use the target bitrate.\n *\n * @param targetResolution the target resolution.\n * @param currentWidth the current width of the track.\n * @param currentHeight the current height of the track.\n */ const getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight)=>{\n    // if the current resolution is lower than the target resolution,\n    // we want to proportionally reduce the target bitrate\n    const { width: targetWidth, height: targetHeight } = targetResolution;\n    if (currentWidth < targetWidth || currentHeight < targetHeight) {\n        const currentPixels = currentWidth * currentHeight;\n        const targetPixels = targetWidth * targetHeight;\n        const reductionFactor = currentPixels / targetPixels;\n        return Math.round(targetResolution.bitrate * reductionFactor);\n    }\n    return targetResolution.bitrate;\n};\n/**\n * Browsers have different simulcast constraints for different video resolutions.\n *\n * This function modifies the provided list of video layers according to the\n * current implementation of simulcast constraints in the Chromium based browsers.\n *\n * https://chromium.googlesource.com/external/webrtc/+/refs/heads/main/media/engine/simulcast.cc#90\n */ const withSimulcastConstraints = (settings, optimalVideoLayers)=>{\n    let layers;\n    const size = Math.max(settings.width || 0, settings.height || 0);\n    if (size <= 320) {\n        // provide only one layer 320x240 (q), the one with the highest quality\n        layers = optimalVideoLayers.filter((layer)=>layer.rid === \"f\");\n    } else if (size <= 640) {\n        // provide two layers, 160x120 (q) and 640x480 (h)\n        layers = optimalVideoLayers.filter((layer)=>layer.rid !== \"h\");\n    } else {\n        // provide three layers for sizes > 640x480\n        layers = optimalVideoLayers;\n    }\n    const ridMapping = [\n        \"q\",\n        \"h\",\n        \"f\"\n    ];\n    return layers.map((layer, index)=>({\n            ...layer,\n            rid: ridMapping[index]\n        }));\n};\nconst findOptimalScreenSharingLayers = (videoTrack, preferences)=>{\n    const settings = videoTrack.getSettings();\n    return [\n        {\n            active: true,\n            rid: \"q\",\n            width: settings.width || 0,\n            height: settings.height || 0,\n            scaleResolutionDownBy: 1,\n            maxBitrate: preferences?.maxBitrate ?? 3000000,\n            maxFramerate: preferences?.maxFramerate ?? 30\n        }\n    ];\n};\nconst trackTypeToParticipantStreamKey = (trackType)=>{\n    switch(trackType){\n        case TrackType.SCREEN_SHARE:\n            return \"screenShareStream\";\n        case TrackType.SCREEN_SHARE_AUDIO:\n            return \"screenShareAudioStream\";\n        case TrackType.VIDEO:\n            return \"videoStream\";\n        case TrackType.AUDIO:\n            return \"audioStream\";\n        case TrackType.UNSPECIFIED:\n            throw new Error(\"Track type is unspecified\");\n        default:\n            const exhaustiveTrackTypeCheck = trackType;\n            throw new Error(`Unknown track type: ${exhaustiveTrackTypeCheck}`);\n    }\n};\nconst muteTypeToTrackType = (muteType)=>{\n    switch(muteType){\n        case \"audio\":\n            return TrackType.AUDIO;\n        case \"video\":\n            return TrackType.VIDEO;\n        case \"screenshare\":\n            return TrackType.SCREEN_SHARE;\n        case \"screenshare_audio\":\n            return TrackType.SCREEN_SHARE_AUDIO;\n        default:\n            const exhaustiveMuteTypeCheck = muteType;\n            throw new Error(`Unknown mute type: ${exhaustiveMuteTypeCheck}`);\n    }\n};\n/**\n * Checks if the provided update is a function patch.\n *\n * @param update the value to check.\n */ const isFunctionPatch = (update)=>typeof update === \"function\";\n/**\n * Gets the current value of an observable, or undefined if the observable has\n * not emitted a value yet.\n *\n * @param observable$ the observable to get the value from.\n */ const getCurrentValue = (observable$)=>{\n    let value;\n    let err = undefined;\n    (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n        observable$\n    ]).subscribe({\n        next: ([v])=>{\n            value = v;\n        },\n        error: (e)=>{\n            err = e;\n        }\n    }).unsubscribe();\n    if (err) throw err;\n    return value;\n};\n/**\n * Updates the value of the provided Subject.\n * An `update` can either be a new value or a function which takes\n * the current value and returns a new value.\n *\n * @param subject the subject to update.\n * @param update the update to apply to the subject.\n * @return the updated value.\n */ const setCurrentValue = (subject, update)=>{\n    const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;\n    subject.next(next);\n    return next;\n};\n/**\n * Creates a subscription and returns a function to unsubscribe.\n *\n * @param observable the observable to subscribe to.\n * @param handler the handler to call when the observable emits a value.\n */ const createSubscription = (observable, handler)=>{\n    const subscription = observable.subscribe(handler);\n    return ()=>{\n        subscription.unsubscribe();\n    };\n};\nvar rxUtils = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    createSubscription: createSubscription,\n    getCurrentValue: getCurrentValue,\n    setCurrentValue: setCurrentValue\n});\n/**\n * Creates a new combined {@link Comparator<T>} which sorts items by the given comparators.\n * The comparators are applied in the order they are given (left -> right).\n *\n * @param comparators the comparators to use for sorting.\n * @returns a combined {@link Comparator<T>}.\n */ const combineComparators = (...comparators)=>{\n    return (a, b)=>{\n        for (const comparator of comparators){\n            const result = comparator(a, b);\n            if (result !== 0) return result;\n        }\n        return 0;\n    };\n};\n/**\n * Creates a new comparator which sorts items in descending order.\n *\n * @example\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const byValueDesc = descending(byValue);\n *\n * @param comparator the comparator to wrap.\n */ const descending = (comparator)=>{\n    return (a, b)=>comparator(b, a);\n};\n/**\n * Creates a new comparator which conditionally applies the given comparator.\n *\n * @example\n * const shouldSortByValue = (a, b) => a % 2 === 0; // return false to turn it off\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const comparator = conditional(shouldSortByValue)(byValue);\n *\n * @param predicate the predicate to use for determining whether to apply the comparator.\n */ const conditional = (predicate)=>{\n    return (comparator)=>{\n        return (a, b)=>{\n            if (!predicate(a, b)) return 0;\n            return comparator(a, b);\n        };\n    };\n};\n/**\n * A no-op comparator which always returns 0.\n */ const noopComparator = ()=>{\n    return ()=>0;\n};\n/**\n * A comparator which sorts participants by the fact that they are the dominant speaker or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const dominantSpeaker = (a, b)=>{\n    if (a.isDominantSpeaker && !b.isDominantSpeaker) return -1;\n    if (!a.isDominantSpeaker && b.isDominantSpeaker) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by the fact that they are speaking or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const speaking = (a, b)=>{\n    if (a.isSpeaking && !b.isSpeaking) return -1;\n    if (!a.isSpeaking && b.isSpeaking) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by screen sharing status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const screenSharing = (a, b)=>{\n    if (hasScreenShare(a) && !hasScreenShare(b)) return -1;\n    if (!hasScreenShare(a) && hasScreenShare(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by video status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingVideo = (a, b)=>{\n    if (hasVideo(a) && !hasVideo(b)) return -1;\n    if (!hasVideo(a) && hasVideo(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by audio status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingAudio = (a, b)=>{\n    if (hasAudio(a) && !hasAudio(b)) return -1;\n    if (!hasAudio(a) && hasAudio(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which prioritizes participants who are pinned.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const pinned = (a, b)=>{\n    if (a.pin && b.pin) {\n        if (!a.pin.isLocalPin && b.pin.isLocalPin) return -1;\n        if (a.pin.isLocalPin && !b.pin.isLocalPin) return 1;\n        if (a.pin.pinnedAt > b.pin.pinnedAt) return -1;\n        if (a.pin.pinnedAt < b.pin.pinnedAt) return 1;\n    }\n    if (a.pin && !b.pin) return -1;\n    if (!a.pin && b.pin) return 1;\n    return 0;\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific reaction.\n *\n * @param type the reaction type.\n */ const reactionType = (type)=>{\n    return (a, b)=>{\n        if (a.reaction?.type === type && b.reaction?.type !== type) return -1;\n        if (a.reaction?.type !== type && b.reaction?.type === type) return 1;\n        return 0;\n    };\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific role.\n *\n * @param roles the roles to prioritize.\n */ const role = (...roles)=>(a, b)=>{\n        if (hasAnyRole(a, roles) && !hasAnyRole(b, roles)) return -1;\n        if (!hasAnyRole(a, roles) && hasAnyRole(b, roles)) return 1;\n        return 0;\n    };\n/**\n * A comparator which sorts participants by name.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const name = (a, b)=>{\n    if (a.name < b.name) return -1;\n    if (a.name > b.name) return 1;\n    return 0;\n};\nconst hasAnyRole = (p, roles)=>(p.roles || []).some((r)=>roles.includes(r));\nconst hasScreenShare = (p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE);\nconst hasVideo = (p)=>p.publishedTracks.includes(TrackType.VIDEO);\nconst hasAudio = (p)=>p.publishedTracks.includes(TrackType.AUDIO);\n// a comparator decorator which applies the decorated comparator only if the\n// participant is invisible.\n// This ensures stable sorting when all participants are visible.\nconst ifInvisibleBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE);\n/**\n * A comparator that applies the decorated comparator when a participant is\n * either invisible or its visibility state isn't known.\n * For visible participants, it ensures stable sorting.\n */ const ifInvisibleOrUnknownBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || a.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN);\n/**\n * The default sorting preset.\n */ const defaultSortPreset = combineComparators(pinned, screenSharing, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for speaker layout.\n */ const speakerLayoutSortPreset = combineComparators(pinned, screenSharing, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for layouts that don't render all participants but\n * instead, render them in pages.\n */ const paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for livestreams and audio rooms.\n */ const livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)), role(\"admin\", \"host\", \"speaker\"));\n/**\n * Represents the state of the current call.\n */ var CallingState;\n(function(CallingState) {\n    /**\n     * The call is in an unknown state.\n     */ CallingState[\"UNKNOWN\"] = \"unknown\";\n    /**\n     * The call is in an idle state.\n     */ CallingState[\"IDLE\"] = \"idle\";\n    /**\n     * The call is in the process of ringing.\n     * (User hasn't accepted nor rejected the call yet.)\n     */ CallingState[\"RINGING\"] = \"ringing\";\n    /**\n     * The call is in the process of joining.\n     */ CallingState[\"JOINING\"] = \"joining\";\n    /**\n     * The call is currently active.\n     */ CallingState[\"JOINED\"] = \"joined\";\n    /**\n     * The call has been left.\n     */ CallingState[\"LEFT\"] = \"left\";\n    /**\n     * The call is in the process of reconnecting.\n     */ CallingState[\"RECONNECTING\"] = \"reconnecting\";\n    /**\n     * The call is in the process of migrating from one node to another.\n     */ CallingState[\"MIGRATING\"] = \"migrating\";\n    /**\n     * The call has failed to reconnect.\n     */ CallingState[\"RECONNECTING_FAILED\"] = \"reconnecting-failed\";\n    /**\n     * The call is in offline mode.\n     */ CallingState[\"OFFLINE\"] = \"offline\";\n})(CallingState || (CallingState = {}));\n/**\n * Returns the default egress object - when no egress data is available.\n */ const defaultEgress = {\n    broadcasting: false,\n    hls: {\n        playlist_url: \"\"\n    },\n    rtmps: []\n};\n/**\n * Holds the state of the current call.\n * @react You don't have to use this class directly, as we are exposing the state through Hooks.\n */ class CallState {\n    /**\n     * Creates a new instance of the CallState class.\n     *\n     */ constructor(){\n        this.backstageSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.blockedUserIdsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.createdAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.endedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.startsAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.updatedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.createdBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.customSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({});\n        this.egressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.ingressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.recordingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.sessionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.transcribingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.endedBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.thumbnailsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.membersSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.ownCapabilitiesSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callingStateSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(CallingState.UNKNOWN);\n        this.startedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.participantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.anonymousParticipantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.participantsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callStatsReportSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of comparators that are used to sort the participants.\n         *\n         * @private\n         */ this.sortParticipantsBy = defaultSortPreset;\n        /**\n         * Sets the list of criteria that are used to sort the participants.\n         * To disable sorting, you can pass `noopComparator()`.\n         *\n         * @param comparator the comparator to use to sort the participants.\n         */ this.setSortParticipantsBy = (comparator)=>{\n            this.sortParticipantsBy = comparator;\n            // trigger re-sorting of participants\n            this.setCurrentValue(this.participantsSubject, (ps)=>ps);\n        };\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the number of participants in the current call.\n         *\n         * @internal\n         * @param count the number of participants.\n         */ this.setParticipantCount = (count)=>{\n            return this.setCurrentValue(this.participantCountSubject, count);\n        };\n        /**\n         * Sets the time the call session actually started.\n         *\n         * @internal\n         * @param startedAt the time the call session actually started.\n         */ this.setStartedAt = (startedAt)=>{\n            return this.setCurrentValue(this.startedAtSubject, startedAt);\n        };\n        /**\n         * Sets the number of anonymous participants in the current call.\n         *\n         * @internal\n         * @param count the number of anonymous participants.\n         */ this.setAnonymousParticipantCount = (count)=>{\n            return this.setCurrentValue(this.anonymousParticipantCountSubject, count);\n        };\n        /**\n         * Sets the list of participants in the current call.\n         *\n         * @internal\n         *\n         * @param participants the list of participants.\n         */ this.setParticipants = (participants)=>{\n            return this.setCurrentValue(this.participantsSubject, participants);\n        };\n        /**\n         * Sets the calling state.\n         *\n         * @internal\n         * @param state the new calling state.\n         */ this.setCallingState = (state)=>{\n            return this.setCurrentValue(this.callingStateSubject, state);\n        };\n        /**\n         * Sets the call stats report.\n         *\n         * @internal\n         * @param report the report to set.\n         */ this.setCallStatsReport = (report)=>{\n            return this.setCurrentValue(this.callStatsReportSubject, report);\n        };\n        /**\n         * Sets the members of the current call.\n         *\n         * @internal\n         * @param members the members to set.\n         */ this.setMembers = (members)=>{\n            this.setCurrentValue(this.membersSubject, members);\n        };\n        /**\n         * Sets the own capabilities.\n         *\n         * @internal\n         * @param capabilities the capabilities to set.\n         */ this.setOwnCapabilities = (capabilities)=>{\n            return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);\n        };\n        /**\n         * Will try to find the participant with the given sessionId in the current call.\n         *\n         * @param sessionId the sessionId of the participant to find.\n         * @returns the participant with the given sessionId or undefined if not found.\n         */ this.findParticipantBySessionId = (sessionId)=>{\n            return this.participants.find((p)=>p.sessionId === sessionId);\n        };\n        /**\n         * Returns a new lookup table of participants indexed by their session ID.\n         */ this.getParticipantLookupBySessionId = ()=>{\n            return this.participants.reduce((lookupTable, participant)=>{\n                lookupTable[participant.sessionId] = participant;\n                return lookupTable;\n            }, {});\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If the participant can't be found, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param patch the patch to apply to the participant.\n         * @returns the updated participant or `undefined` if the participant couldn't be found.\n         */ this.updateParticipant = (sessionId, patch)=>{\n            const participant = this.findParticipantBySessionId(sessionId);\n            if (!participant) {\n                this.logger(\"warn\", `Participant with sessionId ${sessionId} not found`);\n                return;\n            }\n            const thePatch = typeof patch === \"function\" ? patch(participant) : patch;\n            const updatedParticipant = {\n                // FIXME OL: this is not a deep merge, we might want to revisit this\n                ...participant,\n                ...thePatch\n            };\n            return this.setParticipants((participants)=>participants.map((p)=>p.sessionId === sessionId ? updatedParticipant : p));\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If a participant with matching `sessionId` can't be found, the provided\n         * `participant` is added to the list of participants.\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param participant the participant to update or add.\n         */ this.updateOrAddParticipant = (sessionId, participant)=>{\n            if (!this.findParticipantBySessionId(sessionId)) {\n                return this.setParticipants((participants)=>[\n                        ...participants,\n                        participant\n                    ]);\n            }\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    if (p.sessionId === sessionId) {\n                        return {\n                            ...p,\n                            ...participant\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates all participants in the current call whose session ID is in the given `sessionIds`.\n         * If no patches are provided, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param patch the patch to apply to the participants.\n         * @returns all participants, with all patch applied.\n         */ this.updateParticipants = (patch)=>{\n            if (Object.keys(patch).length === 0) return;\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    const thePatch = patch[p.sessionId];\n                    if (thePatch) {\n                        return {\n                            ...p,\n                            ...thePatch\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param event the video event that our backend sent us.\n         */ this.updateFromEvent = (event)=>{\n            const update = this.eventHandlers[event.type];\n            if (update) {\n                update(event);\n            }\n        };\n        /**\n         * Updates the participant pinned state with server side pinning data.\n         *\n         * @param pins the latest pins from the server.\n         */ this.setServerSidePins = (pins)=>{\n            const pinsLookup = pins.reduce((lookup, pin)=>{\n                lookup[pin.sessionId] = Date.now();\n                return lookup;\n            }, {});\n            return this.setParticipants((participants)=>participants.map((participant)=>{\n                    const serverSidePinnedAt = pinsLookup[participant.sessionId];\n                    // the participant is newly pinned\n                    if (serverSidePinnedAt) {\n                        return {\n                            ...participant,\n                            pin: {\n                                isLocalPin: false,\n                                pinnedAt: serverSidePinnedAt\n                            }\n                        };\n                    }\n                    // the participant is no longer pinned server side\n                    // we need to reset the pin\n                    if (participant.pin && !participant.pin.isLocalPin) {\n                        return {\n                            ...participant,\n                            pin: undefined\n                        };\n                    }\n                    // no changes to be applied\n                    return participant;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param call the call response from the server.\n         */ this.updateFromCallResponse = (call)=>{\n            this.setCurrentValue(this.backstageSubject, call.backstage);\n            this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);\n            this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));\n            this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));\n            this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : undefined);\n            this.setCurrentValue(this.endedAtSubject, call.ended_at ? new Date(call.ended_at) : undefined);\n            this.setCurrentValue(this.createdBySubject, call.created_by);\n            this.setCurrentValue(this.customSubject, call.custom);\n            this.setCurrentValue(this.egressSubject, call.egress);\n            this.setCurrentValue(this.ingressSubject, call.ingress);\n            this.setCurrentValue(this.recordingSubject, call.recording);\n            this.setCurrentValue(this.sessionSubject, call.session);\n            this.setCurrentValue(this.settingsSubject, call.settings);\n            this.setCurrentValue(this.transcribingSubject, call.transcribing);\n            this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);\n        };\n        this.updateFromMemberRemoved = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.filter((m)=>event.members.indexOf(m.user_id) === -1));\n        };\n        this.updateFromMemberAdded = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>[\n                    ...members,\n                    ...event.members\n                ]);\n        };\n        this.updateFromHLSBroadcastStopped = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastingFailed = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastStarted = (event)=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: true,\n                    hls: {\n                        ...egress.hls,\n                        playlist_url: event.hls_playlist_url\n                    }\n                }));\n        };\n        this.updateFromSessionParticipantLeft = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_left event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                return {\n                    ...session,\n                    participants: participants.filter((p)=>p.user_session_id !== user_session_id),\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)\n                    }\n                };\n            });\n        };\n        this.updateFromSessionParticipantJoined = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_joined event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                // It could happen that the backend delivers the same participant more than once.\n                // Once with the call.session_started event and once again with the\n                // call.session_participant_joined event. In this case,\n                // we should update the existing participant and prevent duplicating it.\n                let shouldInsertParticipant = true;\n                const updatedParticipants = participants.map((p)=>{\n                    if (p.user_session_id === user_session_id) {\n                        shouldInsertParticipant = false;\n                        return event.participant;\n                    }\n                    return p;\n                });\n                if (shouldInsertParticipant) {\n                    // this is a new array, we can safely push the new participant\n                    updatedParticipants.push(event.participant);\n                }\n                // If we are updating an existing participant, we don't want to increment\n                // the participant_by_role count.\n                const increment = shouldInsertParticipant ? 1 : 0;\n                return {\n                    ...session,\n                    participants: updatedParticipants,\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: (participants_count_by_role[user.role] || 0) + increment\n                    }\n                };\n            });\n        };\n        this.updateMembers = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.map((member)=>{\n                    const memberUpdate = event.members.find((m)=>m.user_id === member.user_id);\n                    return memberUpdate ? memberUpdate : member;\n                }));\n        };\n        this.updateParticipantReaction = (event)=>{\n            const { user, custom, type, emoji_code } = event.reaction;\n            this.setParticipants((participants)=>{\n                return participants.map((p)=>{\n                    // skip if the reaction is not for this participant\n                    if (p.userId !== user.id) return p;\n                    // update the participant with the new reaction\n                    return {\n                        ...p,\n                        reaction: {\n                            type,\n                            emoji_code,\n                            custom\n                        }\n                    };\n                });\n            });\n        };\n        this.unblockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>{\n                if (!current) return current;\n                return current.filter((id)=>id !== event.user.id);\n            });\n        };\n        this.blockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>[\n                    ...current || [],\n                    event.user.id\n                ]);\n        };\n        this.updateOwnCapabilities = (event)=>{\n            if (event.user.id === this.localParticipant?.userId) {\n                this.setCurrentValue(this.ownCapabilitiesSubject, event.own_capabilities);\n            }\n        };\n        this.logger = getLogger([\n            \"CallState\"\n        ]);\n        this.participants$ = this.participantsSubject.asObservable().pipe(// maintain stable-sort by mutating the participants stored\n        // in the original subject\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((ps)=>ps.sort(this.sortParticipantsBy)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.localParticipant$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.remoteParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.pinnedParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!!p.pin)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.dominantSpeaker$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isDominantSpeaker)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.hasOngoingScreenShare$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.some((p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE))), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.startedAt$ = this.startedAtSubject.asObservable();\n        this.participantCount$ = this.participantCountSubject.asObservable();\n        this.anonymousParticipantCount$ = this.anonymousParticipantCountSubject.asObservable();\n        this.callStatsReport$ = this.callStatsReportSubject.asObservable();\n        this.members$ = this.membersSubject.asObservable();\n        this.ownCapabilities$ = this.ownCapabilitiesSubject.asObservable();\n        this.callingState$ = this.callingStateSubject.asObservable();\n        this.backstage$ = this.backstageSubject.asObservable();\n        this.blockedUserIds$ = this.blockedUserIdsSubject.asObservable();\n        this.createdAt$ = this.createdAtSubject.asObservable();\n        this.endedAt$ = this.endedAtSubject.asObservable();\n        this.startsAt$ = this.startsAtSubject.asObservable();\n        this.updatedAt$ = this.updatedAtSubject.asObservable();\n        this.createdBy$ = this.createdBySubject.asObservable();\n        this.custom$ = this.customSubject.asObservable();\n        this.egress$ = this.egressSubject.asObservable();\n        this.ingress$ = this.ingressSubject.asObservable();\n        this.recording$ = this.recordingSubject.asObservable();\n        this.session$ = this.sessionSubject.asObservable();\n        this.settings$ = this.settingsSubject.asObservable();\n        this.transcribing$ = this.transcribingSubject.asObservable();\n        this.endedBy$ = this.endedBySubject.asObservable();\n        this.thumbnails$ = this.thumbnailsSubject.asObservable();\n        this.eventHandlers = {\n            // these events are not updating the call state:\n            \"call.closed_caption\": undefined,\n            \"call.permission_request\": undefined,\n            \"call.recording_failed\": undefined,\n            \"call.recording_ready\": undefined,\n            \"call.transcription_started\": undefined,\n            \"call.transcription_stopped\": undefined,\n            \"call.transcription_ready\": undefined,\n            \"call.transcription_failed\": undefined,\n            \"call.user_muted\": undefined,\n            \"connection.error\": undefined,\n            \"connection.ok\": undefined,\n            \"health.check\": undefined,\n            custom: undefined,\n            // events that update call state:\n            \"call.accepted\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.blocked_user\": this.blockUser,\n            \"call.created\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ended\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setCurrentValue(this.endedBySubject, e.user);\n            },\n            \"call.hls_broadcasting_failed\": this.updateFromHLSBroadcastingFailed,\n            \"call.hls_broadcasting_started\": this.updateFromHLSBroadcastStarted,\n            \"call.hls_broadcasting_stopped\": this.updateFromHLSBroadcastStopped,\n            \"call.live_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.member_added\": this.updateFromMemberAdded,\n            \"call.member_removed\": this.updateFromMemberRemoved,\n            \"call.member_updated_permission\": this.updateMembers,\n            \"call.member_updated\": this.updateMembers,\n            \"call.notification\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setMembers(e.members);\n            },\n            \"call.permissions_updated\": this.updateOwnCapabilities,\n            \"call.reaction_new\": this.updateParticipantReaction,\n            \"call.recording_started\": ()=>this.setCurrentValue(this.recordingSubject, true),\n            \"call.recording_stopped\": ()=>this.setCurrentValue(this.recordingSubject, false),\n            \"call.rejected\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ring\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_ended\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_participant_joined\": this.updateFromSessionParticipantJoined,\n            \"call.session_participant_left\": this.updateFromSessionParticipantLeft,\n            \"call.session_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.unblocked_user\": this.unblockUser,\n            \"call.updated\": (e)=>this.updateFromCallResponse(e.call)\n        };\n    }\n    /**\n     * The server-side counted number of participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get participantCount() {\n        return this.getCurrentValue(this.participantCount$);\n    }\n    /**\n     * The time the call session actually started.\n     * Useful for displaying the call duration.\n     */ get startedAt() {\n        return this.getCurrentValue(this.startedAt$);\n    }\n    /**\n     * The server-side counted number of anonymous participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get anonymousParticipantCount() {\n        return this.getCurrentValue(this.anonymousParticipantCount$);\n    }\n    /**\n     * The list of participants in the current call.\n     */ get participants() {\n        return this.getCurrentValue(this.participants$);\n    }\n    /**\n     * The local participant in the current call.\n     */ get localParticipant() {\n        return this.getCurrentValue(this.localParticipant$);\n    }\n    /**\n     * The list of remote participants in the current call.\n     */ get remoteParticipants() {\n        return this.getCurrentValue(this.remoteParticipants$);\n    }\n    /**\n     * The dominant speaker in the current call.\n     */ get dominantSpeaker() {\n        return this.getCurrentValue(this.dominantSpeaker$);\n    }\n    /**\n     * The list of pinned participants in the current call.\n     */ get pinnedParticipants() {\n        return this.getCurrentValue(this.pinnedParticipants$);\n    }\n    /**\n     * Tell if there is an ongoing screen share in this call.\n     */ get hasOngoingScreenShare() {\n        return this.getCurrentValue(this.hasOngoingScreenShare$);\n    }\n    /**\n     * The calling state.\n     */ get callingState() {\n        return this.getCurrentValue(this.callingState$);\n    }\n    /**\n     * The call stats report.\n     */ get callStatsReport() {\n        return this.getCurrentValue(this.callStatsReport$);\n    }\n    /**\n     * The members of the current call.\n     */ get members() {\n        return this.getCurrentValue(this.members$);\n    }\n    /**\n     * The capabilities of the current user for the current call.\n     */ get ownCapabilities() {\n        return this.getCurrentValue(this.ownCapabilities$);\n    }\n    /**\n     * The backstage state.\n     */ get backstage() {\n        return this.getCurrentValue(this.backstage$);\n    }\n    /**\n     * Will provide the list of blocked user IDs.\n     */ get blockedUserIds() {\n        return this.getCurrentValue(this.blockedUserIds$);\n    }\n    /**\n     * Will provide the time when this call has been created.\n     */ get createdAt() {\n        return this.getCurrentValue(this.createdAt$);\n    }\n    /**\n     * Will provide the time when this call has been ended.\n     */ get endedAt() {\n        return this.getCurrentValue(this.endedAt$);\n    }\n    /**\n     * Will provide the time when this call has been scheduled to start.\n     */ get startsAt() {\n        return this.getCurrentValue(this.startsAt$);\n    }\n    /**\n     * Will provide the time when this call has been updated.\n     */ get updatedAt() {\n        return this.getCurrentValue(this.updatedAt$);\n    }\n    /**\n     * Will provide the user who created this call.\n     */ get createdBy() {\n        return this.getCurrentValue(this.createdBy$);\n    }\n    /**\n     * Will provide the custom data of this call.\n     */ get custom() {\n        return this.getCurrentValue(this.custom$);\n    }\n    /**\n     * Will provide the egress data of this call.\n     */ get egress() {\n        return this.getCurrentValue(this.egress$);\n    }\n    /**\n     * Will provide the ingress data of this call.\n     */ get ingress() {\n        return this.getCurrentValue(this.ingress$);\n    }\n    /**\n     * Will provide the recording state of this call.\n     */ get recording() {\n        return this.getCurrentValue(this.recording$);\n    }\n    /**\n     * Will provide the session data of this call.\n     */ get session() {\n        return this.getCurrentValue(this.session$);\n    }\n    /**\n     * Will provide the settings of this call.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Will provide the transcribing state of this call.\n     */ get transcribing() {\n        return this.getCurrentValue(this.transcribing$);\n    }\n    /**\n     * Will provide the user who ended this call.\n     */ get endedBy() {\n        return this.getCurrentValue(this.endedBy$);\n    }\n    /**\n     * Will provide the thumbnails of this call, if enabled in the call settings.\n     */ get thumbnails() {\n        return this.getCurrentValue(this.thumbnails$);\n    }\n}\nclass StreamVideoWriteableStateStore {\n    constructor(){\n        /**\n         * A store keeping data of a successfully connected user over WS to the coordinator server.\n         */ this.connectedUserSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of {@link Call} objects created/tracked by this client.\n         */ this.callsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the currently connected user.\n         *\n         * @internal\n         * @param user the user to set as connected.\n         */ this.setConnectedUser = (user)=>{\n            return this.setCurrentValue(this.connectedUserSubject, user);\n        };\n        /**\n         * Sets the list of {@link Call} objects created/tracked by this client.\n         * @param calls\n         */ this.setCalls = (calls)=>{\n            return this.setCurrentValue(this.callsSubject, calls);\n        };\n        /**\n         * Adds a {@link Call} object to the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to add.\n         */ this.registerCall = (call)=>{\n            if (!this.calls.find((c)=>c.cid === call.cid)) {\n                this.setCalls((calls)=>[\n                        ...calls,\n                        call\n                    ]);\n            }\n        };\n        /**\n         * Removes a {@link Call} object from the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to remove\n         */ this.unregisterCall = (call)=>{\n            return this.setCalls((calls)=>calls.filter((c)=>c !== call));\n        };\n        /**\n         * Finds a {@link Call} object in the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param type the type of call to find.\n         * @param id the id of the call to find.\n         */ this.findCall = (type, id)=>{\n            return this.calls.find((c)=>c.type === type && c.id === id);\n        };\n        this.connectedUserSubject.subscribe(async (user)=>{\n            // leave all calls when the user disconnects.\n            if (!user) {\n                const logger = getLogger([\n                    \"client-state\"\n                ]);\n                for (const call of this.calls){\n                    if (call.state.callingState === CallingState.LEFT) continue;\n                    logger(\"info\", `User disconnected, leaving call: ${call.cid}`);\n                    await call.leave({\n                        reason: \"client.disconnectUser() called\"\n                    }).catch((err)=>{\n                        logger(\"error\", `Error leaving call: ${call.cid}`, err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * The currently connected user.\n     */ get connectedUser() {\n        return this.getCurrentValue(this.connectedUserSubject);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return this.getCurrentValue(this.callsSubject);\n    }\n}\n/**\n * A reactive store that exposes state variables in a reactive manner.\n * You can subscribe to changes of the different state variables.\n * This central store contains all the state variables related to [`StreamVideoClient`](./StreamVideClient.md) and [`Call`](./Call.md).\n */ class StreamVideoReadOnlyStateStore {\n    constructor(store){\n        /**\n         * This method allows you the get the current value of a state variable.\n         *\n         * @param observable the observable to get the current value of.\n         * @returns the current value of the observable.\n         */ this.getCurrentValue = getCurrentValue;\n        // convert and expose subjects as observables\n        this.connectedUser$ = store.connectedUserSubject.asObservable();\n        this.calls$ = store.callsSubject.asObservable();\n    }\n    /**\n     * The current user connected over WS to the backend.\n     */ get connectedUser() {\n        return getCurrentValue(this.connectedUser$);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return getCurrentValue(this.calls$);\n    }\n}\nconst getRtpMap = (line)=>{\n    // Example: a=rtpmap:110 opus/48000/2\n    const rtpRegex = /^a=rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/;\n    // The first captured group is the payload type number, the second captured group is the encoding name, the third captured group is the clock rate, and the fourth captured group is any additional parameters.\n    const rtpMatch = rtpRegex.exec(line);\n    if (rtpMatch) {\n        return {\n            original: rtpMatch[0],\n            payload: rtpMatch[1],\n            codec: rtpMatch[2]\n        };\n    }\n};\nconst getFmtp = (line)=>{\n    // Example: a=fmtp:111 minptime=10; useinbandfec=1\n    const fmtpRegex = /^a=fmtp:(\\d*) (.*)/;\n    const fmtpMatch = fmtpRegex.exec(line);\n    // The first captured group is the payload type number, the second captured group is any additional parameters.\n    if (fmtpMatch) {\n        return {\n            original: fmtpMatch[0],\n            payload: fmtpMatch[1],\n            config: fmtpMatch[2]\n        };\n    }\n};\n/**\n * gets the media section for the specified media type.\n * The media section contains the media type, port, codec, and payload type.\n * Example: m=video 9 UDP/TLS/RTP/SAVPF 100 101 96 97 35 36 102 125 127\n */ const getMedia = (line, mediaType)=>{\n    const regex = new RegExp(`(m=${mediaType} \\\\d+ [\\\\w/]+) ([\\\\d\\\\s]+)`);\n    const match = regex.exec(line);\n    if (match) {\n        return {\n            original: match[0],\n            mediaWithPorts: match[1],\n            codecOrder: match[2]\n        };\n    }\n};\nconst getMediaSection = (sdp, mediaType)=>{\n    let media;\n    const rtpMap = [];\n    const fmtp = [];\n    let isTheRequiredMediaSection = false;\n    sdp.split(/(\\r\\n|\\r|\\n)/).forEach((line)=>{\n        const isValidLine = /^([a-z])=(.*)/.test(line);\n        if (!isValidLine) return;\n        /*\n          NOTE: according to https://www.rfc-editor.org/rfc/rfc8866.pdf\n          Each media description starts with an \"m=\" line and continues to the next media description or the end of the whole session description, whichever comes first\n        */ const type = line[0];\n        if (type === \"m\") {\n            const _media = getMedia(line, mediaType);\n            isTheRequiredMediaSection = !!_media;\n            if (_media) {\n                media = _media;\n            }\n        } else if (isTheRequiredMediaSection && type === \"a\") {\n            const rtpMapLine = getRtpMap(line);\n            const fmtpLine = getFmtp(line);\n            if (rtpMapLine) {\n                rtpMap.push(rtpMapLine);\n            } else if (fmtpLine) {\n                fmtp.push(fmtpLine);\n            }\n        }\n    });\n    if (media) {\n        return {\n            media,\n            rtpMap,\n            fmtp\n        };\n    }\n};\n/**\n * Gets the fmtp line corresponding to opus\n */ const getOpusFmtp = (sdp)=>{\n    const section = getMediaSection(sdp, \"audio\");\n    const rtpMap = section?.rtpMap.find((r)=>r.codec.toLowerCase() === \"opus\");\n    const codecId = rtpMap?.payload;\n    if (codecId) {\n        return section?.fmtp.find((f)=>f.payload === codecId);\n    }\n};\n/**\n * Returns an SDP with DTX enabled or disabled.\n */ const toggleDtx = (sdp, enable)=>{\n    const opusFmtp = getOpusFmtp(sdp);\n    if (opusFmtp) {\n        const matchDtx = /usedtx=(\\d)/.exec(opusFmtp.config);\n        const requiredDtxConfig = `usedtx=${enable ? \"1\" : \"0\"}`;\n        if (matchDtx) {\n            const newFmtp = opusFmtp.original.replace(/usedtx=(\\d)/, requiredDtxConfig);\n            return sdp.replace(opusFmtp.original, newFmtp);\n        } else {\n            const newFmtp = `${opusFmtp.original};${requiredDtxConfig}`;\n            return sdp.replace(opusFmtp.original, newFmtp);\n        }\n    }\n    return sdp;\n};\n/**\n * Enables high-quality audio through SDP munging for the given trackMid.\n *\n * @param sdp the SDP to munge.\n * @param trackMid the trackMid.\n * @param maxBitrate the max bitrate to set.\n */ const enableHighQualityAudio = (sdp, trackMid, maxBitrate = 510000)=>{\n    maxBitrate = Math.max(Math.min(maxBitrate, 510000), 96000);\n    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n    const audioMedia = parsedSdp.media.find((m)=>m.type === \"audio\" && String(m.mid) === trackMid);\n    if (!audioMedia) return sdp;\n    const opusRtp = audioMedia.rtp.find((r)=>r.codec === \"opus\");\n    if (!opusRtp) return sdp;\n    const opusFmtp = audioMedia.fmtp.find((f)=>f.payload === opusRtp.payload);\n    if (!opusFmtp) return sdp;\n    // enable stereo, if not already enabled\n    if (opusFmtp.config.match(/stereo=(\\d)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/stereo=(\\d)/, \"stereo=1\");\n    } else {\n        opusFmtp.config = `${opusFmtp.config};stereo=1`;\n    }\n    // set maxaveragebitrate, to the given value\n    if (opusFmtp.config.match(/maxaveragebitrate=(\\d*)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/maxaveragebitrate=(\\d*)/, `maxaveragebitrate=${maxBitrate}`);\n    } else {\n        opusFmtp.config = `${opusFmtp.config};maxaveragebitrate=${maxBitrate}`;\n    }\n    return sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp);\n};\nconst logger$3 = getLogger([\n    \"Publisher\"\n]);\n/**\n * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU\n * @internal\n */ class Publisher {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Publisher` instance.\n     *\n     * @param connectionConfig the connection configuration to use.\n     * @param sfuClient the SFU client to use.\n     * @param state the call state to use.\n     * @param dispatcher the dispatcher to use.\n     * @param isDtxEnabled whether DTX is enabled.\n     * @param isRedEnabled whether RED is enabled.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE once connection goes to `disconnected` state.\n     */ constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, iceRestartDelay = 2500 }){\n        this.transceiverRegistry = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.publishOptionsPerTrackType = new Map();\n        /**\n         * An array maintaining the order how transceivers were added to the peer connection.\n         * This is needed because some browsers (Firefox) don't reliably report\n         * trackId and `mid` parameters.\n         *\n         * @private\n         */ this.transceiverInitOrder = [];\n        this.trackKindMapping = {\n            [TrackType.AUDIO]: \"audio\",\n            [TrackType.VIDEO]: \"video\",\n            [TrackType.SCREEN_SHARE]: \"video\",\n            [TrackType.SCREEN_SHARE_AUDIO]: \"audio\",\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.trackLayersCache = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.isIceRestarting = false;\n        this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            pc.addEventListener(\"signalingstatechange\", this.onSignalingStateChange);\n            return pc;\n        };\n        /**\n         * Closes the publisher PeerConnection and cleans up the resources.\n         */ this.close = ({ stopTracks = true } = {})=>{\n            if (stopTracks) {\n                this.stopPublishing();\n                Object.keys(this.transceiverRegistry).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.transceiverRegistry[trackType] = undefined;\n                });\n                Object.keys(this.trackLayersCache).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.trackLayersCache[trackType] = undefined;\n                });\n            }\n            clearTimeout(this.iceRestartTimeout);\n            this.unsubscribeOnIceRestart();\n            this.pc.removeEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            this.pc.close();\n        };\n        /**\n         * Starts publishing the given track of the given media stream.\n         *\n         * Consecutive calls to this method will replace the stream.\n         * The previous stream will be stopped.\n         *\n         * @param mediaStream the media stream to publish.\n         * @param track the track to publish.\n         * @param trackType the track type to publish.\n         * @param opts the optional publish options to use.\n         */ this.publishStream = async (mediaStream, track, trackType, opts = {})=>{\n            if (track.readyState === \"ended\") {\n                throw new Error(`Can't publish a track that has ended already.`);\n            }\n            let transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track && t.sender.track?.kind === this.trackKindMapping[trackType]);\n            /**\n             * An event handler which listens for the 'ended' event on the track.\n             * Once the track has ended, it will notify the SFU and update the state.\n             */ const handleTrackEnded = async ()=>{\n                logger$3(\"info\", `Track ${TrackType[trackType]} has ended, notifying the SFU`);\n                await this.notifyTrackMuteStateChanged(mediaStream, trackType, true);\n                // clean-up, this event listener needs to run only once.\n                track.removeEventListener(\"ended\", handleTrackEnded);\n            };\n            if (!transceiver) {\n                const { settings } = this.state;\n                const targetResolution = settings?.video.target_resolution;\n                const videoEncodings = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, opts.screenShareSettings) : undefined;\n                let preferredCodec = opts.preferredCodec;\n                if (!preferredCodec && trackType === TrackType.VIDEO) {\n                    if (isReactNative()) {\n                        const osName = getOSInfo()?.name.toLowerCase();\n                        if (osName === \"ipados\") {\n                            // in ipads it was noticed that if vp8 codec is used\n                            // then the bytes sent is 0 in the outbound-rtp\n                            // so we are forcing h264 codec for ipads\n                            preferredCodec = \"H264\";\n                        } else if (osName === \"android\") {\n                            preferredCodec = \"VP8\";\n                        }\n                    }\n                }\n                const codecPreferences = this.getCodecPreferences(trackType, preferredCodec);\n                // listen for 'ended' event on the track as it might be ended abruptly\n                // by an external factor as permission revokes, device disconnected, etc.\n                // keep in mind that `track.stop()` doesn't trigger this event.\n                track.addEventListener(\"ended\", handleTrackEnded);\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                transceiver = this.pc.addTransceiver(track, {\n                    direction: \"sendonly\",\n                    streams: trackType === TrackType.VIDEO || trackType === TrackType.SCREEN_SHARE ? [\n                        mediaStream\n                    ] : undefined,\n                    sendEncodings: videoEncodings\n                });\n                logger$3(\"debug\", `Added ${TrackType[trackType]} transceiver`);\n                this.transceiverInitOrder.push(trackType);\n                this.transceiverRegistry[trackType] = transceiver;\n                this.publishOptionsPerTrackType.set(trackType, opts);\n                if (\"setCodecPreferences\" in transceiver && codecPreferences) {\n                    logger$3(\"info\", `Setting ${TrackType[trackType]} codec preferences`, codecPreferences);\n                    transceiver.setCodecPreferences(codecPreferences);\n                }\n            } else {\n                const previousTrack = transceiver.sender.track;\n                // don't stop the track if we are re-publishing the same track\n                if (previousTrack && previousTrack !== track) {\n                    previousTrack.stop();\n                    previousTrack.removeEventListener(\"ended\", handleTrackEnded);\n                    track.addEventListener(\"ended\", handleTrackEnded);\n                }\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                await transceiver.sender.replaceTrack(track);\n            }\n            await this.notifyTrackMuteStateChanged(mediaStream, trackType, false);\n        };\n        /**\n         * Stops publishing the given track type to the SFU, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         * @param trackType the track type to unpublish.\n         * @param stopTrack specifies whether track should be stopped or just disabled\n         */ this.unpublishStream = async (trackType, stopTrack)=>{\n            const transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track);\n            if (transceiver && transceiver.sender.track && (stopTrack ? transceiver.sender.track.readyState === \"live\" : transceiver.sender.track.enabled)) {\n                stopTrack ? transceiver.sender.track.stop() : transceiver.sender.track.enabled = false;\n                // We don't need to notify SFU if unpublishing in response to remote soft mute\n                if (this.state.localParticipant?.publishedTracks.includes(trackType)) {\n                    await this.notifyTrackMuteStateChanged(undefined, trackType, true);\n                }\n            }\n        };\n        /**\n         * Returns true if the given track type is currently being published to the SFU.\n         *\n         * @param trackType the track type to check.\n         */ this.isPublishing = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\" && sender.track.enabled;\n            }\n            return false;\n        };\n        /**\n         * Returns true if the given track type is currently live\n         *\n         * @param trackType the track type to check.\n         */ this.isLive = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\";\n            }\n            return false;\n        };\n        this.notifyTrackMuteStateChanged = async (mediaStream, trackType, isMuted)=>{\n            await this.sfuClient.updateMuteState(trackType, isMuted);\n            const audioOrVideoOrScreenShareStream = trackTypeToParticipantStreamKey(trackType);\n            if (isMuted) {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>({\n                        publishedTracks: p.publishedTracks.filter((t)=>t !== trackType),\n                        [audioOrVideoOrScreenShareStream]: undefined\n                    }));\n            } else {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>{\n                    return {\n                        publishedTracks: p.publishedTracks.includes(trackType) ? p.publishedTracks : [\n                            ...p.publishedTracks,\n                            trackType\n                        ],\n                        [audioOrVideoOrScreenShareStream]: mediaStream\n                    };\n                });\n            }\n        };\n        /**\n         * Stops publishing all tracks and stop all tracks.\n         */ this.stopPublishing = ()=>{\n            logger$3(\"debug\", \"Stopping publishing all tracks\");\n            this.pc.getSenders().forEach((s)=>{\n                s.track?.stop();\n                if (this.pc.signalingState !== \"closed\") {\n                    this.pc.removeTrack(s);\n                }\n            });\n        };\n        this.updateVideoPublishQuality = async (enabledLayers)=>{\n            logger$3(\"info\", \"Update publish quality, requested layers by SFU:\", enabledLayers);\n            const videoSender = this.transceiverRegistry[TrackType.VIDEO]?.sender;\n            if (!videoSender) {\n                logger$3(\"warn\", \"Update publish quality, no video sender found.\");\n                return;\n            }\n            const params = videoSender.getParameters();\n            if (params.encodings.length === 0) {\n                logger$3(\"warn\", \"Update publish quality, No suitable video encoding quality found\");\n                return;\n            }\n            let changed = false;\n            let enabledRids = enabledLayers.filter((ly)=>ly.active).map((ly)=>ly.name);\n            params.encodings.forEach((enc)=>{\n                // flip 'active' flag only when necessary\n                const shouldEnable = enabledRids.includes(enc.rid);\n                if (shouldEnable !== enc.active) {\n                    enc.active = shouldEnable;\n                    changed = true;\n                }\n                if (shouldEnable) {\n                    let layer = enabledLayers.find((vls)=>vls.name === enc.rid);\n                    if (layer !== undefined) {\n                        if (layer.scaleResolutionDownBy >= 1 && layer.scaleResolutionDownBy !== enc.scaleResolutionDownBy) {\n                            logger$3(\"debug\", \"[dynascale]: setting scaleResolutionDownBy from server\", \"layer\", layer.name, \"scale-resolution-down-by\", layer.scaleResolutionDownBy);\n                            enc.scaleResolutionDownBy = layer.scaleResolutionDownBy;\n                            changed = true;\n                        }\n                        if (layer.maxBitrate > 0 && layer.maxBitrate !== enc.maxBitrate) {\n                            logger$3(\"debug\", \"[dynascale] setting max-bitrate from the server\", \"layer\", layer.name, \"max-bitrate\", layer.maxBitrate);\n                            enc.maxBitrate = layer.maxBitrate;\n                            changed = true;\n                        }\n                        if (layer.maxFramerate > 0 && layer.maxFramerate !== enc.maxFramerate) {\n                            logger$3(\"debug\", \"[dynascale]: setting maxFramerate from server\", \"layer\", layer.name, \"max-framerate\", layer.maxFramerate);\n                            enc.maxFramerate = layer.maxFramerate;\n                            changed = true;\n                        }\n                    }\n                }\n            });\n            const activeLayers = params.encodings.filter((e)=>e.active);\n            if (changed) {\n                await videoSender.setParameters(params);\n                logger$3(\"info\", `Update publish quality, enabled rids: `, activeLayers);\n            } else {\n                logger$3(\"info\", `Update publish quality, no change: `, activeLayers);\n            }\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        this.getCodecPreferences = (trackType, preferredCodec)=>{\n            if (trackType === TrackType.VIDEO) {\n                return getPreferredCodecs(\"video\", preferredCodec || \"vp8\");\n            }\n            if (trackType === TrackType.AUDIO) {\n                const defaultAudioCodec = this.isRedEnabled ? \"red\" : \"opus\";\n                const codecToRemove = !this.isRedEnabled ? \"red\" : undefined;\n                return getPreferredCodecs(\"audio\", preferredCodec ?? defaultAudioCodec, codecToRemove);\n            }\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$3(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.PUBLISHER_UNSPECIFIED\n            });\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Performs a migration of this publisher instance to a new SFU.\n         *\n         * Initiates a new `iceRestart` offer/answer exchange with the new SFU.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = async (sfuClient, connectionConfig)=>{\n            this.sfuClient = sfuClient;\n            this.pc.setConfiguration(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            const shouldRestartIce = this.pc.iceConnectionState === \"connected\";\n            if (shouldRestartIce) {\n                // negotiate only if there are tracks to publish\n                await this.negotiate({\n                    iceRestart: true\n                });\n            }\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$3(\"debug\", \"Restarting ICE connection\");\n            const signalingState = this.pc.signalingState;\n            if (this.isIceRestarting || signalingState === \"have-local-offer\") {\n                logger$3(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            await this.negotiate({\n                iceRestart: true\n            });\n        };\n        this.onNegotiationNeeded = async ()=>{\n            await this.negotiate();\n        };\n        /**\n         * Initiates a new offer/answer exchange with the currently connected SFU.\n         *\n         * @param options the optional offer options to use.\n         */ this.negotiate = async (options)=>{\n            this.isIceRestarting = options?.iceRestart ?? false;\n            const offer = await this.pc.createOffer(options);\n            let sdp = this.mungeCodecs(offer.sdp);\n            if (sdp && this.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n                const transceiver = this.transceiverRegistry[TrackType.SCREEN_SHARE_AUDIO];\n                if (transceiver && transceiver.sender.track) {\n                    const mid = transceiver.mid ?? this.extractMid(sdp, transceiver.sender.track, TrackType.SCREEN_SHARE_AUDIO);\n                    sdp = enableHighQualityAudio(sdp, mid);\n                }\n            }\n            // set the munged SDP back to the offer\n            offer.sdp = sdp;\n            const trackInfos = this.getCurrentTrackInfos(offer.sdp);\n            if (trackInfos.length === 0) {\n                throw new Error(`Can't initiate negotiation without announcing any tracks`);\n            }\n            await this.pc.setLocalDescription(offer);\n            const { response } = await this.sfuClient.setPublisher({\n                sdp: offer.sdp || \"\",\n                tracks: trackInfos\n            });\n            try {\n                await this.pc.setRemoteDescription({\n                    type: \"answer\",\n                    sdp: response.sdp\n                });\n            } catch (e) {\n                logger$3(\"error\", `setRemoteDescription error`, {\n                    sdp: response.sdp,\n                    error: e\n                });\n            }\n            this.isIceRestarting = false;\n            this.sfuClient.iceTrickleBuffer.publisherCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$3(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n        };\n        this.mungeCodecs = (sdp)=>{\n            if (sdp) {\n                sdp = toggleDtx(sdp, this.isDtxEnabled);\n            }\n            return sdp;\n        };\n        this.extractMid = (sdp, track, trackType)=>{\n            if (!sdp) {\n                logger$3(\"warn\", \"No SDP found. Returning empty mid\");\n                return \"\";\n            }\n            logger$3(\"debug\", `No 'mid' found for track. Trying to find it from the Offer SDP`);\n            const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n            const media = parsedSdp.media.find((m)=>{\n                return m.type === track.kind && // if `msid` is not present, we assume that the track is the first one\n                (m.msid?.includes(track.id) ?? true);\n            });\n            if (typeof media?.mid === \"undefined\") {\n                logger$3(\"debug\", `No mid found in SDP for track type ${track.kind} and id ${track.id}. Attempting to find a heuristic mid`);\n                const heuristicMid = this.transceiverInitOrder.indexOf(trackType);\n                if (heuristicMid !== -1) {\n                    return String(heuristicMid);\n                }\n                logger$3(\"debug\", \"No heuristic mid found. Returning empty mid\");\n                return \"\";\n            }\n            return String(media.mid);\n        };\n        this.getCurrentTrackInfos = (sdp)=>{\n            sdp = sdp || this.pc.localDescription?.sdp;\n            const { settings } = this.state;\n            const targetResolution = settings?.video.target_resolution;\n            return this.pc.getTransceivers().filter((t)=>t.direction === \"sendonly\" && t.sender.track).map((transceiver)=>{\n                const trackType = Number(Object.keys(this.transceiverRegistry).find((key)=>this.transceiverRegistry[key] === transceiver));\n                const track = transceiver.sender.track;\n                let optimalLayers;\n                if (track.readyState === \"live\") {\n                    const publishOpts = this.publishOptionsPerTrackType.get(trackType);\n                    optimalLayers = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, publishOpts?.screenShareSettings) : [];\n                    this.trackLayersCache[trackType] = optimalLayers;\n                } else {\n                    // we report the last known optimal layers for ended tracks\n                    optimalLayers = this.trackLayersCache[trackType] || [];\n                    logger$3(\"debug\", `Track ${TrackType[trackType]} is ended. Announcing last known optimal layers`, optimalLayers);\n                }\n                const layers = optimalLayers.map((optimalLayer)=>({\n                        rid: optimalLayer.rid || \"\",\n                        bitrate: optimalLayer.maxBitrate || 0,\n                        fps: optimalLayer.maxFramerate || 0,\n                        quality: this.ridToVideoQuality(optimalLayer.rid || \"\"),\n                        videoDimension: {\n                            width: optimalLayer.width,\n                            height: optimalLayer.height\n                        }\n                    }));\n                const isAudioTrack = [\n                    TrackType.AUDIO,\n                    TrackType.SCREEN_SHARE_AUDIO\n                ].includes(trackType);\n                const trackSettings = track.getSettings();\n                const isStereo = isAudioTrack && trackSettings.channelCount === 2;\n                return {\n                    trackId: track.id,\n                    layers: layers,\n                    trackType,\n                    mid: transceiver.mid ?? this.extractMid(sdp, track, trackType),\n                    stereo: isStereo,\n                    dtx: isAudioTrack && this.isDtxEnabled,\n                    red: isAudioTrack && this.isRedEnabled\n                };\n            });\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$3(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$3(\"debug\", `ICE Connection state changed to`, state);\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$3(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$3(\"error\", `ICE restart error`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$3(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$3(\"error\", `ICE restart error`, e);\n                        });\n                    } else {\n                        logger$3(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, this.iceRestartDelay);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$3(\"debug\", `ICE Gathering State`, this.pc.iceGatheringState);\n        };\n        this.onSignalingStateChange = ()=>{\n            logger$3(\"debug\", `Signaling state changed`, this.pc.signalingState);\n        };\n        this.ridToVideoQuality = (rid)=>{\n            return rid === \"q\" ? VideoQuality.LOW_UNSPECIFIED : rid === \"h\" ? VideoQuality.MID : VideoQuality.HIGH; // default to HIGH\n        };\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.isDtxEnabled = isDtxEnabled;\n        this.isRedEnabled = isRedEnabled;\n        this.iceRestartDelay = iceRestartDelay;\n        this.unsubscribeOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED) return;\n            await this.restartIce();\n        });\n    }\n}\nconst logger$2 = getLogger([\n    \"Subscriber\"\n]);\n/**\n * A wrapper around the `RTCPeerConnection` that handles the incoming\n * media streams from the SFU.\n */ class Subscriber {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Subscriber` instance.\n     *\n     * @param sfuClient the SFU client to use.\n     * @param dispatcher the dispatcher to use.\n     * @param state the state of the call.\n     * @param connectionConfig the connection configuration to use.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE when connection goes to `disconnected` state.\n     */ constructor({ sfuClient, dispatcher, state, connectionConfig, iceRestartDelay = 2500 }){\n        this.isIceRestarting = false;\n        /**\n         * Creates a new `RTCPeerConnection` instance with the given configuration.\n         *\n         * @param connectionConfig the connection configuration to use.\n         */ this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"track\", this.handleOnTrack);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            return pc;\n        };\n        /**\n         * Closes the `RTCPeerConnection` and unsubscribes from the dispatcher.\n         */ this.close = ()=>{\n            clearTimeout(this.iceRestartTimeout);\n            this.unregisterOnSubscriberOffer();\n            this.unregisterOnIceRestart();\n            this.pc.close();\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Migrates the subscriber to a new SFU client.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = (sfuClient, connectionConfig)=>{\n            this.setSfuClient(sfuClient);\n            // when migrating, we want to keep the previous subscriber open\n            // until the new one is connected\n            const previousPC = this.pc;\n            // we keep a record of previously available video tracks\n            // so that we can monitor when they become available on the new\n            // subscriber and close the previous one.\n            const trackIdsToMigrate = new Set();\n            previousPC.getReceivers().forEach((r)=>{\n                if (r.track.kind === \"video\") {\n                    trackIdsToMigrate.add(r.track.id);\n                }\n            });\n            // set up a new subscriber peer connection, configured to connect\n            // to the new SFU node\n            const pc = this.createPeerConnection(connectionConfig);\n            let migrationTimeoutId;\n            const cleanupMigration = ()=>{\n                previousPC.close();\n                clearTimeout(migrationTimeoutId);\n            };\n            // When migrating, we want to keep track of the video tracks\n            // that are migrating to the new subscriber.\n            // Once all of them are available, we can close the previous subscriber.\n            const handleTrackMigration = (e)=>{\n                logger$2(\"debug\", `[Migration]: Migrated track: ${e.track.id}, ${e.track.kind}`);\n                trackIdsToMigrate.delete(e.track.id);\n                if (trackIdsToMigrate.size === 0) {\n                    logger$2(\"debug\", `[Migration]: Migration complete`);\n                    pc.removeEventListener(\"track\", handleTrackMigration);\n                    cleanupMigration();\n                }\n            };\n            // When migrating, we want to keep track of the connection state\n            // of the new subscriber.\n            // Once it is connected, we give it a 2-second grace period to receive\n            // all the video tracks that are migrating from the previous subscriber.\n            // After this threshold, we abruptly close the previous subscriber.\n            const handleConnectionStateChange = ()=>{\n                if (pc.connectionState === \"connected\") {\n                    migrationTimeoutId = setTimeout(()=>{\n                        pc.removeEventListener(\"track\", handleTrackMigration);\n                        cleanupMigration();\n                    }, 2000);\n                    pc.removeEventListener(\"connectionstatechange\", handleConnectionStateChange);\n                }\n            };\n            pc.addEventListener(\"track\", handleTrackMigration);\n            pc.addEventListener(\"connectionstatechange\", handleConnectionStateChange);\n            // replace the PeerConnection instance\n            this.pc = pc;\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$2(\"debug\", \"Restarting ICE connection\");\n            if (this.pc.signalingState === \"have-remote-offer\") {\n                logger$2(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            const previousIsIceRestarting = this.isIceRestarting;\n            try {\n                this.isIceRestarting = true;\n                await this.sfuClient.iceRestart({\n                    peerType: PeerType.SUBSCRIBER\n                });\n            } catch (e) {\n                // restore the previous state, as our intent for restarting ICE failed\n                this.isIceRestarting = previousIsIceRestarting;\n                throw e;\n            }\n        };\n        this.handleOnTrack = (e)=>{\n            const [primaryStream] = e.streams;\n            // example: `e3f6aaf8-b03d-4911-be36-83f47d37a76a:TRACK_TYPE_VIDEO`\n            const [trackId, trackType] = primaryStream.id.split(\":\");\n            const participantToUpdate = this.state.participants.find((p)=>p.trackLookupPrefix === trackId);\n            logger$2(\"debug\", `[onTrack]: Got remote ${trackType} track for userId: ${participantToUpdate?.userId}`, e.track.id, e.track);\n            if (!participantToUpdate) {\n                logger$2(\"error\", `[onTrack]: Received track for unknown participant: ${trackId}`, e);\n                return;\n            }\n            e.track.addEventListener(\"mute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track muted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"unmute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track unmuted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"ended\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track ended: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            const streamKindProp = {\n                TRACK_TYPE_AUDIO: \"audioStream\",\n                TRACK_TYPE_VIDEO: \"videoStream\",\n                TRACK_TYPE_SCREEN_SHARE: \"screenShareStream\",\n                TRACK_TYPE_SCREEN_SHARE_AUDIO: \"screenShareAudioStream\"\n            }[trackType];\n            if (!streamKindProp) {\n                logger$2(\"error\", `Unknown track type: ${trackType}`);\n                return;\n            }\n            const previousStream = participantToUpdate[streamKindProp];\n            if (previousStream) {\n                logger$2(\"info\", `[onTrack]: Cleaning up previous remote ${e.track.kind} tracks for userId: ${participantToUpdate.userId}`);\n                previousStream.getTracks().forEach((t)=>{\n                    t.stop();\n                    previousStream.removeTrack(t);\n                });\n            }\n            this.state.updateParticipant(participantToUpdate.sessionId, {\n                [streamKindProp]: primaryStream\n            });\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$2(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.SUBSCRIBER\n            });\n        };\n        this.negotiate = async (subscriberOffer)=>{\n            logger$2(\"info\", `Received subscriberOffer`, subscriberOffer);\n            await this.pc.setRemoteDescription({\n                type: \"offer\",\n                sdp: subscriberOffer.sdp\n            });\n            this.sfuClient.iceTrickleBuffer.subscriberCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$2(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n            const answer = await this.pc.createAnswer();\n            await this.pc.setLocalDescription(answer);\n            await this.sfuClient.sendAnswer({\n                peerType: PeerType.SUBSCRIBER,\n                sdp: answer.sdp || \"\"\n            });\n            this.isIceRestarting = false;\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$2(\"debug\", `ICE connection state changed`, state);\n            // do nothing when ICE is restarting\n            if (this.isIceRestarting) return;\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$2(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$2(\"error\", `ICE restart failed`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$2(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$2(\"error\", `ICE restart failed`, e);\n                        });\n                    } else {\n                        logger$2(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, 5000);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$2(\"debug\", `ICE gathering state changed`, this.pc.iceGatheringState);\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$2(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.iceRestartDelay = iceRestartDelay;\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.unregisterOnSubscriberOffer = dispatcher.on(\"subscriberOffer\", async (subscriberOffer)=>{\n            await this.negotiate(subscriberOffer);\n        });\n        this.unregisterOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.SUBSCRIBER) return;\n            await this.restartIce();\n        });\n    }\n}\nconst createWebSocketSignalChannel = (opts)=>{\n    const logger = getLogger([\n        \"sfu-client\"\n    ]);\n    const { endpoint, onMessage } = opts;\n    const ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(endpoint);\n    ws.binaryType = \"arraybuffer\"; // do we need this?\n    ws.addEventListener(\"error\", (e)=>{\n        logger(\"error\", \"Signaling WS channel error\", e);\n    });\n    ws.addEventListener(\"close\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is closed\", e);\n    });\n    ws.addEventListener(\"open\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is open\", e);\n    });\n    ws.addEventListener(\"message\", (e)=>{\n        try {\n            const message = e.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e.data)) : SfuEvent.fromJsonString(e.data.toString());\n            onMessage(message);\n        } catch (err) {\n            logger(\"error\", \"Failed to decode a message. Check whether the Proto models match.\", {\n                event: e,\n                error: err\n            });\n        }\n    });\n    return ws;\n};\nconst sleep = (m)=>new Promise((r)=>setTimeout(r, m));\nfunction isFunction(value) {\n    return value && (Object.prototype.toString.call(value) === \"[object Function]\" || \"function\" === typeof value || value instanceof Function);\n}\n/**\n * A map of known error codes.\n */ const KnownCodes = {\n    TOKEN_EXPIRED: 40,\n    WS_CLOSED_SUCCESS: 1000,\n    WS_CLOSED_ABRUPTLY: 1006,\n    WS_POLICY_VIOLATION: 1008\n};\n/**\n * retryInterval - A retry interval which increases acc to number of failures\n *\n * @return {number} Duration to wait in milliseconds\n */ function retryInterval(numberOfFailures) {\n    // try to reconnect in 0.25-5 seconds (random to spread out the load from failures)\n    const max = Math.min(500 + numberOfFailures * 2000, 5000);\n    const min = Math.min(Math.max(250, (numberOfFailures - 1) * 2000), 5000);\n    return Math.floor(Math.random() * (max - min) + min);\n}\nfunction randomId() {\n    return generateUUIDv4();\n}\nfunction hex(bytes) {\n    let s = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        s += bytes[i].toString(16).padStart(2, \"0\");\n    }\n    return s;\n}\n// https://tools.ietf.org/html/rfc4122\nfunction generateUUIDv4() {\n    const bytes = getRandomBytes(16);\n    bytes[6] = bytes[6] & 0x0f | 0x40; // version\n    bytes[8] = bytes[8] & 0xbf | 0x80; // variant\n    return hex(bytes.subarray(0, 4)) + \"-\" + hex(bytes.subarray(4, 6)) + \"-\" + hex(bytes.subarray(6, 8)) + \"-\" + hex(bytes.subarray(8, 10)) + \"-\" + hex(bytes.subarray(10, 16));\n}\nfunction getRandomValuesWithMathRandom(bytes) {\n    const max = Math.pow(2, 8 * bytes.byteLength / bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Math.random() * max;\n    }\n}\nconst getRandomValues = (()=>{\n    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues !== \"undefined\") {\n        return crypto.getRandomValues.bind(crypto);\n    } else if (typeof msCrypto !== \"undefined\") {\n        return msCrypto.getRandomValues.bind(msCrypto);\n    } else {\n        return getRandomValuesWithMathRandom;\n    }\n})();\nfunction getRandomBytes(length) {\n    const bytes = new Uint8Array(length);\n    getRandomValues(bytes);\n    return bytes;\n}\nfunction convertErrorToJson(err) {\n    const jsonObj = {};\n    if (!err) return jsonObj;\n    try {\n        Object.getOwnPropertyNames(err).forEach((key)=>{\n            jsonObj[key] = Object.getOwnPropertyDescriptor(err, key);\n        });\n    } catch (_) {\n        return {\n            error: \"failed to serialize the error\"\n        };\n    }\n    return jsonObj;\n}\n/**\n * isOnline safely return the navigator.online value for browser env\n * if navigator is not in global object, it always return true\n */ function isOnline(logger) {\n    const nav = typeof navigator !== \"undefined\" ? navigator :  false ? 0 : undefined;\n    if (!nav) {\n        logger(\"warn\", \"isOnline failed to access window.navigator and assume browser is online\");\n        return true;\n    }\n    // RN navigator has undefined for onLine\n    if (typeof nav.onLine !== \"boolean\") {\n        return true;\n    }\n    return nav.onLine;\n}\n/**\n * listenForConnectionChanges - Adds an event listener fired on browser going online or offline\n */ function addConnectionEventListeners(cb) {\n    if (false) {}\n}\nfunction removeConnectionEventListeners(cb) {\n    if (false) {}\n}\n/**\n * The client used for exchanging information with the SFU.\n */ class StreamSfuClient {\n    /**\n     * Constructs a new SFU client.\n     *\n     * @param dispatcher the event dispatcher to use.\n     * @param sfuServer the SFU server to connect to.\n     * @param token the JWT token to use for authentication.\n     * @param sessionId the `sessionId` of the currently connected participant.\n     */ constructor({ dispatcher, sfuServer, token, sessionId }){\n        /**\n         * A buffer for ICE Candidates that are received before\n         * the PeerConnections are ready to handle them.\n         */ this.iceTrickleBuffer = new IceTrickleBuffer();\n        /**\n         * A flag indicating whether the client is currently migrating away\n         * from this SFU.\n         */ this.isMigratingAway = false;\n        /**\n         * A flag indicating that the client connection is broken for the current\n         * client and that a fast-reconnect with a new client should be attempted.\n         */ this.isFastReconnecting = false;\n        this.pingIntervalInMs = 10 * 1000;\n        this.unhealthyTimeoutInMs = this.pingIntervalInMs + 5 * 1000;\n        this.close = (code, reason)=>{\n            this.logger(\"debug\", `Closing SFU WS connection: ${code} - ${reason}`);\n            if (this.signalWs.readyState !== this.signalWs.CLOSED) {\n                this.signalWs.close(code, `js-client: ${reason}`);\n            }\n            this.unsubscribeIceTrickle();\n            clearInterval(this.keepAliveInterval);\n            clearTimeout(this.connectionCheckTimeout);\n        };\n        this.updateSubscriptions = async (subscriptions)=>{\n            return retryable(()=>this.rpc.updateSubscriptions({\n                    sessionId: this.sessionId,\n                    tracks: subscriptions\n                }), this.logger);\n        };\n        this.setPublisher = async (data)=>{\n            return retryable(()=>this.rpc.setPublisher({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendAnswer = async (data)=>{\n            return retryable(()=>this.rpc.sendAnswer({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceTrickle = async (data)=>{\n            return retryable(()=>this.rpc.iceTrickle({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceRestart = async (data)=>{\n            return retryable(()=>this.rpc.iceRestart({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.updateMuteState = async (trackType, muted)=>{\n            return this.updateMuteStates({\n                muteStates: [\n                    {\n                        trackType,\n                        muted\n                    }\n                ]\n            });\n        };\n        this.updateMuteStates = async (data)=>{\n            return retryable(()=>this.rpc.updateMuteStates({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendStats = async (stats)=>{\n            return retryable(()=>this.rpc.sendStats({\n                    ...stats,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.join = async (data)=>{\n            const joinRequest = JoinRequest.create({\n                ...data,\n                sessionId: this.sessionId,\n                token: this.token\n            });\n            return this.send(SfuRequest.create({\n                requestPayload: {\n                    oneofKind: \"joinRequest\",\n                    joinRequest\n                }\n            }));\n        };\n        this.send = async (message)=>{\n            return this.signalReady.then((signal)=>{\n                if (signal.readyState !== signal.OPEN) return;\n                this.logger(\"debug\", `Sending message to: ${this.edgeName}`, SfuRequest.toJson(message));\n                signal.send(SfuRequest.toBinary(message));\n            });\n        };\n        this.keepAlive = ()=>{\n            clearInterval(this.keepAliveInterval);\n            this.keepAliveInterval = setInterval(()=>{\n                this.logger(\"trace\", \"Sending healthCheckRequest to SFU\");\n                const message = SfuRequest.create({\n                    requestPayload: {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: {}\n                    }\n                });\n                this.send(message).catch((e)=>{\n                    this.logger(\"error\", \"Error sending healthCheckRequest to SFU\", e);\n                });\n            }, this.pingIntervalInMs);\n        };\n        this.scheduleConnectionCheck = ()=>{\n            clearTimeout(this.connectionCheckTimeout);\n            this.connectionCheckTimeout = setTimeout(()=>{\n                if (this.lastMessageTimestamp) {\n                    const timeSinceLastMessage = new Date().getTime() - this.lastMessageTimestamp.getTime();\n                    if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {\n                        this.close(StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);\n                    }\n                }\n            }, this.unhealthyTimeoutInMs);\n        };\n        this.sessionId = sessionId || generateUUIDv4();\n        this.sfuServer = sfuServer;\n        this.edgeName = sfuServer.edge_name;\n        this.token = token;\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        const logInterceptor = {\n            interceptUnary: (next, method, input, options)=>{\n                this.logger(\"trace\", `Calling SFU RPC method ${method.name}`, {\n                    input,\n                    options\n                });\n                return next(method, input, options);\n            }\n        };\n        this.rpc = createSignalClient({\n            baseUrl: sfuServer.url,\n            interceptors: [\n                withHeaders({\n                    Authorization: `Bearer ${token}`\n                }),\n                logInterceptor\n            ]\n        });\n        // Special handling for the ICETrickle kind of events.\n        // These events might be triggered by the SFU before the initial RTC\n        // connection is established. In that case, those events (ICE candidates)\n        // need to be buffered and later added to the appropriate PeerConnection\n        // once the remoteDescription is known and set.\n        this.unsubscribeIceTrickle = dispatcher.on(\"iceTrickle\", (iceTrickle)=>{\n            this.iceTrickleBuffer.push(iceTrickle);\n        });\n        this.signalWs = createWebSocketSignalChannel({\n            endpoint: sfuServer.ws_endpoint,\n            onMessage: (message)=>{\n                this.lastMessageTimestamp = new Date();\n                this.scheduleConnectionCheck();\n                dispatcher.dispatch(message);\n            }\n        });\n        this.signalReady = new Promise((resolve)=>{\n            const onOpen = ()=>{\n                this.signalWs.removeEventListener(\"open\", onOpen);\n                this.keepAlive();\n                resolve(this.signalWs);\n            };\n            this.signalWs.addEventListener(\"open\", onOpen);\n        });\n    }\n}\n/**\n * The normal closure code. Used for controlled shutdowns.\n */ StreamSfuClient.NORMAL_CLOSURE = 1000;\n/**\n * The error code used when the SFU connection is unhealthy.\n * Usually, this means that no message has been received from the SFU for\n * a certain amount of time (`connectionCheckTimeout`).\n */ StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;\n/**\n * The error code used when the SFU connection is broken.\n * Usually, this means that the WS connection has been closed unexpectedly.\n * This error code is used to announce a fast-reconnect.\n */ StreamSfuClient.ERROR_CONNECTION_BROKEN = 4002; // used in fast-reconnects\nconst MAX_RETRIES = 5;\n/**\n * Creates a closure which wraps the given RPC call and retries invoking\n * the RPC until it succeeds or the maximum number of retries is reached.\n *\n * Between each retry, there would be a random delay in order to avoid\n * request bursts towards the SFU.\n *\n * @param rpc the closure around the RPC call to execute.\n * @param logger a logger instance to use.\n * @param <I> the type of the request object.\n * @param <O> the type of the response object.\n */ const retryable = async (rpc, logger)=>{\n    let retryAttempt = 0;\n    let rpcCallResult;\n    do {\n        // don't delay the first invocation\n        if (retryAttempt > 0) {\n            await sleep(retryInterval(retryAttempt));\n        }\n        rpcCallResult = await rpc();\n        logger(\"trace\", `SFU RPC response received for ${rpcCallResult.method.name}`, rpcCallResult);\n        // if the RPC call failed, log the error and retry\n        if (rpcCallResult.response.error) {\n            logger(\"error\", `SFU RPC Error (${rpcCallResult.method.name}):`, rpcCallResult.response.error);\n        }\n        retryAttempt++;\n    }while (rpcCallResult.response.error?.shouldRetry && retryAttempt < MAX_RETRIES);\n    if (rpcCallResult.response.error) {\n        throw rpcCallResult.response.error;\n    }\n    return rpcCallResult;\n};\n/**\n * Event handler that watched the delivery of `call.accepted`.\n * Once the event is received, the call is joined.\n */ const watchCallAccepted = (call)=>{\n    return async function onCallAccepted(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { state } = call;\n        if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {\n            await call.join();\n        }\n    };\n};\n/**\n * Event handler that watches delivery of `call.rejected` Websocket event.\n * Once the event is received, the call is left.\n */ const watchCallRejected = (call)=>{\n    return async function onCallRejected(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { call: eventCall } = event;\n        const { session: callSession } = eventCall;\n        if (!callSession) {\n            call.logger(\"warn\", \"No call session provided. Ignoring call.rejected event.\", event);\n            return;\n        }\n        const rejectedBy = callSession.rejected_by;\n        const { members, callingState } = call.state;\n        if (callingState !== CallingState.RINGING) {\n            call.logger(\"info\", \"Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.\", event);\n            return;\n        }\n        if (call.isCreatedByMe) {\n            const everyoneElseRejected = members.filter((m)=>m.user_id !== call.currentUserId).every((m)=>rejectedBy[m.user_id]);\n            if (everyoneElseRejected) {\n                call.logger(\"info\", \"everyone rejected, leaving the call\");\n                await call.leave({\n                    reason: \"ring: everyone rejected\"\n                });\n            }\n        } else {\n            if (rejectedBy[eventCall.created_by.id]) {\n                call.logger(\"info\", \"call creator rejected, leaving call\");\n                await call.leave({\n                    reason: \"ring: creator rejected\"\n                });\n            }\n        }\n    };\n};\n/**\n * Event handler that watches the delivery of `call.ended` Websocket event.\n */ const watchCallEnded = (call)=>{\n    return async function onCallEnded() {\n        const { callingState } = call.state;\n        if (callingState === CallingState.RINGING || callingState === CallingState.JOINED || callingState === CallingState.JOINING) {\n            await call.leave({\n                reason: \"call.ended event received\"\n            });\n        }\n    };\n};\n/**\n * Event handler that watches for `callGrantsUpdated` events.\n *\n * @param state the call state to update.\n */ const watchCallGrantsUpdated = (state)=>{\n    return function onCallGrantsUpdated(event) {\n        const { currentGrants } = event;\n        if (currentGrants) {\n            const { canPublishAudio, canPublishVideo, canScreenshare } = currentGrants;\n            const update = {\n                [OwnCapability.SEND_AUDIO]: canPublishAudio,\n                [OwnCapability.SEND_VIDEO]: canPublishVideo,\n                [OwnCapability.SCREENSHARE]: canScreenshare\n            };\n            const nextCapabilities = state.ownCapabilities.filter((capability)=>update[capability] !== false);\n            Object.entries(update).forEach(([capability, value])=>{\n                if (value && !nextCapabilities.includes(capability)) {\n                    nextCapabilities.push(capability);\n                }\n            });\n            state.setOwnCapabilities(nextCapabilities);\n        }\n    };\n};\nconst logger$1 = getLogger([\n    \"events\"\n]);\n/**\n * An event responder which handles the `changePublishQuality` event.\n */ const watchChangePublishQuality = (dispatcher, call)=>{\n    return dispatcher.on(\"changePublishQuality\", (e)=>{\n        const { videoSenders } = e;\n        videoSenders.forEach((videoSender)=>{\n            const { layers } = videoSender;\n            call.updatePublishQuality(layers.filter((l)=>l.active));\n        });\n    });\n};\nconst watchConnectionQualityChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"connectionQualityChanged\", (e)=>{\n        const { connectionQualityUpdates } = e;\n        if (!connectionQualityUpdates) return;\n        state.updateParticipants(connectionQualityUpdates.reduce((patches, update)=>{\n            const { sessionId, connectionQuality } = update;\n            patches[sessionId] = {\n                connectionQuality\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Updates the approximate number of participants in the call by peeking at the\n * health check events that our SFU sends.\n */ const watchParticipantCountChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"healthCheckResponse\", (e)=>{\n        const { participantCount } = e;\n        if (participantCount) {\n            state.setParticipantCount(participantCount.total);\n            state.setAnonymousParticipantCount(participantCount.anonymous);\n        }\n    });\n};\nconst watchLiveEnded = (dispatcher, call)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (e.error && e.error.code !== ErrorCode.LIVE_ENDED) return;\n        if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {\n            call.leave({\n                reason: \"live ended\"\n            }).catch((err)=>{\n                logger$1(\"error\", \"Failed to leave call after live ended\", err);\n            });\n        }\n    });\n};\n/**\n * Watches and logs the errors reported by the currently connected SFU.\n */ const watchSfuErrorReports = (dispatcher)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (!e.error) return;\n        const { error } = e;\n        logger$1(\"error\", \"SFU reported error\", {\n            code: ErrorCode[error.code],\n            message: error.message,\n            shouldRetry: error.shouldRetry\n        });\n    });\n};\n/**\n * Watches for `pinsUpdated` events and updates the pinned state of participants\n * in the call.\n */ const watchPinsUpdated = (state)=>{\n    return function onPinsUpdated(e) {\n        const { pins } = e;\n        state.setServerSidePins(pins);\n    };\n};\n/**\n * An event handler that handles soft mutes.\n *\n * @param call the call.\n */ const handleRemoteSoftMute = (call)=>{\n    return call.on(\"trackUnpublished\", async (event)=>{\n        const { cause, type, sessionId } = event;\n        const { localParticipant } = call.state;\n        if (cause === TrackUnpublishReason.MODERATION && sessionId === localParticipant?.sessionId) {\n            const logger = call.logger;\n            logger(\"info\", `Local participant's ${TrackType[type]} track is muted remotely`);\n            try {\n                if (type === TrackType.VIDEO) {\n                    await call.camera.disable();\n                } else if (type === TrackType.AUDIO) {\n                    await call.microphone.disable();\n                } else {\n                    logger(\"warn\", \"Unsupported track type to soft mute\", TrackType[type]);\n                }\n                if (call.publisher?.isPublishing(type)) {\n                    await call.stopPublish(type);\n                }\n            } catch (error) {\n                logger(\"error\", \"Failed to stop publishing\", error);\n            }\n        }\n    });\n};\n/**\n * An event responder which handles the `participantJoined` event.\n */ const watchParticipantJoined = (state)=>{\n    return function onParticipantJoined(e) {\n        const { participant } = e;\n        if (!participant) return;\n        // `state.updateOrAddParticipant` acts as a safeguard against\n        // potential duplicate events from the SFU.\n        //\n        // Although the SFU should not send duplicate events, we have seen\n        // some race conditions in the past during the `join-flow` where\n        // the SFU would send participant info as part of the `join`\n        // response and then follow up with a `participantJoined` event for\n        // already announced participants.\n        state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, {\n            viewportVisibilityState: {\n                videoTrack: VisibilityState.UNKNOWN,\n                screenShareTrack: VisibilityState.UNKNOWN\n            }\n        }));\n    };\n};\n/**\n * An event responder which handles the `participantLeft` event.\n */ const watchParticipantLeft = (state)=>{\n    return function onParticipantLeft(e) {\n        const { participant } = e;\n        if (!participant) return;\n        state.setParticipants((participants)=>participants.filter((p)=>p.sessionId !== participant.sessionId));\n    };\n};\n/**\n * An event responder which handles the `trackPublished` event.\n * The SFU will send this event when a participant publishes a track.\n */ const watchTrackPublished = (state)=>{\n    return function onTrackPublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls.\n        // After a certain threshold, the SFU would stop emitting `participantJoined`\n        // events, and instead, it would only provide the participant's information\n        // once they start publishing a track.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: [\n                        ...p.publishedTracks,\n                        type\n                    ].filter(unique)\n                }));\n        }\n    };\n};\n/**\n * An event responder which handles the `trackUnpublished` event.\n * The SFU will send this event when a participant unpublishes a track.\n */ const watchTrackUnpublished = (state)=>{\n    return function onTrackUnpublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls. See `watchTrackPublished`.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: p.publishedTracks.filter((t)=>t !== type)\n                }));\n        }\n    };\n};\nconst unique = (v, i, arr)=>arr.indexOf(v) === i;\n/**\n * Watches for `dominantSpeakerChanged` events.\n */ const watchDominantSpeakerChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"dominantSpeakerChanged\", (e)=>{\n        const { sessionId } = e;\n        if (sessionId === state.dominantSpeaker?.sessionId) return;\n        state.setParticipants((participants)=>participants.map((participant)=>{\n                // mark the new dominant speaker\n                if (participant.sessionId === sessionId) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: true\n                    };\n                }\n                // unmark the old dominant speaker\n                if (participant.isDominantSpeaker) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: false\n                    };\n                }\n                return participant; // no change\n            }));\n    });\n};\n/**\n * Watches for `audioLevelChanged` events.\n */ const watchAudioLevelChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"audioLevelChanged\", (e)=>{\n        const { audioLevels } = e;\n        state.updateParticipants(audioLevels.reduce((patches, current)=>{\n            patches[current.sessionId] = {\n                audioLevel: current.level,\n                isSpeaking: current.isSpeaking\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Registers the default event handlers for a call during its lifecycle.\n *\n * @param call the call to register event handlers for.\n * @param state the call state.\n * @param dispatcher the dispatcher.\n */ const registerEventHandlers = (call, state, dispatcher)=>{\n    const eventHandlers = [\n        call.on(\"call.ended\", watchCallEnded(call)),\n        watchLiveEnded(dispatcher, call),\n        watchSfuErrorReports(dispatcher),\n        watchChangePublishQuality(dispatcher, call),\n        watchConnectionQualityChanged(dispatcher, state),\n        watchParticipantCountChanged(dispatcher, state),\n        call.on(\"participantJoined\", watchParticipantJoined(state)),\n        call.on(\"participantLeft\", watchParticipantLeft(state)),\n        call.on(\"trackPublished\", watchTrackPublished(state)),\n        call.on(\"trackUnpublished\", watchTrackUnpublished(state)),\n        watchAudioLevelChanged(dispatcher, state),\n        watchDominantSpeakerChanged(dispatcher, state),\n        call.on(\"callGrantsUpdated\", watchCallGrantsUpdated(state)),\n        call.on(\"pinsUpdated\", watchPinsUpdated(state)),\n        handleRemoteSoftMute(call)\n    ];\n    if (call.ringing) {\n        // these events are only relevant when the call is ringing\n        eventHandlers.push(registerRingingCallEventHandlers(call));\n    }\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Registers event handlers for a call that is of ringing type.\n *\n * @param call the call to register event handlers for.\n */ const registerRingingCallEventHandlers = (call)=>{\n    const coordinatorRingEvents = {\n        \"call.accepted\": watchCallAccepted(call),\n        \"call.rejected\": watchCallRejected(call)\n    };\n    const eventHandlers = Object.keys(coordinatorRingEvents).map((event)=>{\n        const eventName = event;\n        return call.on(eventName, coordinatorRingEvents[eventName]);\n    });\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Collects all necessary information to join a call, talks to the coordinator\n * and returns the necessary information to join the call.\n *\n * @param httpClient the http client to use.\n * @param type the type of the call.\n * @param id the id of the call.\n * @param data the data for the call.\n */ const join = async (httpClient, type, id, data)=>{\n    const { call, credentials, members, own_capabilities, stats_options } = await doJoin(httpClient, type, id, data);\n    return {\n        connectionConfig: toRtcConfiguration(credentials.ice_servers),\n        sfuServer: credentials.server,\n        token: credentials.token,\n        metadata: call,\n        members,\n        ownCapabilities: own_capabilities,\n        statsOptions: stats_options\n    };\n};\nconst doJoin = async (httpClient, type, id, data)=>{\n    const location = await httpClient.getLocationHint();\n    const request = {\n        ...data,\n        location\n    };\n    return httpClient.post(`/call/${type}/${id}/join`, request);\n};\nconst toRtcConfiguration = (config)=>{\n    if (!config || config.length === 0) return undefined;\n    const rtcConfig = {\n        iceServers: config.map((ice)=>({\n                urls: ice.urls,\n                username: ice.username,\n                credential: ice.password\n            }))\n    };\n    return rtcConfig;\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten$1 = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\n/**\n * Creates a new StatsReporter instance that collects metrics about the ongoing call and reports them to the state store\n */ const createStatsReporter = ({ subscriber, publisher, state, pollingIntervalInMs = 2000 })=>{\n    const logger = getLogger([\n        \"stats\"\n    ]);\n    const getRawStatsForTrack = async (kind, selector)=>{\n        if (kind === \"subscriber\" && subscriber) {\n            return subscriber.getStats(selector);\n        } else if (kind === \"publisher\" && publisher) {\n            return publisher.getStats(selector);\n        } else {\n            logger(\"warn\", `Can't retrieve RTC stats for ${kind}`);\n            return undefined;\n        }\n    };\n    const getStatsForStream = async (kind, mediaStream)=>{\n        const pc = kind === \"subscriber\" ? subscriber : publisher;\n        const statsForStream = [];\n        for (let track of mediaStream.getTracks()){\n            const report = await pc.getStats(track);\n            const stats = transform(report, {\n                // @ts-ignore\n                trackKind: track.kind,\n                kind\n            });\n            statsForStream.push(stats);\n        }\n        return statsForStream;\n    };\n    const startReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.add(sessionId);\n        void run();\n    };\n    const stopReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.delete(sessionId);\n        void run();\n    };\n    const sessionIdsToTrack = new Set();\n    /**\n     * The main stats reporting loop.\n     */ const run = async ()=>{\n        const participantStats = {};\n        const sessionIds = new Set(sessionIdsToTrack);\n        if (sessionIds.size > 0) {\n            for (let participant of state.participants){\n                if (!sessionIds.has(participant.sessionId)) continue;\n                const kind = participant.isLocalParticipant ? \"publisher\" : \"subscriber\";\n                try {\n                    const mergedStream = new MediaStream([\n                        ...participant.videoStream?.getVideoTracks() || [],\n                        ...participant.audioStream?.getAudioTracks() || []\n                    ]);\n                    participantStats[participant.sessionId] = await getStatsForStream(kind, mergedStream);\n                    mergedStream.getTracks().forEach((t)=>{\n                        mergedStream.removeTrack(t);\n                    });\n                } catch (e) {\n                    logger(\"error\", `Failed to collect stats for ${kind} if ${participant.userId}`, e);\n                }\n            }\n        }\n        const [subscriberStats, publisherStats] = await Promise.all([\n            subscriber.getStats().then((report)=>transform(report, {\n                    kind: \"subscriber\",\n                    trackKind: \"video\"\n                })).then(aggregate),\n            publisher.getStats().then((report)=>transform(report, {\n                    kind: \"publisher\",\n                    trackKind: \"video\"\n                })).then(aggregate)\n        ]);\n        const [subscriberRawStats, publisherRawStats] = await Promise.all([\n            getRawStatsForTrack(\"subscriber\"),\n            getRawStatsForTrack(\"publisher\")\n        ]);\n        state.setCallStatsReport({\n            datacenter: publisher.sfuClient.edgeName,\n            publisherStats,\n            subscriberStats,\n            subscriberRawStats,\n            publisherRawStats,\n            participants: participantStats,\n            timestamp: Date.now()\n        });\n    };\n    let timeoutId;\n    if (pollingIntervalInMs > 0) {\n        const loop = async ()=>{\n            await run().catch((e)=>{\n                logger(\"debug\", \"Failed to collect stats\", e);\n            });\n            timeoutId = setTimeout(loop, pollingIntervalInMs);\n        };\n        void loop();\n    }\n    const stop = ()=>{\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n    };\n    return {\n        getRawStatsForTrack,\n        getStatsForStream,\n        startReportingStatsFor,\n        stopReportingStatsFor,\n        stop\n    };\n};\n/**\n * Transforms raw RTC stats into a slimmer and uniform across browsers format.\n *\n * @param report the report to transform.\n * @param opts the transform options.\n */ const transform = (report, opts)=>{\n    const { trackKind, kind } = opts;\n    const direction = kind === \"subscriber\" ? \"inbound-rtp\" : \"outbound-rtp\";\n    const stats = flatten$1(report);\n    const streams = stats.filter((stat)=>stat.type === direction && stat.kind === trackKind).map((stat)=>{\n        const rtcStreamStats = stat;\n        const codec = stats.find((s)=>s.type === \"codec\" && s.id === rtcStreamStats.codecId); // FIXME OL: incorrect type!\n        const transport = stats.find((s)=>s.type === \"transport\" && s.id === rtcStreamStats.transportId);\n        let roundTripTime;\n        if (transport && transport.dtlsState === \"connected\") {\n            const candidatePair = stats.find((s)=>s.type === \"candidate-pair\" && s.id === transport.selectedCandidatePairId);\n            roundTripTime = candidatePair?.currentRoundTripTime;\n        }\n        return {\n            bytesSent: rtcStreamStats.bytesSent,\n            bytesReceived: rtcStreamStats.bytesReceived,\n            codec: codec?.mimeType,\n            currentRoundTripTime: roundTripTime,\n            frameHeight: rtcStreamStats.frameHeight,\n            frameWidth: rtcStreamStats.frameWidth,\n            framesPerSecond: rtcStreamStats.framesPerSecond,\n            jitter: rtcStreamStats.jitter,\n            kind: rtcStreamStats.kind,\n            // @ts-ignore: available in Chrome only, TS doesn't recognize this\n            qualityLimitationReason: rtcStreamStats.qualityLimitationReason,\n            rid: rtcStreamStats.rid,\n            ssrc: rtcStreamStats.ssrc\n        };\n    });\n    return {\n        rawStats: report,\n        streams,\n        timestamp: Date.now()\n    };\n};\n/**\n * Aggregates generic stats.\n *\n * @param stats the stats to aggregate.\n */ const aggregate = (stats)=>{\n    const aggregatedStats = {\n        rawReport: stats,\n        totalBytesSent: 0,\n        totalBytesReceived: 0,\n        averageJitterInMs: 0,\n        averageRoundTripTimeInMs: 0,\n        qualityLimitationReasons: \"none\",\n        highestFrameWidth: 0,\n        highestFrameHeight: 0,\n        highestFramesPerSecond: 0,\n        timestamp: Date.now()\n    };\n    let maxArea = -1;\n    const area = (w, h)=>w * h;\n    const qualityLimitationReasons = new Set();\n    const streams = stats.streams;\n    const report = streams.reduce((acc, stream)=>{\n        acc.totalBytesSent += stream.bytesSent || 0;\n        acc.totalBytesReceived += stream.bytesReceived || 0;\n        acc.averageJitterInMs += stream.jitter || 0;\n        acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;\n        // naive calculation of the highest resolution\n        const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);\n        if (streamArea > maxArea) {\n            acc.highestFrameWidth = stream.frameWidth || 0;\n            acc.highestFrameHeight = stream.frameHeight || 0;\n            acc.highestFramesPerSecond = stream.framesPerSecond || 0;\n            maxArea = streamArea;\n        }\n        qualityLimitationReasons.add(stream.qualityLimitationReason || \"\");\n        return acc;\n    }, aggregatedStats);\n    if (streams.length > 0) {\n        report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1000);\n        report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1000);\n    }\n    const qualityLimitationReason = [\n        qualityLimitationReasons.has(\"cpu\") && \"cpu\",\n        qualityLimitationReasons.has(\"bandwidth\") && \"bandwidth\",\n        qualityLimitationReasons.has(\"other\") && \"other\"\n    ].filter(Boolean).join(\", \");\n    if (qualityLimitationReason) {\n        report.qualityLimitationReasons = qualityLimitationReason;\n    }\n    return report;\n};\nclass SfuStatsReporter {\n    constructor(sfuClient, { options, clientDetails, subscriber, publisher }){\n        this.logger = getLogger([\n            \"SfuStatsReporter\"\n        ]);\n        this.run = async ()=>{\n            const [subscriberStats, publisherStats] = await Promise.all([\n                this.subscriber.getStats().then(flatten$1).then(JSON.stringify),\n                this.publisher.getStats().then(flatten$1).then(JSON.stringify)\n            ]);\n            await this.sfuClient.sendStats({\n                sdk: this.sdkName,\n                sdkVersion: this.sdkVersion,\n                webrtcVersion: this.webRTCVersion,\n                subscriberStats,\n                publisherStats\n            });\n        };\n        this.start = ()=>{\n            if (this.options.reporting_interval_ms <= 0) return;\n            this.intervalId = setInterval(()=>{\n                this.run().catch((err)=>{\n                    this.logger(\"warn\", \"Failed to report stats\", err);\n                });\n            }, this.options.reporting_interval_ms);\n        };\n        this.stop = ()=>{\n            clearInterval(this.intervalId);\n            this.intervalId = undefined;\n        };\n        this.sfuClient = sfuClient;\n        this.options = options;\n        this.subscriber = subscriber;\n        this.publisher = publisher;\n        const webRTCInfo = getWebRTCInfo();\n        const { sdk, browser } = clientDetails;\n        this.sdkName = sdk && sdk.type === SdkType.REACT ? \"stream-react\" : sdk && sdk.type === SdkType.REACT_NATIVE ? \"stream-react-native\" : \"stream-js\";\n        this.sdkVersion = sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : \"0.0.0-development\";\n        // The WebRTC version if passed from the SDK, it is taken else the browser info is sent.\n        this.webRTCVersion = webRTCInfo?.version || `${browser?.name || \"\"}-${browser?.version || \"\"}` || \"N/A\";\n    }\n}\nconst DEFAULT_THRESHOLD = 0.35;\nclass ViewportTracker {\n    constructor(){\n        /**\n         * @private\n         */ this.elementHandlerMap = new Map();\n        /**\n         * @private\n         */ this.observer = null;\n        // in React children render before viewport is set, add\n        // them to the queue and observe them once the observer is ready\n        /**\n         * @private\n         */ this.queueSet = new Set();\n        /**\n         * Method to set scrollable viewport as root for the IntersectionObserver, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param viewportElement\n         * @param options\n         * @returns Unobserve\n         */ this.setViewport = (viewportElement, options)=>{\n            const cleanup = ()=>{\n                this.observer?.disconnect();\n                this.observer = null;\n                this.elementHandlerMap.clear();\n            };\n            this.observer = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    const handler = this.elementHandlerMap.get(entry.target);\n                    handler?.(entry);\n                });\n            }, {\n                root: viewportElement,\n                ...options,\n                threshold: options?.threshold ?? DEFAULT_THRESHOLD\n            });\n            if (this.queueSet.size) {\n                this.queueSet.forEach(([queueElement, queueHandler])=>{\n                    // check if element which requested observation is\n                    // a child of a viewport element, skip if isn't\n                    if (!viewportElement.contains(queueElement)) return;\n                    this.observer.observe(queueElement);\n                    this.elementHandlerMap.set(queueElement, queueHandler);\n                });\n                this.queueSet.clear();\n            }\n            return cleanup;\n        };\n        /**\n         * Method to set element to observe and handler to be triggered whenever IntersectionObserver\n         * detects a possible change in element's visibility within specified viewport, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param element\n         * @param handler\n         * @returns Unobserve\n         */ this.observe = (element, handler)=>{\n            const queueItem = [\n                element,\n                handler\n            ];\n            const cleanup = ()=>{\n                this.elementHandlerMap.delete(element);\n                this.observer?.unobserve(element);\n                this.queueSet.delete(queueItem);\n            };\n            if (this.elementHandlerMap.has(element)) return cleanup;\n            if (!this.observer) {\n                this.queueSet.add(queueItem);\n                return cleanup;\n            }\n            if (this.observer.root.contains(element)) {\n                this.elementHandlerMap.set(element, handler);\n                this.observer.observe(element);\n            }\n            return cleanup;\n        };\n    }\n}\n/**\n * Checks whether the current browser is Safari.\n */ const isSafari = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || \"\");\n};\n/**\n * Checks whether the current browser is Firefox.\n */ const isFirefox = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Firefox\");\n};\n/**\n * Checks whether the current browser is Google Chrome.\n */ const isChrome = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Chrome\");\n};\nvar browsers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    isChrome: isChrome,\n    isFirefox: isFirefox,\n    isSafari: isSafari\n});\nconst DEFAULT_VIEWPORT_VISIBILITY_STATE = {\n    videoTrack: VisibilityState.UNKNOWN,\n    screenShareTrack: VisibilityState.UNKNOWN\n};\n/**\n * A manager class that handles dynascale related tasks like:\n *\n * - binding video elements to session ids\n * - binding audio elements to session ids\n * - tracking element visibility\n * - updating subscriptions based on viewport visibility\n * - updating subscriptions based on video element dimensions\n * - updating subscriptions based on published tracks\n */ class DynascaleManager {\n    /**\n     * Creates a new DynascaleManager instance.\n     *\n     * @param call the call to manage.\n     */ constructor(call){\n        /**\n         * The viewport tracker instance.\n         */ this.viewportTracker = new ViewportTracker();\n        this.logger = getLogger([\n            \"DynascaleManager\"\n        ]);\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         * @returns Untrack.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            const cleanup = this.viewportTracker.observe(element, (entry)=>{\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    // observer triggers when the element is \"moved\" to be a fullscreen element\n                    // keep it VISIBLE if that happens to prevent fullscreen with placeholder\n                    const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: isVisible\n                        }\n                    };\n                });\n            });\n            return ()=>{\n                cleanup();\n                // reset visibility state to UNKNOWN upon cleanup\n                // so that the layouts that are not actively observed\n                // can still function normally (runtime layout switching)\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: VisibilityState.UNKNOWN\n                        }\n                    };\n                });\n            };\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.viewportTracker.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const boundParticipant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!boundParticipant) return;\n            const requestTrackWithDimensions = (debounceType, dimension)=>{\n                if (dimension && (dimension.width === 0 || dimension.height === 0)) {\n                    // ignore 0x0 dimensions. this can happen when the video element\n                    // is not visible (e.g., has display: none).\n                    // we treat this as \"unsubscription\" as we don't want to keep\n                    // consuming bandwidth for a video that is not visible on the screen.\n                    this.logger(\"debug\", `Ignoring 0x0 dimension`, boundParticipant);\n                    dimension = undefined;\n                }\n                this.call.updateSubscriptionsPartial(trackType, {\n                    [sessionId]: {\n                        dimension\n                    }\n                }, debounceType);\n            };\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((participant)=>participant.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((participant)=>!!participant), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            /**\n             * Since the video elements are now being removed from the DOM (React SDK) upon\n             * visibility change, this subscription is not in use an stays here only for the\n             * plain JS integrations where integrators might choose not to remove the video\n             * elements from the DOM.\n             */ // keep copy for resize observer handler\n            let viewportVisibilityState;\n            const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.viewportVisibilityState?.[trackType]), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((nextViewportVisibilityState)=>{\n                // skip initial trigger\n                if (!viewportVisibilityState) {\n                    viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                    return;\n                }\n                viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return requestTrackWithDimensions(DebounceType.MEDIUM, undefined);\n                }\n                requestTrackWithDimensions(DebounceType.MEDIUM, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n            });\n            let lastDimensions;\n            const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(()=>{\n                const currentDimensions = `${videoElement.clientWidth},${videoElement.clientHeight}`;\n                // skip initial trigger\n                if (!lastDimensions) {\n                    lastDimensions = currentDimensions;\n                    return;\n                }\n                if (lastDimensions === currentDimensions || viewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return;\n                }\n                requestTrackWithDimensions(DebounceType.SLOW, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n                lastDimensions = currentDimensions;\n            });\n            resizeObserver?.observe(videoElement);\n            // element renders and gets bound - track subscription gets\n            // triggered first other ones get skipped on initial subscriptions\n            const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(\"publishedTracks\"), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.publishedTracks.includes(trackType === \"videoTrack\" ? TrackType.VIDEO : TrackType.SCREEN_SHARE)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((isPublishing)=>{\n                if (isPublishing) {\n                    // the participant just started to publish a track\n                    requestTrackWithDimensions(DebounceType.FAST, {\n                        width: videoElement.clientWidth,\n                        height: videoElement.clientHeight\n                    });\n                } else {\n                    // the participant just stopped publishing a track\n                    requestTrackWithDimensions(DebounceType.FAST, undefined);\n                }\n            });\n            videoElement.autoplay = true;\n            videoElement.playsInline = true;\n            // explicitly marking the element as muted will allow autoplay to work\n            // without prior user interaction:\n            // https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\n            videoElement.muted = true;\n            const streamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"videoTrack\" ? \"videoStream\" : \"screenShareStream\")).subscribe((p)=>{\n                const source = trackType === \"videoTrack\" ? p.videoStream : p.screenShareStream;\n                if (videoElement.srcObject === source) return;\n                videoElement.srcObject = source ?? null;\n                if (isSafari() || isFirefox()) {\n                    setTimeout(()=>{\n                        videoElement.srcObject = source ?? null;\n                        videoElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                    // we add extra delay until we attempt to force-play\n                    // the participant's media stream in Firefox and Safari,\n                    // as they seem to have some timing issues\n                    }, 25);\n                }\n            });\n            return ()=>{\n                requestTrackWithDimensions(DebounceType.FAST, undefined);\n                viewportVisibilityStateSubscription?.unsubscribe();\n                publishedTracksSubscription?.unsubscribe();\n                streamSubscription.unsubscribe();\n                resizeObserver?.disconnect();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         * @returns a cleanup function that will unbind the audio element.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType)=>{\n            const participant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!participant || participant.isLocalParticipant) return;\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((p)=>!!p), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            const updateMediaStreamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"screenShareAudioTrack\" ? \"screenShareAudioStream\" : \"audioStream\")).subscribe((p)=>{\n                const source = trackType === \"screenShareAudioTrack\" ? p.screenShareAudioStream : p.audioStream;\n                if (audioElement.srcObject === source) return;\n                setTimeout(()=>{\n                    audioElement.srcObject = source ?? null;\n                    if (audioElement.srcObject) {\n                        audioElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                        // audio output device shall be set after the audio element is played\n                        // otherwise, the browser will not pick it up, and will always\n                        // play audio through the system's default device\n                        const { selectedDevice } = this.call.speaker.state;\n                        if (selectedDevice && \"setSinkId\" in audioElement) {\n                            audioElement.setSinkId(selectedDevice);\n                        }\n                    }\n                });\n            });\n            const sinkIdSubscription = !(\"setSinkId\" in audioElement) ? null : this.call.speaker.state.selectedDevice$.subscribe((deviceId)=>{\n                if (deviceId) {\n                    audioElement.setSinkId(deviceId);\n                }\n            });\n            const volumeSubscription = (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n                this.call.speaker.state.volume$,\n                participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(\"audioVolume\"))\n            ]).subscribe(([volume, p])=>{\n                audioElement.volume = p.audioVolume ?? volume;\n            });\n            audioElement.autoplay = true;\n            return ()=>{\n                sinkIdSubscription?.unsubscribe();\n                volumeSubscription.unsubscribe();\n                updateMediaStreamSubscription.unsubscribe();\n            };\n        };\n        this.call = call;\n    }\n}\n/**\n * Stores the permissions for the current user and exposes\n * a few helper methods which make it easier to work with permissions.\n *\n * This is an internal class meant to be used in combination with\n * a {@link Call} instance.\n *\n * @internal\n */ class PermissionsContext {\n    constructor(){\n        this.permissions = [];\n        /**\n         * Sets the permissions for the current user.\n         *\n         * @param permissions the permissions to set.\n         */ this.setPermissions = (permissions)=>{\n            this.permissions = permissions || [];\n        };\n        /**\n         * Sets the settings for the bound call.\n         * @param settings\n         */ this.setCallSettings = (settings)=>{\n            this.settings = settings;\n        };\n        /**\n         * Checks if the current user has a specific permission.\n         *\n         * @param permission the permission to check for.\n         */ this.hasPermission = (permission)=>{\n            return this.permissions.includes(permission);\n        };\n        /**\n         * Checks if the current user can request a specific permission\n         * within the call.\n         *\n         * @param permission the permission to check for.\n         * @param settings the call settings to check against (optional).\n         */ this.canRequest = (permission, settings = this.settings)=>{\n            if (!settings) return false;\n            const { audio, video, screensharing } = settings;\n            switch(permission){\n                case OwnCapability.SEND_AUDIO:\n                    return audio.access_request_enabled;\n                case OwnCapability.SEND_VIDEO:\n                    return video.access_request_enabled;\n                case OwnCapability.SCREENSHARE:\n                    return screensharing.access_request_enabled;\n                default:\n                    return false;\n            }\n        };\n    }\n}\n/**\n * Represents a call type.\n */ class CallType {\n    /**\n     * Constructs a new CallType.\n     *\n     * @param name the name of the call type.\n     * @param options the options for the call type.\n     */ constructor(name, options = {\n        sortParticipantsBy: defaultSortPreset\n    }){\n        this.name = name;\n        this.options = options;\n    }\n}\n/**\n * A registry of {@link CallType}s.\n * You can register and unregister call types.\n */ class CallTypesRegistry {\n    /**\n     * Constructs a new CallTypesRegistry.\n     *\n     * @param callTypes the initial call types to register.\n     */ constructor(callTypes){\n        /**\n         * Registers a new call type.\n         *\n         * @param callType the call type to register.\n         */ this.register = (callType)=>{\n            this.callTypes[callType.name] = callType;\n        };\n        /**\n         * Unregisters a call type.\n         *\n         * @param name the name of the call type to unregister.\n         */ this.unregister = (name)=>{\n            delete this.callTypes[name];\n        };\n        /**\n         * Gets a call type by name.\n         *\n         * @param name the name of the call type to get.\n         */ this.get = (name)=>{\n            if (!this.callTypes[name]) {\n                this.register(new CallType(name));\n            }\n            return this.callTypes[name];\n        };\n        this.callTypes = callTypes.reduce((acc, callType)=>{\n            acc[callType.name] = callType;\n            return acc;\n        }, {});\n    }\n}\n/**\n * The default call types registry.\n * You can use this instance to dynamically register and unregister call types.\n */ const CallTypes = new CallTypesRegistry([\n    new CallType(\"default\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"development\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"livestream\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    }),\n    new CallType(\"audio_room\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    })\n]);\n/**\n * Returns an Observable that emits the list of available devices\n * that meet the given constraints.\n *\n * @param constraints the constraints to use when requesting the devices.\n * @param kind the kind of devices to enumerate.\n */ const getDevices = (constraints, kind)=>{\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        const enumerate = async ()=>{\n            let devices = await navigator.mediaDevices.enumerateDevices();\n            // some browsers report empty device labels (Firefox).\n            // in that case, we need to request permissions (via getUserMedia)\n            // to be able to get the device labels\n            const needsGetUserMedia = devices.some((device)=>device.kind === kind && device.label === \"\");\n            if (needsGetUserMedia) {\n                let mediaStream;\n                try {\n                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n                    devices = await navigator.mediaDevices.enumerateDevices();\n                } finally{\n                    if (mediaStream) disposeOfMediaStream(mediaStream);\n                }\n            }\n            return devices;\n        };\n        enumerate().then((devices)=>{\n            // notify subscribers and complete\n            subscriber.next(devices);\n            subscriber.complete();\n        }).catch((error)=>{\n            const logger = getLogger([\n                \"devices\"\n            ]);\n            logger(\"error\", \"Failed to enumerate devices\", error);\n            subscriber.error(error);\n        });\n    });\n};\n/**\n * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n *\n *  */ const checkIfAudioOutputChangeSupported = ()=>{\n    if (typeof document === \"undefined\") return false;\n    const element = document.createElement(\"audio\");\n    return \"setSinkId\" in element;\n};\n/**\n * The default constraints used to request audio devices.\n */ const audioDeviceConstraints = {\n    audio: {\n        autoGainControl: true,\n        noiseSuppression: true,\n        echoCancellation: true\n    }\n};\n/**\n * The default constraints used to request video devices.\n */ const videoDeviceConstraints = {\n    video: {\n        width: 1280,\n        height: 720\n    }\n};\n/**\n * Creates a memoized observable instance\n * that will be created only once and shared between all callers.\n *\n * @param create a function that creates an Observable.\n */ const memoizedObservable = (create)=>{\n    let memoized;\n    return ()=>{\n        if (!memoized) memoized = create();\n        return memoized;\n    };\n};\nconst getDeviceChangeObserver = memoizedObservable(()=>{\n    // Audio and video devices are requested in two separate requests.\n    // That way, users will be presented with two separate prompts\n    // -> they can give access to just camera, or just microphone\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        // 'addEventListener' is not available in React Native\n        if (!navigator.mediaDevices.addEventListener) return;\n        const notify = ()=>subscriber.next();\n        navigator.mediaDevices.addEventListener(\"devicechange\", notify);\n        return ()=>{\n            navigator.mediaDevices.removeEventListener(\"devicechange\", notify);\n        };\n    }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__.debounceTime)(500), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.concatMap)(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices())), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audioinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioOutputDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audiooutput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getVideoDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(videoDeviceConstraints, \"videoinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audioinput' devices, if devices are added/removed the list is updated.\n */ const getAudioDevices = ()=>{\n    return getAudioDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audioinput\")));\n};\n/**\n * Prompts the user for a permission to use video devices (if not already granted) and lists the available 'videoinput' devices, if devices are added/removed the list is updated.\n */ const getVideoDevices = ()=>{\n    return getVideoDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"videoinput\")));\n};\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audiooutput' devices, if devices are added/removed the list is updated. Selecting 'audiooutput' device only makes sense if [the browser has support for changing audio output on 'audio' elements](#checkifaudiooutputchangesupported)\n */ const getAudioOutputDevices = ()=>{\n    return getAudioOutputDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audiooutput\")));\n};\nconst getStream = async (constraints)=>{\n    try {\n        return await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", `Failed get user media`, {\n            error: e,\n            constraints: constraints\n        });\n        throw e;\n    }\n};\n/**\n * Returns an audio media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns the new `MediaStream` fulfilling the given constraints.\n */ const getAudioStream = async (trackConstraints)=>{\n    const constraints = {\n        audio: {\n            ...audioDeviceConstraints.audio,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Returns a video media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns a new `MediaStream` fulfilling the given constraints.\n */ const getVideoStream = async (trackConstraints)=>{\n    const constraints = {\n        video: {\n            ...videoDeviceConstraints.video,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Prompts the user for a permission to share a screen.\n * If the user grants the permission, a screen sharing stream is returned. Throws otherwise.\n *\n * The callers of this API are responsible to handle the possible errors.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n *\n * @param options any additional options to pass to the [`getDisplayMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia) API.\n */ const getScreenShareStream = async (options)=>{\n    try {\n        return await navigator.mediaDevices.getDisplayMedia({\n            video: true,\n            audio: {\n                channelCount: {\n                    ideal: 2\n                },\n                echoCancellation: false,\n                autoGainControl: false,\n                noiseSuppression: false\n            },\n            // @ts-expect-error - not present in types yet\n            systemAudio: \"include\",\n            ...options\n        });\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", \"Failed to get screen share stream\", e);\n        throw e;\n    }\n};\nconst deviceIds$ = typeof navigator !== \"undefined\" && typeof navigator.mediaDevices !== \"undefined\" ? memoizedObservable(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices()), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1)))() : undefined;\n/**\n * Deactivates MediaStream (stops and removes tracks) to be later garbage collected\n *\n * @param stream MediaStream\n * @returns void\n */ const disposeOfMediaStream = (stream)=>{\n    if (!stream.active) return;\n    stream.getTracks().forEach((track)=>{\n        track.stop();\n        stream.removeTrack(track);\n    });\n    // @ts-expect-error release() is present in react-native-webrtc and must be called to dispose the stream\n    if (typeof stream.release === \"function\") {\n        // @ts-expect-error\n        stream.release();\n    }\n};\nclass InputMediaDeviceManager {\n    constructor(call, state, trackType){\n        this.call = call;\n        this.state = state;\n        this.trackType = trackType;\n        /**\n         * if true, stops the media stream when call is left\n         */ this.stopOnLeave = true;\n        this.subscriptions = [];\n        this.isTrackStoppedDueToTrackEnd = false;\n        this.filters = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s());\n        };\n        this.logger = getLogger([\n            `${TrackType[trackType].toLowerCase()} manager`\n        ]);\n        if (deviceIds$ && !isReactNative() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {\n            this.handleDisconnectedOrReplacedDevices();\n        }\n    }\n    /**\n     * Lists the available audio/video devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        return this.getDevices();\n    }\n    /**\n     * Starts stream.\n     */ async enable() {\n        if (this.state.status === \"enabled\") return;\n        this.enablePromise = this.unmuteStream();\n        try {\n            await this.enablePromise;\n            this.state.setStatus(\"enabled\");\n            this.enablePromise = undefined;\n        } catch (error) {\n            this.enablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * Stops or pauses the stream based on state.disableMode\n     * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode\n     */ async disable(forceStop = false) {\n        this.state.prevStatus = this.state.status;\n        if (!forceStop && this.state.status === \"disabled\") return;\n        const stopTracks = forceStop || this.state.disableMode === \"stop-tracks\";\n        this.disablePromise = this.muteStream(stopTracks);\n        try {\n            await this.disablePromise;\n            this.state.setStatus(\"disabled\");\n            this.disablePromise = undefined;\n        } catch (error) {\n            this.disablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * If status was previously enabled, it will re-enable the device.\n     */ async resume() {\n        if (this.state.prevStatus === \"enabled\" && this.state.status === \"disabled\") {\n            await this.enable();\n        }\n    }\n    /**\n     * If the current device status is disabled, it will enable the device,\n     * else it will disable it.\n     */ async toggle() {\n        if (this.state.status === \"enabled\") {\n            return this.disable();\n        } else {\n            return this.enable();\n        }\n    }\n    /**\n     * Registers a filter that will be applied to the stream.\n     *\n     * The registered filter will get the existing stream, and it should return\n     * a new stream with the applied filter.\n     *\n     * @param filter the filter to register.\n     * @returns a function that will unregister the filter.\n     */ async registerFilter(filter) {\n        this.filters.push(filter);\n        await this.applySettingsToStream();\n        return async ()=>{\n            this.filters = this.filters.filter((f)=>f !== filter);\n            await this.applySettingsToStream();\n        };\n    }\n    /**\n     * Will set the default constraints for the device.\n     *\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.state.setDefaultConstraints(constraints);\n    }\n    /**\n     * Selects a device.\n     *\n     * Note: This method is not supported in React Native\n     * @param deviceId the device id to select.\n     */ async select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This method is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for reference.\");\n        }\n        if (deviceId === this.state.selectedDevice) {\n            return;\n        }\n        this.state.setDevice(deviceId);\n        await this.applySettingsToStream();\n    }\n    async applySettingsToStream() {\n        if (this.state.status === \"enabled\") {\n            await this.muteStream();\n            await this.unmuteStream();\n        }\n    }\n    getTracks() {\n        return this.state.mediaStream?.getTracks() ?? [];\n    }\n    async muteStream(stopTracks = true) {\n        if (!this.state.mediaStream) return;\n        this.logger(\"debug\", `${stopTracks ? \"Stopping\" : \"Disabling\"} stream`);\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.stopPublishStream(stopTracks);\n        }\n        this.muteLocalStream(stopTracks);\n        const allEnded = this.getTracks().every((t)=>t.readyState === \"ended\");\n        if (allEnded) {\n            if (this.state.mediaStream && // @ts-expect-error release() is present in react-native-webrtc\n            typeof this.state.mediaStream.release === \"function\") {\n                // @ts-expect-error called to dispose the stream in RN\n                this.state.mediaStream.release();\n            }\n            this.state.setMediaStream(undefined);\n        }\n    }\n    muteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.enabled) track.enabled = false;\n        });\n    }\n    unmuteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (!track.enabled) track.enabled = true;\n        });\n    }\n    stopTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.readyState === \"live\") track.stop();\n        });\n    }\n    muteLocalStream(stopTracks) {\n        if (!this.state.mediaStream) {\n            return;\n        }\n        if (stopTracks) {\n            this.stopTracks();\n        } else {\n            this.muteTracks();\n        }\n    }\n    async unmuteStream() {\n        this.logger(\"debug\", \"Starting stream\");\n        let stream;\n        if (this.state.mediaStream && this.getTracks().every((t)=>t.readyState === \"live\")) {\n            stream = this.state.mediaStream;\n            this.unmuteTracks();\n        } else {\n            const defaultConstraints = this.state.defaultConstraints;\n            const constraints = {\n                ...defaultConstraints,\n                deviceId: this.state.selectedDevice\n            };\n            /**\n             * Chains two media streams together.\n             *\n             * In our case, filters MediaStreams are derived from their parent MediaStream.\n             * However, once a child filter's track is stopped,\n             * the tracks of the parent MediaStream aren't automatically stopped.\n             * This leads to a situation where the camera indicator light is still on\n             * even though the user stopped publishing video.\n             *\n             * This function works around this issue by stopping the parent MediaStream's tracks\n             * as well once the child filter's tracks are stopped.\n             *\n             * It works by patching the stop() method of the child filter's tracks to also stop\n             * the parent MediaStream's tracks of the same type. Here we assume that\n             * the parent MediaStream has only one track of each type.\n             *\n             * @param parentStream the parent MediaStream. Omit for the root stream.\n             */ const chainWith = (parentStream)=>async (filterStream)=>{\n                    if (!parentStream) return filterStream;\n                    // TODO OL: take care of track.enabled property as well\n                    const parent = await parentStream;\n                    filterStream.getTracks().forEach((track)=>{\n                        const originalStop = track.stop;\n                        track.stop = function stop() {\n                            originalStop.call(track);\n                            parent.getTracks().forEach((parentTrack)=>{\n                                if (parentTrack.kind === track.kind) {\n                                    parentTrack.stop();\n                                }\n                            });\n                        };\n                    });\n                    parent.getTracks().forEach((parentTrack)=>{\n                        // When the parent stream abruptly ends, we propagate the event\n                        // to the filter stream.\n                        // This usually happens when the camera/microphone permissions\n                        // are revoked or when the device is disconnected.\n                        const handleParentTrackEnded = ()=>{\n                            filterStream.getTracks().forEach((track)=>{\n                                if (parentTrack.kind !== track.kind) return;\n                                track.stop();\n                                track.dispatchEvent(new Event(\"ended\")); // propagate the event\n                            });\n                        };\n                        parentTrack.addEventListener(\"ended\", handleParentTrackEnded);\n                        this.subscriptions.push(()=>{\n                            parentTrack.removeEventListener(\"ended\", handleParentTrackEnded);\n                        });\n                    });\n                    return filterStream;\n                };\n            // we publish the last MediaStream of the chain\n            stream = await this.filters.reduce((parent, filter)=>parent.then(filter).then(chainWith(parent)), this.getStream(constraints));\n        }\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.publishStream(stream);\n        }\n        if (this.state.mediaStream !== stream) {\n            this.state.setMediaStream(stream);\n            this.getTracks().forEach((track)=>{\n                track.addEventListener(\"ended\", async ()=>{\n                    if (this.enablePromise) {\n                        await this.enablePromise;\n                    }\n                    if (this.disablePromise) {\n                        await this.disablePromise;\n                    }\n                    if (this.state.status === \"enabled\") {\n                        this.isTrackStoppedDueToTrackEnd = true;\n                        setTimeout(()=>{\n                            this.isTrackStoppedDueToTrackEnd = false;\n                        }, 2000);\n                        await this.disable();\n                    }\n                });\n            });\n        }\n    }\n    get mediaDeviceKind() {\n        if (this.trackType === TrackType.AUDIO) {\n            return \"audioinput\";\n        }\n        if (this.trackType === TrackType.VIDEO) {\n            return \"videoinput\";\n        }\n        return \"\";\n    }\n    handleDisconnectedOrReplacedDevices() {\n        this.subscriptions.push(createSubscription((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            deviceIds$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__.pairwise)()),\n            this.state.selectedDevice$\n        ]), async ([[prevDevices, currentDevices], deviceId])=>{\n            if (!deviceId) {\n                return;\n            }\n            if (this.enablePromise) {\n                await this.enablePromise;\n            }\n            if (this.disablePromise) {\n                await this.disablePromise;\n            }\n            let isDeviceDisconnected = false;\n            let isDeviceReplaced = false;\n            const currentDevice = this.findDeviceInList(currentDevices, deviceId);\n            const prevDevice = this.findDeviceInList(prevDevices, deviceId);\n            if (!currentDevice && prevDevice) {\n                isDeviceDisconnected = true;\n            } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {\n                isDeviceReplaced = true;\n            }\n            if (isDeviceDisconnected) {\n                await this.disable();\n                this.select(undefined);\n            }\n            if (isDeviceReplaced) {\n                if (this.isTrackStoppedDueToTrackEnd && this.state.status === \"disabled\") {\n                    await this.enable();\n                    this.isTrackStoppedDueToTrackEnd = false;\n                } else {\n                    await this.applySettingsToStream();\n                }\n            }\n        }));\n    }\n    findDeviceInList(devices, deviceId) {\n        return devices.find((d)=>d.deviceId === deviceId && d.kind === this.mediaDeviceKind);\n    }\n}\nclass InputMediaDeviceManagerState {\n    /**\n     * Constructs new InputMediaDeviceManagerState instance.\n     *\n     * @param disableMode the disable mode to use.\n     * @param permissionName the permission name to use for querying.\n     * `undefined` means no permission is required.\n     */ constructor(disableMode = \"stop-tracks\", permissionName = undefined){\n        this.disableMode = disableMode;\n        this.permissionName = permissionName;\n        this.statusSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.mediaStreamSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.defaultConstraintsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current media stream, or `undefined` if the device is currently disabled.\n         *\n         */ this.mediaStream$ = this.mediaStreamSubject.asObservable();\n        /**\n         * An Observable that emits the currently selected device\n         */ this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the device status\n         */ this.status$ = this.statusSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * The default constraints for the device.\n         */ this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();\n        /**\n         * An observable that will emit `true` if browser/system permission\n         * is granted, `false` otherwise.\n         */ this.hasBrowserPermission$ = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n            const notifyGranted = ()=>subscriber.next(true);\n            const permissionsAPIAvailable = !!navigator?.permissions?.query;\n            if (isReactNative() || !this.permissionName || !permissionsAPIAvailable) {\n                getLogger([\n                    \"devices\"\n                ])(\"warn\", `Permissions can't be queried. Assuming granted.`);\n                return notifyGranted();\n            }\n            let permissionState;\n            const notify = ()=>{\n                subscriber.next(// In some browsers, the 'change' event doesn't reliably emit and hence,\n                // permissionState stays in 'prompt' state forever.\n                // Typically, this happens when a user grants one-time permission.\n                // Instead of checking if a permission is granted, we check if it isn't denied\n                permissionState.state !== \"denied\");\n            };\n            navigator.permissions.query({\n                name: this.permissionName\n            }).then((permissionStatus)=>{\n                permissionState = permissionStatus;\n                permissionState.addEventListener(\"change\", notify);\n                notify();\n            }).catch(()=>{\n                // permission doesn't exist or can't be queried -> assume it's granted\n                // an example would be Firefox,\n                // where neither camera microphone permission can be queried\n                notifyGranted();\n            });\n            return ()=>{\n                permissionState?.removeEventListener(\"change\", notify);\n            };\n        }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n    }\n    /**\n     * The device status\n     */ get status() {\n        return this.getCurrentValue(this.status$);\n    }\n    /**\n     * The currently selected device\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The current media stream, or `undefined` if the device is currently disabled.\n     */ get mediaStream() {\n        return this.getCurrentValue(this.mediaStream$);\n    }\n    /**\n     * @internal\n     * @param status\n     */ setStatus(status) {\n        this.setCurrentValue(this.statusSubject, status);\n    }\n    /**\n     * @internal\n     * @param stream the stream to set.\n     */ setMediaStream(stream) {\n        this.setCurrentValue(this.mediaStreamSubject, stream);\n        if (stream) {\n            this.setDevice(this.getDeviceIdFromStream(stream));\n        }\n    }\n    /**\n     * @internal\n     * @param deviceId the device id to set.\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * Gets the default constraints for the device.\n     */ get defaultConstraints() {\n        return this.getCurrentValue(this.defaultConstraints$);\n    }\n    /**\n     * Sets the default constraints for the device.\n     *\n     * @internal\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.setCurrentValue(this.defaultConstraintsSubject, constraints);\n    }\n}\nclass CameraManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"stop-tracks\", // `camera` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"camera\");\n        this.directionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.direction$ = this.directionSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The preferred camera direction\n     * front - means the camera facing the user\n     * back - means the camera facing the environment\n     */ get direction() {\n        return this.getCurrentValue(this.direction$);\n    }\n    /**\n     * @internal\n     */ setDirection(direction) {\n        this.setCurrentValue(this.directionSubject, direction);\n    }\n    /**\n     * @internal\n     */ setMediaStream(stream) {\n        super.setMediaStream(stream);\n        if (stream) {\n            // RN getSettings() doesn't return facingMode, so we don't verify camera direction\n            const direction = isReactNative() ? this.direction : stream.getVideoTracks()[0]?.getSettings().facingMode === \"environment\" ? \"back\" : \"front\";\n            this.setDirection(direction);\n        }\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getVideoTracks()[0]?.getSettings().deviceId;\n    }\n}\nclass CameraManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new CameraManagerState(), TrackType.VIDEO);\n        this.targetResolution = {\n            width: 1280,\n            height: 720\n        };\n    }\n    /**\n     * Select the camera direction.\n     *\n     * @param direction the direction of the camera to select.\n     */ async selectDirection(direction) {\n        this.state.setDirection(direction);\n        // Providing both device id and direction doesn't work, so we deselect the device\n        this.state.setDevice(undefined);\n        await this.applySettingsToStream();\n    }\n    /**\n     * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.\n     *\n     * Note: if there is no available camera with the desired direction, this method will do nothing.\n     * @returns\n     */ async flip() {\n        const newDirection = this.state.direction === \"front\" ? \"back\" : \"front\";\n        await this.selectDirection(newDirection);\n    }\n    /**\n     * @internal\n     */ async selectTargetResolution(resolution) {\n        this.targetResolution.height = resolution.height;\n        this.targetResolution.width = resolution.width;\n        if (this.enablePromise) {\n            try {\n                await this.enablePromise;\n            } catch (error) {\n                // couldn't enable device, target resolution will be applied the next time user attempts to start the device\n                this.logger(\"warn\", \"could not apply target resolution\", error);\n            }\n        }\n        if (this.state.status === \"enabled\") {\n            const { width, height } = this.state.mediaStream.getVideoTracks()[0]?.getSettings();\n            if (width !== this.targetResolution.width || height !== this.targetResolution.height) {\n                await this.applySettingsToStream();\n                this.logger(\"debug\", `${width}x${height} target resolution applied to media stream`);\n            }\n        }\n    }\n    /**\n     * Sets the preferred codec for encoding the video.\n     *\n     * @internal internal use only, not part of the public API.\n     * @param codec the codec to use for encoding the video.\n     */ setPreferredCodec(codec) {\n        this.preferredCodec = codec;\n    }\n    getDevices() {\n        return getVideoDevices();\n    }\n    getStream(constraints) {\n        constraints.width = this.targetResolution.width;\n        constraints.height = this.targetResolution.height;\n        // We can't set both device id and facing mode\n        // Device id has higher priority\n        if (!constraints.deviceId && this.state.direction) {\n            constraints.facingMode = this.state.direction === \"front\" ? \"user\" : \"environment\";\n        }\n        return getVideoStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishVideoStream(stream, {\n            preferredCodec: this.preferredCodec\n        });\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.VIDEO, stopTracks);\n    }\n}\nclass MicrophoneManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"disable-tracks\", // `microphone` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"microphone\");\n        this.speakingWhileMutedSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * `true` if the user's microphone is muted but they'are speaking.\n     *\n     * This feature is not available in the React Native SDK.\n     */ get speakingWhileMuted() {\n        return this.getCurrentValue(this.speakingWhileMuted$);\n    }\n    /**\n     * @internal\n     */ setSpeakingWhileMuted(isSpeaking) {\n        this.setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getAudioTracks()[0]?.getSettings().deviceId;\n    }\n}\nconst DETECTION_FREQUENCY_IN_MS = 500;\nconst AUDIO_LEVEL_THRESHOLD$1 = 150;\nconst FFT_SIZE = 128;\n/**\n * Creates a new sound detector.\n *\n * @param audioStream the audio stream to observe. Depending on the provided configuration, this stream might be destroyed when the sound detector is stopped.\n * @param onSoundDetectedStateChanged a callback which is called when the sound state changes.\n * @param options custom options for the sound detector.\n * @returns a clean-up function which once invoked stops the sound detector.\n */ const createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {})=>{\n    const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD$1, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;\n    const audioContext = new AudioContext();\n    const analyser = audioContext.createAnalyser();\n    analyser.fftSize = fftSize;\n    const microphone = audioContext.createMediaStreamSource(audioStream);\n    microphone.connect(analyser);\n    const intervalId = setInterval(()=>{\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        analyser.getByteFrequencyData(data);\n        const isSoundDetected = data.some((value)=>value >= audioLevelThreshold);\n        const averagedDataValue = data.reduce((pv, cv)=>pv + cv, 0) / data.length;\n        const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);\n        // When the track is disabled, it takes time for the buffer to empty\n        // This check will ensure that we don't send anything if the track is disabled\n        if (audioStream.getAudioTracks()[0]?.enabled) {\n            onSoundDetectedStateChanged({\n                isSoundDetected,\n                audioLevel: percentage\n            });\n        } else {\n            onSoundDetectedStateChanged({\n                isSoundDetected: false,\n                audioLevel: 0\n            });\n        }\n    }, detectionFrequencyInMs);\n    return async function stop() {\n        clearInterval(intervalId);\n        // clean-up the AudioContext elements\n        microphone.disconnect();\n        analyser.disconnect();\n        await audioContext.close();\n        // stop the stream\n        if (destroyStreamOnStop) {\n            audioStream.getTracks().forEach((track)=>{\n                track.stop();\n                audioStream.removeTrack(track);\n            });\n        }\n    };\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst AUDIO_LEVEL_THRESHOLD = 0.2;\nclass RNSpeechDetector {\n    constructor(){\n        this.pc1 = new RTCPeerConnection({});\n        this.pc2 = new RTCPeerConnection({});\n    }\n    /**\n     * Starts the speech detection.\n     */ async start() {\n        try {\n            const audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            this.pc1.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc2.addIceCandidate(e.candidate);\n            });\n            this.pc2.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc1.addIceCandidate(e.candidate);\n            });\n            audioStream.getTracks().forEach((track)=>this.pc1.addTrack(track, audioStream));\n            const offer = await this.pc1.createOffer({});\n            await this.pc2.setRemoteDescription(offer);\n            await this.pc1.setLocalDescription(offer);\n            const answer = await this.pc2.createAnswer();\n            await this.pc1.setRemoteDescription(answer);\n            await this.pc2.setLocalDescription(answer);\n            const audioTracks = audioStream.getAudioTracks();\n            // We need to mute the audio track for this temporary stream, or else you will hear yourself twice while in the call.\n            audioTracks.forEach((track)=>track.enabled = false);\n        } catch (error) {\n            console.error(\"Error connecting and negotiating between PeerConnections:\", error);\n        }\n    }\n    /**\n     * Stops the speech detection and releases all allocated resources.\n     */ stop() {\n        this.pc1.close();\n        this.pc2.close();\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    /**\n     * Public method that detects the audio levels and returns the status.\n     */ onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {\n        this.intervalId = setInterval(async ()=>{\n            const stats = await this.pc1.getStats();\n            const report = flatten(stats);\n            // Audio levels are present inside stats of type `media-source` and of kind `audio`\n            const audioMediaSourceStats = report.find((stat)=>stat.type === \"media-source\" && stat.kind === \"audio\");\n            if (audioMediaSourceStats) {\n                const { audioLevel } = audioMediaSourceStats;\n                if (audioLevel) {\n                    if (audioLevel >= AUDIO_LEVEL_THRESHOLD) {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: true,\n                            audioLevel\n                        });\n                    } else {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: false,\n                            audioLevel: 0\n                        });\n                    }\n                }\n            }\n        }, 1000);\n        return ()=>{\n            clearInterval(this.intervalId);\n        };\n    }\n}\nclass MicrophoneManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new MicrophoneManagerState(), TrackType.AUDIO);\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            this.call.state.callingState$,\n            this.call.state.ownCapabilities$,\n            this.state.selectedDevice$,\n            this.state.status$\n        ]).subscribe(async ([callingState, ownCapabilities, deviceId, status])=>{\n            if (callingState !== CallingState.JOINED) {\n                if (callingState === CallingState.LEFT) {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n                return;\n            }\n            if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {\n                if (status === \"disabled\") {\n                    await this.startSpeakingWhileMutedDetection(deviceId);\n                } else {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n            } else {\n                await this.stopSpeakingWhileMutedDetection();\n            }\n        });\n    }\n    getDevices() {\n        return getAudioDevices();\n    }\n    getStream(constraints) {\n        return getAudioStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishAudioStream(stream);\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.AUDIO, stopTracks);\n    }\n    async startSpeakingWhileMutedDetection(deviceId) {\n        await this.stopSpeakingWhileMutedDetection();\n        if (isReactNative()) {\n            this.rnSpeechDetector = new RNSpeechDetector();\n            await this.rnSpeechDetector.start();\n            const unsubscribe = this.rnSpeechDetector?.onSpeakingDetectedStateChange((event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n            this.soundDetectorCleanup = ()=>{\n                unsubscribe();\n                this.rnSpeechDetector?.stop();\n                this.rnSpeechDetector = undefined;\n            };\n        } else {\n            // Need to start a new stream that's not connected to publisher\n            const stream = await this.getStream({\n                deviceId\n            });\n            this.soundDetectorCleanup = createSoundDetector(stream, (event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n        }\n    }\n    async stopSpeakingWhileMutedDetection() {\n        if (!this.soundDetectorCleanup) {\n            return;\n        }\n        this.state.setSpeakingWhileMuted(false);\n        try {\n            await this.soundDetectorCleanup();\n        } finally{\n            this.soundDetectorCleanup = undefined;\n        }\n    }\n}\nclass ScreenShareState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(...arguments);\n        this.audioEnabledSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current screen share audio status.\n         */ this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the current screen share settings.\n         */ this.settings$ = this.settingsSubject.asObservable();\n        /**\n         * @internal\n         */ this.getDeviceIdFromStream = (stream)=>{\n            const [track] = stream.getTracks();\n            return track?.getSettings().deviceId;\n        };\n    }\n    /**\n     * The current screen share audio status.\n     */ get audioEnabled() {\n        return this.getCurrentValue(this.audioEnabled$);\n    }\n    /**\n     * Set the current screen share audio status.\n     */ setAudioEnabled(isEnabled) {\n        this.setCurrentValue(this.audioEnabledSubject, isEnabled);\n    }\n    /**\n     * The current screen share settings.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Set the current screen share settings.\n     *\n     * @param settings the screen share settings to set.\n     */ setSettings(settings) {\n        this.setCurrentValue(this.settingsSubject, settings);\n    }\n}\nclass ScreenShareManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);\n    }\n    /**\n     * Will enable screen share audio options on supported platforms.\n     *\n     * Note: for ongoing screen share, audio won't be enabled until you\n     * re-publish the screen share stream.\n     */ enableScreenShareAudio() {\n        this.state.setAudioEnabled(true);\n    }\n    /**\n     * Will disable screen share audio options on supported platforms.\n     */ async disableScreenShareAudio() {\n        this.state.setAudioEnabled(false);\n        if (this.call.publisher?.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n            await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, true);\n        }\n    }\n    /**\n     * Returns the current screen share settings.\n     */ getSettings() {\n        return this.state.settings;\n    }\n    /**\n     * Sets the current screen share settings.\n     *\n     * @param settings the settings to set.\n     */ setSettings(settings) {\n        this.state.setSettings(settings);\n    }\n    getDevices() {\n        return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__.of)([]); // there are no devices to be listed for Screen Share\n    }\n    getStream(constraints) {\n        if (!this.state.audioEnabled) {\n            constraints.audio = false;\n        }\n        return getScreenShareStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishScreenShareStream(stream, {\n            screenShareSettings: this.state.settings\n        });\n    }\n    async stopPublishStream(stopTracks) {\n        await this.call.stopPublish(TrackType.SCREEN_SHARE, stopTracks);\n        await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, stopTracks);\n    }\n    /**\n     * Overrides the default `select` method to throw an error.\n     *\n     * @param deviceId ignored.\n     */ async select(deviceId) {\n        throw new Error(\"This method is not supported in for Screen Share\");\n    }\n}\nclass SpeakerState {\n    constructor(){\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(\"\");\n        this.volumeSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(1);\n        /**\n         * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n         */ this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        this.volume$ = this.volumeSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The currently selected device\n     *\n     * Note: this feature is not supported in React Native\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The currently selected volume\n     *\n     * Note: this feature is not supported in React Native\n     */ get volume() {\n        return this.getCurrentValue(this.volume$);\n    }\n    /**\n     * @internal\n     * @param deviceId\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * @internal\n     * @param volume\n     */ setVolume(volume) {\n        this.setCurrentValue(this.volumeSubject, volume);\n    }\n}\nclass SpeakerManager {\n    constructor(call){\n        this.state = new SpeakerState();\n        this.subscriptions = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s.unsubscribe());\n        };\n        this.call = call;\n        if (deviceIds$ && !isReactNative()) {\n            this.subscriptions.push((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n                deviceIds$,\n                this.state.selectedDevice$\n            ]).subscribe(([devices, deviceId])=>{\n                if (!deviceId) {\n                    return;\n                }\n                const device = devices.find((d)=>d.deviceId === deviceId && d.kind === \"audiooutput\");\n                if (!device) {\n                    this.select(\"\");\n                }\n            }));\n        }\n    }\n    /**\n     * Lists the available audio output devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     * Note: This method is not supported in React Native\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        return getAudioOutputDevices();\n    }\n    /**\n     * Select a device.\n     *\n     * Note: This method is not supported in React Native\n     *\n     * @param deviceId empty string means the system default\n     */ select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        this.state.setDevice(deviceId);\n    }\n    /**\n     * Set the volume of the audio elements\n     * @param volume a number between 0 and 1.\n     *\n     * Note: This method is not supported in React Native\n     */ setVolume(volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1\");\n        }\n        this.state.setVolume(volume);\n    }\n    /**\n     * Set the volume of a participant.\n     *\n     * Note: This method is not supported in React Native.\n     *\n     * @param sessionId the participant's session id.\n     * @param volume a number between 0 and 1. Set it to `undefined` to use the default volume.\n     */ setParticipantVolume(sessionId, volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1, or undefined\");\n        }\n        this.call.state.updateParticipant(sessionId, {\n            audioVolume: volume\n        });\n    }\n}\n/**\n * An object representation of a `Call`.\n */ class Call {\n    /**\n     * Constructs a new `Call` instance.\n     *\n     * NOTE: Don't call the constructor directly, instead\n     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)\n     * method to construct a `Call` instance.\n     */ constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }){\n        /**\n         * The state of this call.\n         */ this.state = new CallState();\n        /**\n         * The DynascaleManager instance.\n         */ this.dynascaleManager = new DynascaleManager(this);\n        /**\n         * The permissions context of this call.\n         */ this.permissionsContext = new PermissionsContext();\n        /**\n         * The event dispatcher instance dedicated to this Call instance.\n         * @private\n         */ this.dispatcher = new Dispatcher();\n        this.trackSubscriptionsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({\n            type: DebounceType.MEDIUM,\n            data: []\n        });\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        /**\n         * A list hooks/functions to invoke when the call is left.\n         * A typical use case is to clean up some global event handlers.\n         * @private\n         */ this.leaveCallHooks = new Set();\n        this.streamClientEventHandlers = new Map();\n        /**\n         * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.\n         * Please note that subscribing to WebSocket events is an advanced use-case.\n         * For most use-cases, it should be enough to watch for state changes.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.on = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.on(eventName, fn);\n            }\n            const offHandler = this.streamClient.on(eventName, (e)=>{\n                const event = e;\n                if (event.call_cid && event.call_cid === this.cid) {\n                    fn(event);\n                }\n            });\n            // keep the 'off' reference returned by the stream client\n            this.streamClientEventHandlers.set(fn, offHandler);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.off = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.off(eventName, fn);\n            }\n            // unsubscribe from the stream client event by using the 'off' reference\n            const registeredOffHandler = this.streamClientEventHandlers.get(fn);\n            if (registeredOffHandler) {\n                registeredOffHandler();\n            }\n        };\n        /**\n         * Leave the call and stop the media streams that were published by the call.\n         */ this.leave = async ({ reject = false, reason = \"user is leaving the call\" } = {})=>{\n            const callingState = this.state.callingState;\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Cannot leave call that has already been left.\");\n            }\n            if (callingState === CallingState.JOINING) {\n                await this.assertCallJoined();\n            }\n            if (this.ringing) {\n                // I'm the one who started the call, so I should cancel it.\n                const hasOtherParticipants = this.state.remoteParticipants.length > 0;\n                if (this.isCreatedByMe && !hasOtherParticipants) {\n                    // Signals other users that I have cancelled my call to them\n                    // before they accepted it.\n                    await this.reject();\n                } else if (reject && callingState === CallingState.RINGING) {\n                    // Signals other users that I have rejected the incoming call.\n                    await this.reject();\n                }\n            }\n            this.statsReporter?.stop();\n            this.statsReporter = undefined;\n            this.sfuStatsReporter?.stop();\n            this.sfuStatsReporter = undefined;\n            this.subscriber?.close();\n            this.subscriber = undefined;\n            this.publisher?.close();\n            this.publisher = undefined;\n            this.sfuClient?.close(StreamSfuClient.NORMAL_CLOSURE, reason);\n            this.sfuClient = undefined;\n            this.dispatcher.offAll();\n            this.state.setCallingState(CallingState.LEFT);\n            // Call all leave call hooks, e.g. to clean up global event handlers\n            this.leaveCallHooks.forEach((hook)=>hook());\n            this.clientStore.unregisterCall(this);\n            this.camera.dispose();\n            this.microphone.dispose();\n            this.screenShare.dispose();\n            this.speaker.dispose();\n            const stopOnLeavePromises = [];\n            if (this.camera.stopOnLeave) {\n                stopOnLeavePromises.push(this.camera.disable(true));\n            }\n            if (this.microphone.stopOnLeave) {\n                stopOnLeavePromises.push(this.microphone.disable(true));\n            }\n            if (this.screenShare.stopOnLeave) {\n                stopOnLeavePromises.push(this.screenShare.disable(true));\n            }\n            await Promise.all(stopOnLeavePromises);\n        };\n        /**\n         * Loads the information about the call.\n         *\n         * @param params.ring if set to true, a `call.ring` event will be sent to the call members.\n         * @param params.notify if set to true, a `call.notification` event will be sent to the call members.\n         * @param params.members_limit the total number of members to return as part of the response.\n         */ this.get = async (params)=>{\n            const response = await this.streamClient.get(this.streamClientBasePath, params);\n            if (params?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Loads the information about the call and creates it if it doesn't exist.\n         *\n         * @param data the data to create the call with.\n         */ this.getOrCreate = async (data)=>{\n            const response = await this.streamClient.post(this.streamClientBasePath, data);\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Creates a call\n         *\n         * @param data the data to create the call with.\n         */ this.create = async (data)=>{\n            return this.getOrCreate(data);\n        };\n        /**\n         * A shortcut for {@link Call.get} with `ring` parameter set to `true`.\n         * Will send a `call.ring` event to the call members.\n         */ this.ring = async ()=>{\n            return await this.get({\n                ring: true\n            });\n        };\n        /**\n         * A shortcut for {@link Call.get} with `notify` parameter set to `true`.\n         * Will send a `call.notification` event to the call members.\n         */ this.notify = async ()=>{\n            return await this.get({\n                notify: true\n            });\n        };\n        /**\n         * Marks the incoming call as accepted.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.join} invokes this method automatically for you when joining a call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.accept = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/accept`);\n        };\n        /**\n         * Marks the incoming call as rejected.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.reject = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reject`);\n        };\n        /**\n         * Will start to watch for call related WebSocket events and initiate a call session with the server.\n         *\n         * @returns a promise which resolves once the call join-flow has finished.\n         */ this.join = async (data)=>{\n            const callingState = this.state.callingState;\n            if ([\n                CallingState.JOINED,\n                CallingState.JOINING\n            ].includes(callingState)) {\n                this.logger(\"warn\", \"Join method called twice, you should only call this once\");\n                throw new Error(`Illegal State: Already joined.`);\n            }\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Illegal State: Cannot join already left call. Create a new Call instance to join a call.\");\n            }\n            const isMigrating = callingState === CallingState.MIGRATING;\n            const isReconnecting = callingState === CallingState.RECONNECTING;\n            this.state.setCallingState(CallingState.JOINING);\n            this.logger(\"debug\", \"Starting join flow\");\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            if (this.ringing && !this.isCreatedByMe) {\n                // signals other users that I have accepted the incoming call.\n                await this.accept();\n            }\n            let sfuServer;\n            let sfuToken;\n            let connectionConfig;\n            let statsOptions;\n            try {\n                if (this.sfuClient?.isFastReconnecting) {\n                    // use previous SFU configuration and values\n                    connectionConfig = this.publisher?.connectionConfiguration;\n                    sfuServer = this.sfuClient.sfuServer;\n                    sfuToken = this.sfuClient.token;\n                    statsOptions = this.sfuStatsReporter?.options;\n                } else {\n                    // full join flow - let the Coordinator pick a new SFU for us\n                    const call = await join(this.streamClient, this.type, this.id, data);\n                    this.state.updateFromCallResponse(call.metadata);\n                    this.state.setMembers(call.members);\n                    this.state.setOwnCapabilities(call.ownCapabilities);\n                    connectionConfig = call.connectionConfig;\n                    sfuServer = call.sfuServer;\n                    sfuToken = call.token;\n                    statsOptions = call.statsOptions;\n                }\n                if (this.streamClient._hasConnectionID()) {\n                    this.watching = true;\n                    this.clientStore.registerCall(this);\n                }\n            } catch (error) {\n                // restore the previous call state if the join-flow fails\n                this.state.setCallingState(callingState);\n                throw error;\n            }\n            const previousSfuClient = this.sfuClient;\n            const sfuClient = this.sfuClient = new StreamSfuClient({\n                dispatcher: this.dispatcher,\n                sfuServer,\n                token: sfuToken,\n                sessionId: previousSfuClient?.sessionId\n            });\n            /**\n             * A closure which hides away the re-connection logic.\n             */ const reconnect = async (strategy, reason)=>{\n                const currentState = this.state.callingState;\n                if (currentState === CallingState.MIGRATING || currentState === CallingState.RECONNECTING) {\n                    // prevent parallel reconnection attempts\n                    return;\n                }\n                this.reconnectAttempts++;\n                this.state.setCallingState(strategy === \"migrate\" ? CallingState.MIGRATING : CallingState.RECONNECTING);\n                if (strategy === \"migrate\") {\n                    this.logger(\"debug\", `[Migration]: migrating call ${this.cid} away from ${sfuServer.edge_name}`);\n                    sfuClient.isMigratingAway = true;\n                } else {\n                    this.logger(\"debug\", `[Rejoin]: ${strategy} rejoin call ${this.cid} (${this.reconnectAttempts})...`);\n                }\n                // take a snapshot of the current \"local participant\" state\n                // we'll need it for restoring the previous publishing state later\n                const localParticipant = this.state.localParticipant;\n                if (strategy === \"fast\") {\n                    sfuClient.close(StreamSfuClient.ERROR_CONNECTION_BROKEN, `attempting fast reconnect: ${reason}`);\n                } else if (strategy === \"full\") {\n                    // in migration or recovery scenarios, we don't want to\n                    // wait before attempting to reconnect to an SFU server\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    // in full-reconnect, we need to dispose all Peer Connections\n                    this.subscriber?.close();\n                    this.subscriber = undefined;\n                    this.publisher?.close({\n                        stopTracks: false\n                    });\n                    this.publisher = undefined;\n                    this.statsReporter?.stop();\n                    this.statsReporter = undefined;\n                    this.sfuStatsReporter?.stop();\n                    this.sfuStatsReporter = undefined;\n                    // clean up current connection\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, `attempting full reconnect: ${reason}`);\n                }\n                await this.join({\n                    ...data,\n                    ...strategy === \"migrate\" && {\n                        migrating_from: sfuServer.edge_name\n                    }\n                });\n                // clean up previous connection\n                if (strategy === \"migrate\") {\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, \"attempting migration\");\n                }\n                this.logger(\"info\", `[Rejoin]: Attempt ${this.reconnectAttempts} successful!`);\n                // we shouldn't be republishing the streams if we're migrating\n                // as the underlying peer connection will take care of it as part\n                // of the ice-restart process\n                if (localParticipant && strategy === \"full\") {\n                    const { audioStream, videoStream, screenShareStream, screenShareAudioStream } = localParticipant;\n                    let screenShare;\n                    if (screenShareStream || screenShareAudioStream) {\n                        screenShare = new MediaStream();\n                        screenShareStream?.getVideoTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                        screenShareAudioStream?.getAudioTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                    }\n                    // restore previous publishing state\n                    if (audioStream) await this.publishAudioStream(audioStream);\n                    if (videoStream) {\n                        await this.publishVideoStream(videoStream, {\n                            preferredCodec: this.camera.preferredCodec\n                        });\n                    }\n                    if (screenShare) await this.publishScreenShareStream(screenShare);\n                    this.logger(\"info\", `[Rejoin]: State restored. Attempt: ${this.reconnectAttempts}`);\n                }\n            };\n            // reconnect if the connection was closed unexpectedly. example:\n            // - SFU crash or restart\n            // - network change\n            sfuClient.signalReady.then(()=>{\n                // register a handler for the \"goAway\" event\n                const unregisterGoAway = this.dispatcher.on(\"goAway\", (event)=>{\n                    const { reason } = event;\n                    this.logger(\"info\", `[Migration]: Going away from SFU... Reason: ${GoAwayReason[reason]}`);\n                    reconnect(\"migrate\", GoAwayReason[reason]).catch((err)=>{\n                        this.logger(\"warn\", `[Migration]: Failed to migrate to another SFU.`, err);\n                    });\n                });\n                sfuClient.signalWs.addEventListener(\"close\", (e)=>{\n                    // unregister the \"goAway\" handler, as we won't need it anymore for this connection.\n                    // the upcoming re-join will register a new handler anyway\n                    unregisterGoAway();\n                    // do nothing if the connection was closed on purpose\n                    if (e.code === StreamSfuClient.NORMAL_CLOSURE) return;\n                    // do nothing if the connection was closed because of a policy violation\n                    // e.g., the user has been blocked by an admin or moderator\n                    if (e.code === KnownCodes.WS_POLICY_VIOLATION) return;\n                    // When the SFU is being shut down, it sends a goAway message.\n                    // While we migrate to another SFU, we might have the WS connection\n                    // to the old SFU closed abruptly. In this case, we don't want\n                    // to reconnect to the old SFU, but rather to the new one.\n                    const isMigratingAway = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isMigratingAway;\n                    const isFastReconnecting = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isFastReconnecting;\n                    if (isMigratingAway || isFastReconnecting) return;\n                    // do nothing if the connection was closed because of a fast reconnect\n                    if (e.code === StreamSfuClient.ERROR_CONNECTION_BROKEN) return;\n                    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                        sfuClient.isFastReconnecting = this.reconnectAttempts === 0;\n                        const strategy = sfuClient.isFastReconnecting ? \"fast\" : \"full\";\n                        reconnect(strategy, `SFU closed the WS with code: ${e.code}`).catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: ${strategy} rejoin failed for ${this.reconnectAttempts} times. Giving up.`, err);\n                            this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                        });\n                    } else {\n                        this.logger(\"error\", \"[Rejoin]: Reconnect attempts exceeded. Giving up...\");\n                        this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    }\n                });\n            });\n            // handlers for connection online/offline events\n            const unsubscribeOnlineEvent = this.streamClient.on(\"connection.changed\", async (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (!e.online) return;\n                unsubscribeOnlineEvent();\n                const currentCallingState = this.state.callingState;\n                const shouldReconnect = currentCallingState === CallingState.OFFLINE || currentCallingState === CallingState.RECONNECTING_FAILED;\n                if (!shouldReconnect) return;\n                this.logger(\"info\", \"[Rejoin]: Going online...\");\n                let isFirstReconnectAttempt = true;\n                do {\n                    try {\n                        sfuClient.isFastReconnecting = isFirstReconnectAttempt;\n                        await reconnect(isFirstReconnectAttempt ? \"fast\" : \"full\", \"Network: online\");\n                        return; // break the loop if rejoin is successful\n                    } catch (err) {\n                        this.logger(\"error\", `[Rejoin][Network]: Rejoin failed for attempt ${this.reconnectAttempts}`, err);\n                    }\n                    // wait for a bit before trying to reconnect again\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    isFirstReconnectAttempt = false;\n                }while (this.reconnectAttempts < this.maxReconnectAttempts);\n                // if we're here, it means that we've exhausted all the reconnect attempts\n                this.logger(\"error\", `[Rejoin][Network]: Rejoin failed. Giving up.`);\n                this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n            });\n            const unsubscribeOfflineEvent = this.streamClient.on(\"connection.changed\", (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (e.online) return;\n                unsubscribeOfflineEvent();\n                this.state.setCallingState(CallingState.OFFLINE);\n            });\n            this.leaveCallHooks.add(()=>{\n                unsubscribeOnlineEvent();\n                unsubscribeOfflineEvent();\n            });\n            if (!this.subscriber) {\n                this.subscriber = new Subscriber({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig\n                });\n            }\n            if (!this.publisher) {\n                const audioSettings = this.state.settings?.audio;\n                const isDtxEnabled = !!audioSettings?.opus_dtx_enabled;\n                const isRedEnabled = !!audioSettings?.redundant_coding_enabled;\n                this.publisher = new Publisher({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig,\n                    isDtxEnabled,\n                    isRedEnabled\n                });\n            }\n            if (!this.statsReporter) {\n                this.statsReporter = createStatsReporter({\n                    subscriber: this.subscriber,\n                    publisher: this.publisher,\n                    state: this.state\n                });\n            }\n            const clientDetails = getClientDetails();\n            if (!this.sfuStatsReporter && statsOptions) {\n                this.sfuStatsReporter = new SfuStatsReporter(sfuClient, {\n                    clientDetails,\n                    options: statsOptions,\n                    subscriber: this.subscriber,\n                    publisher: this.publisher\n                });\n                this.sfuStatsReporter.start();\n            }\n            try {\n                // 1. wait for the signal server to be ready before sending \"joinRequest\"\n                sfuClient.signalReady.catch((err)=>this.logger(\"error\", \"Signal ready failed\", err))// prepare a generic SDP and send it to the SFU.\n                // this is a throw-away SDP that the SFU will use to determine\n                // the capabilities of the client (codec support, etc.)\n                .then(()=>getGenericSdp(\"recvonly\")).then((sdp)=>{\n                    const subscriptions = getCurrentValue(this.trackSubscriptionsSubject);\n                    const migration = isMigrating ? {\n                        fromSfuId: data?.migrating_from || \"\",\n                        subscriptions: subscriptions.data || [],\n                        announcedTracks: this.publisher?.getCurrentTrackInfos() || []\n                    } : undefined;\n                    return sfuClient.join({\n                        subscriberSdp: sdp || \"\",\n                        clientDetails,\n                        migration,\n                        fastReconnect: previousSfuClient?.isFastReconnecting ?? false\n                    });\n                });\n                // 2. in parallel, wait for the SFU to send us the \"joinResponse\"\n                // this will throw an error if the SFU rejects the join request or\n                // fails to respond in time\n                const { callState, reconnected } = await this.waitForJoinResponse();\n                if (isReconnecting) {\n                    this.logger(\"debug\", \"[Rejoin] fast reconnected:\", reconnected);\n                }\n                if (isMigrating) {\n                    await this.subscriber.migrateTo(sfuClient, connectionConfig);\n                    await this.publisher.migrateTo(sfuClient, connectionConfig);\n                } else if (isReconnecting) {\n                    if (reconnected) {\n                        // update the SFU client instance on the subscriber and publisher\n                        this.subscriber.setSfuClient(sfuClient);\n                        this.publisher.setSfuClient(sfuClient);\n                        // and perform a full ICE restart on the publisher\n                        await this.publisher.restartIce();\n                    } else if (previousSfuClient?.isFastReconnecting) {\n                        // reconnection wasn't possible, so we need to do a full rejoin\n                        return await reconnect(\"full\", \"re-attempting\").catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: Rejoin failed forced full rejoin.`, err);\n                        });\n                    }\n                }\n                const currentParticipants = callState?.participants || [];\n                const participantCount = callState?.participantCount;\n                const startedAt = callState?.startedAt ? Timestamp.toDate(callState.startedAt) : new Date();\n                const pins = callState?.pins ?? [];\n                this.state.setParticipants(()=>{\n                    const participantLookup = this.state.getParticipantLookupBySessionId();\n                    return currentParticipants.map((p)=>{\n                        // We need to preserve the local state of the participant\n                        // (e.g. videoDimension, visibilityState, pinnedAt, etc.)\n                        // as it doesn't exist on the server.\n                        const existingParticipant = participantLookup[p.sessionId];\n                        return Object.assign(p, existingParticipant, {\n                            isLocalParticipant: p.sessionId === sfuClient.sessionId,\n                            viewportVisibilityState: existingParticipant?.viewportVisibilityState ?? {\n                                videoTrack: VisibilityState.UNKNOWN,\n                                screenShareTrack: VisibilityState.UNKNOWN\n                            }\n                        });\n                    });\n                });\n                this.state.setParticipantCount(participantCount?.total || 0);\n                this.state.setAnonymousParticipantCount(participantCount?.anonymous || 0);\n                this.state.setStartedAt(startedAt);\n                this.state.setServerSidePins(pins);\n                this.reconnectAttempts = 0; // reset the reconnect attempts counter\n                this.state.setCallingState(CallingState.JOINED);\n                try {\n                    await this.initCamera({\n                        setStatus: true\n                    });\n                    await this.initMic({\n                        setStatus: true\n                    });\n                } catch (error) {\n                    this.logger(\"warn\", \"Camera and/or mic init failed during join call\", error);\n                }\n                // 3. once we have the \"joinResponse\", and possibly reconciled the local state\n                // we schedule a fast subscription update for all remote participants\n                // that were visible before we reconnected or migrated to a new SFU.\n                const { remoteParticipants } = this.state;\n                if (remoteParticipants.length > 0) {\n                    this.updateSubscriptions(remoteParticipants, DebounceType.FAST);\n                }\n                this.logger(\"info\", `Joined call ${this.cid}`);\n            } catch (err) {\n                // join failed, try to rejoin\n                if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                    this.logger(\"error\", `[Rejoin]: Rejoin ${this.reconnectAttempts} failed.`, err);\n                    await reconnect(\"full\", \"previous attempt failed\");\n                    this.logger(\"info\", `[Rejoin]: Rejoin ${this.reconnectAttempts} successful!`);\n                } else {\n                    this.logger(\"error\", `[Rejoin]: Rejoin failed for ${this.reconnectAttempts} times. Giving up.`);\n                    this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    throw new Error(\"Join failed\");\n                }\n            }\n        };\n        this.waitForJoinResponse = (timeout = 5000)=>{\n            return new Promise((resolve, reject)=>{\n                const unsubscribe = this.on(\"joinResponse\", (event)=>{\n                    clearTimeout(timeoutId);\n                    unsubscribe();\n                    resolve(event);\n                });\n                const timeoutId = setTimeout(()=>{\n                    unsubscribe();\n                    reject(new Error('Waiting for \"joinResponse\" has timed out'));\n                }, timeout);\n            });\n        };\n        /**\n         * Starts publishing the given video stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the previously published stream.\n         * The previous video stream will be stopped.\n         *\n         * @param videoStream the video stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishVideoStream = async (videoStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish video before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [videoTrack] = videoStream.getVideoTracks();\n            if (!videoTrack) {\n                this.logger(\"error\", `There is no video track to publish in the stream.`);\n                return;\n            }\n            await this.publisher.publishStream(videoStream, videoTrack, TrackType.VIDEO, opts);\n        };\n        /**\n         * Starts publishing the given audio stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the audio stream that is currently being published.\n         * The previous audio stream will be stopped.\n         *\n         * @param audioStream the audio stream to publish.\n         */ this.publishAudioStream = async (audioStream)=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish audio before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [audioTrack] = audioStream.getAudioTracks();\n            if (!audioTrack) {\n                this.logger(\"error\", `There is no audio track in the stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(audioStream, audioTrack, TrackType.AUDIO);\n        };\n        /**\n         * Starts publishing the given screen-share stream to the call.\n         *\n         * Consecutive calls to this method will replace the previous screen-share stream.\n         * The previous screen-share stream will be stopped.\n         *\n         * @param screenShareStream the screen-share stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishScreenShareStream = async (screenShareStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish screen share before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [screenShareTrack] = screenShareStream.getVideoTracks();\n            if (!screenShareTrack) {\n                this.logger(\"error\", `There is no video track in the screen share stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(screenShareStream, screenShareTrack, TrackType.SCREEN_SHARE, opts);\n            const [screenShareAudioTrack] = screenShareStream.getAudioTracks();\n            if (screenShareAudioTrack) {\n                await this.publisher.publishStream(screenShareStream, screenShareAudioTrack, TrackType.SCREEN_SHARE_AUDIO, opts);\n            }\n        };\n        /**\n         * Stops publishing the given track type to the call, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         *\n         * @param trackType the track type to stop publishing.\n         * @param stopTrack if `true` the track will be stopped, else it will be just disabled\n         */ this.stopPublish = async (trackType, stopTrack = true)=>{\n            this.logger(\"info\", `stopPublish ${TrackType[trackType]}, stop tracks: ${stopTrack}`);\n            await this.publisher?.unpublishStream(trackType, stopTrack);\n        };\n        /**\n         * Update track subscription configuration for one or more participants.\n         * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.\n         * You can only subscribe for tracks after the participant started publishing the given kind of track.\n         *\n         * @param trackType the kind of subscription to update.\n         * @param changes the list of subscription changes to do.\n         * @param type the debounce type to use for the update.\n         */ this.updateSubscriptionsPartial = (trackType, changes, type = DebounceType.SLOW)=>{\n            if (trackType === \"video\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'videoTrack'`);\n                trackType = \"videoTrack\";\n            } else if (trackType === \"screen\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'screenShareTrack'`);\n                trackType = \"screenShareTrack\";\n            }\n            const participants = this.state.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change])=>{\n                if (change.dimension?.height) {\n                    change.dimension.height = Math.ceil(change.dimension.height);\n                }\n                if (change.dimension?.width) {\n                    change.dimension.width = Math.ceil(change.dimension.width);\n                }\n                const prop = trackType === \"videoTrack\" ? \"videoDimension\" : trackType === \"screenShareTrack\" ? \"screenShareDimension\" : undefined;\n                if (prop) {\n                    acc[sessionId] = {\n                        [prop]: change.dimension\n                    };\n                }\n                return acc;\n            }, {}));\n            if (participants) {\n                this.updateSubscriptions(participants, type);\n            }\n        };\n        this.updateSubscriptions = (participants, type = DebounceType.SLOW)=>{\n            const subscriptions = [];\n            for (const p of participants){\n                // we don't want to subscribe to our own tracks\n                if (p.isLocalParticipant) continue;\n                // NOTE: audio tracks don't have to be requested explicitly\n                // as the SFU will implicitly subscribe us to all of them,\n                // once they become available.\n                if (p.videoDimension && p.publishedTracks.includes(TrackType.VIDEO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.VIDEO,\n                        dimension: p.videoDimension\n                    });\n                }\n                if (p.screenShareDimension && p.publishedTracks.includes(TrackType.SCREEN_SHARE)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE,\n                        dimension: p.screenShareDimension\n                    });\n                }\n                if (p.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE_AUDIO\n                    });\n                }\n            }\n            // schedule update\n            this.trackSubscriptionsSubject.next({\n                type,\n                data: subscriptions\n            });\n        };\n        /**\n         * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).\n         * This is usually helpful when detailed stats for a specific participant are needed.\n         *\n         * @param sessionId the sessionId to start reporting for.\n         */ this.startReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.startReportingStatsFor(sessionId);\n        };\n        /**\n         * Opposite of `startReportingStatsFor`.\n         * Will turn off stats reporting for a specific participant.\n         *\n         * @param sessionId the sessionId to stop reporting for.\n         */ this.stopReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.stopReportingStatsFor(sessionId);\n        };\n        /**\n         * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.\n         *\n         * @param sessionId the session id.\n         */ this.resetReaction = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                reaction: undefined\n            });\n        };\n        /**\n         * Sets the list of criteria to sort the participants by.\n         *\n         * @param criteria the list of criteria to sort the participants by.\n         */ this.setSortParticipantsBy = (criteria)=>{\n            return this.state.setSortParticipantsBy(criteria);\n        };\n        /**\n         * Updates the list of video layers to publish.\n         *\n         * @internal\n         * @param enabledLayers the list of layers to enable.\n         */ this.updatePublishQuality = async (enabledLayers)=>{\n            return this.publisher?.updateVideoPublishQuality(enabledLayers);\n        };\n        this.assertCallJoined = ()=>{\n            return new Promise((resolve)=>{\n                this.state.callingState$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((state)=>state !== CallingState.JOINED, true), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__.filter)((s)=>s === CallingState.JOINED)).subscribe(()=>resolve());\n            });\n        };\n        /**\n         * Sends a reaction to the other call participants.\n         *\n         * @param reaction the reaction to send.\n         */ this.sendReaction = async (reaction)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);\n        };\n        /**\n         * Blocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to block.\n         */ this.blockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/block`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Unblocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to unblock.\n         */ this.unblockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Mutes the current user.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteSelf = (type)=>{\n            const myUserId = this.currentUserId;\n            if (myUserId) {\n                return this.muteUser(myUserId, type);\n            }\n        };\n        /**\n         * Mutes all the other participants.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteOthers = (type)=>{\n            const trackType = muteTypeToTrackType(type);\n            if (!trackType) return;\n            const userIdsToMute = [];\n            for (const participant of this.state.remoteParticipants){\n                if (participant.publishedTracks.includes(trackType)) {\n                    userIdsToMute.push(participant.userId);\n                }\n            }\n            return this.muteUser(userIdsToMute, type);\n        };\n        /**\n         * Mutes the user with the given `userId`.\n         *\n         * @param userId the id of the user to mute.\n         * @param type the type of the mute operation.\n         */ this.muteUser = (userId, type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                user_ids: Array.isArray(userId) ? userId : [\n                    userId\n                ],\n                [type]: true\n            });\n        };\n        /**\n         * Will mute all users in the call.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteAllUsers = (type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                mute_all_users: true,\n                [type]: true\n            });\n        };\n        /**\n         * Starts recording the call\n         */ this.startRecording = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});\n        };\n        /**\n         * Stops recording the call\n         */ this.stopRecording = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});\n        };\n        /**\n         * Starts the transcription of the call.\n         *\n         * @param request the request data.\n         */ this.startTranscription = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_transcription`, request);\n        };\n        /**\n         * Stops the transcription of the call.\n         */ this.stopTranscription = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_transcription`);\n        };\n        /**\n         * Sends a `call.permission_request` event to all users connected to the call. The call settings object contains infomration about which permissions can be requested during a call (for example a user might be allowed to request permission to publish audio, but not video).\n         */ this.requestPermissions = async (data)=>{\n            const { permissions } = data;\n            const canRequestPermissions = permissions.every((permission)=>this.permissionsContext.canRequest(permission));\n            if (!canRequestPermissions) {\n                throw new Error(`You are not allowed to request permissions: ${permissions.join(\", \")}`);\n            }\n            return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);\n        };\n        /**\n         * Allows you to grant certain permissions to a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be granted are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to grant permissions to.\n         * @param permissions the permissions to grant.\n         */ this.grantPermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                grant_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to revoke certain permissions from a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be revoked are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to revoke permissions from.\n         * @param permissions the permissions to revoke.\n         */ this.revokePermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                revoke_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.\n         *\n         * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.\n         *\n         * `call.permissions_updated` event is sent to all members of the call.\n         *\n         */ this.updateUserPermissions = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);\n        };\n        /**\n         * Starts the livestreaming of the call.\n         *\n         * @param data the request data.\n         * @param params the request params.\n         */ this.goLive = async (data = {}, params)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);\n        };\n        /**\n         * Stops the livestreaming of the call.\n         */ this.stopLive = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, {});\n        };\n        /**\n         * Starts the broadcasting of the call.\n         */ this.startHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});\n        };\n        /**\n         * Stops the broadcasting of the call.\n         */ this.stopHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});\n        };\n        /**\n         * Updates the call settings or custom data.\n         *\n         * @param updates the updates to apply to the call.\n         */ this.update = async (updates)=>{\n            const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);\n            const { call, members, own_capabilities } = response;\n            this.state.updateFromCallResponse(call);\n            this.state.setMembers(members);\n            this.state.setOwnCapabilities(own_capabilities);\n            return response;\n        };\n        /**\n         * Ends the call. Once the call is ended, it cannot be re-joined.\n         */ this.endCall = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);\n        };\n        /**\n         * Pins the given session to the top of the participants list.\n         *\n         * @param sessionId the sessionId to pin.\n         */ this.pin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: {\n                    isLocalPin: true,\n                    pinnedAt: Date.now()\n                }\n            });\n        };\n        /**\n         * Unpins the given session from the top of the participants list.\n         *\n         * @param sessionId the sessionId to unpin.\n         */ this.unpin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: undefined\n            });\n        };\n        /**\n         * Pins the given session to the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.pinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);\n        };\n        /**\n         * Unpins the given session from the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.unpinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);\n        };\n        /**\n         * Query call members with filter query. The result won't be stored in call state.\n         * @param request\n         * @returns\n         */ this.queryMembers = (request)=>{\n            return this.streamClient.post(\"/call/members\", {\n                ...request || {},\n                id: this.id,\n                type: this.type\n            });\n        };\n        /**\n         * Will update the call members.\n         *\n         * @param data the request data.\n         */ this.updateCallMembers = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/members`, data);\n        };\n        /**\n         * Schedules an auto-drop timeout based on the call settings.\n         * Applicable only for ringing calls.\n         */ this.scheduleAutoDrop = ()=>{\n            clearTimeout(this.dropTimeout);\n            this.leaveCallHooks.add(createSubscription(this.state.settings$, (settings)=>{\n                if (!settings) return;\n                // ignore if the call is not ringing\n                if (this.state.callingState !== CallingState.RINGING) return;\n                const timeoutInMs = settings.ring.auto_cancel_timeout_ms;\n                // 0 means no auto-drop\n                if (timeoutInMs <= 0) return;\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = setTimeout(()=>{\n                    this.leave({\n                        reason: \"ring: timeout\"\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to drop call\", err);\n                    });\n                }, timeoutInMs);\n            }));\n        };\n        /**\n         * Retrieves the list of recordings for the current call or call session.\n         *\n         * If `callSessionId` is provided, it will return the recordings for that call session.\n         * Otherwise, all recordings for the current call will be returned.\n         *\n         * @param callSessionId the call session id to retrieve recordings for.\n         */ this.queryRecordings = async (callSessionId)=>{\n            let endpoint = this.streamClientBasePath;\n            if (callSessionId) {\n                endpoint = `${endpoint}/${callSessionId}`;\n            }\n            return this.streamClient.get(`${endpoint}/recordings`);\n        };\n        /**\n         * Retrieves the list of transcriptions for the current call.\n         *\n         * @returns the list of transcriptions.\n         */ this.queryTranscriptions = async ()=>{\n            return this.streamClient.get(`${this.streamClientBasePath}/transcriptions`);\n        };\n        /**\n         * Retrieve call statistics for a particular call session (historical).\n         * Here `callSessionID` is mandatory.\n         *\n         * @param callSessionID the call session ID to retrieve statistics for.\n         * @returns The call stats.\n         */ this.getCallStats = async (callSessionID)=>{\n            const endpoint = `${this.streamClientBasePath}/stats/${callSessionID}`;\n            return this.streamClient.get(endpoint);\n        };\n        /**\n         * Sends a custom event to all call participants.\n         *\n         * @param payload the payload to send.\n         */ this.sendCustomEvent = async (payload)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/event`, {\n                custom: payload\n            });\n        };\n        this.applyDeviceConfig = ()=>{\n            this.initCamera({\n                setStatus: false\n            });\n            this.initMic({\n                setStatus: false\n            });\n        };\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the video mode.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.dynascaleManager.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType = \"audioTrack\")=>{\n            const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).\n         *\n         * @param imageElement the image element to bind to.\n         * @param opts options for the binding.\n         */ this.bindCallThumbnailElement = (imageElement, opts = {})=>{\n            const handleError = ()=>{\n                imageElement.src = opts.fallbackImageSource || \"https://getstream.io/random_svg/?name=x&id=x\";\n            };\n            const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails)=>{\n                if (!thumbnails) return;\n                imageElement.addEventListener(\"error\", handleError);\n                const thumbnailUrl = new URL(thumbnails.image_url);\n                thumbnailUrl.searchParams.set(\"w\", String(imageElement.clientWidth));\n                thumbnailUrl.searchParams.set(\"h\", String(imageElement.clientHeight));\n                imageElement.src = thumbnailUrl.toString();\n            });\n            return ()=>{\n                unsubscribe();\n                imageElement.removeEventListener(\"error\", handleError);\n            };\n        };\n        this.type = type;\n        this.id = id;\n        this.cid = `${type}:${id}`;\n        this.ringingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(ringing);\n        this.watching = watching;\n        this.streamClient = streamClient;\n        this.clientStore = clientStore;\n        this.streamClientBasePath = `/call/${this.type}/${this.id}`;\n        this.logger = getLogger([\n            \"Call\"\n        ]);\n        const callTypeConfig = CallTypes.get(type);\n        const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;\n        if (participantSorter) {\n            this.state.setSortParticipantsBy(participantSorter);\n        }\n        this.state.setMembers(members || []);\n        this.state.setOwnCapabilities(ownCapabilities || []);\n        this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);\n        this.on(\"all\", (event)=>{\n            // update state with the latest event data\n            this.state.updateFromEvent(event);\n        });\n        this.leaveCallHooks.add(registerEventHandlers(this, this.state, this.dispatcher));\n        this.registerEffects();\n        this.leaveCallHooks.add(createSubscription(this.trackSubscriptionsSubject.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__.debounce)((v)=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__.timer)(v.type)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((v)=>v.data)), (subscriptions)=>this.sfuClient?.updateSubscriptions(subscriptions)));\n        this.camera = new CameraManager(this);\n        this.microphone = new MicrophoneManager(this);\n        this.speaker = new SpeakerManager(this);\n        this.screenShare = new ScreenShareManager(this);\n    }\n    registerEffects() {\n        this.leaveCallHooks.add(// handles updating the permissions context when the settings change.\n        createSubscription(this.state.settings$, (settings)=>{\n            if (!settings) return;\n            this.permissionsContext.setCallSettings(settings);\n        }));\n        this.leaveCallHooks.add(// handle the case when the user permissions are modified.\n        createSubscription(this.state.ownCapabilities$, (ownCapabilities)=>{\n            // update the permission context.\n            this.permissionsContext.setPermissions(ownCapabilities);\n            if (!this.publisher) return;\n            // check if the user still has publishing permissions and stop publishing if not.\n            const permissionToTrackType = {\n                [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,\n                [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,\n                [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE\n            };\n            for (const [permission, trackType] of Object.entries(permissionToTrackType)){\n                const hasPermission = this.permissionsContext.hasPermission(permission);\n                if (!hasPermission && (this.publisher.isPublishing(trackType) || this.publisher.isLive(trackType))) {\n                    // Stop tracks, then notify device manager\n                    this.stopPublish(trackType).catch((err)=>{\n                        this.logger(\"error\", `Error stopping publish ${trackType}`, err);\n                    }).then(()=>{\n                        if (trackType === TrackType.VIDEO && this.camera.state.status === \"enabled\") {\n                            this.camera.disable().catch((err)=>this.logger(\"error\", `Error disabling camera after permission revoked`, err));\n                        }\n                        if (trackType === TrackType.AUDIO && this.microphone.state.status === \"enabled\") {\n                            this.microphone.disable().catch((err)=>this.logger(\"error\", `Error disabling microphone after permission revoked`, err));\n                        }\n                    });\n                }\n            }\n        }));\n        this.leaveCallHooks.add(// handles the case when the user is blocked by the call owner.\n        createSubscription(this.state.blockedUserIds$, async (blockedUserIds)=>{\n            if (!blockedUserIds || blockedUserIds.length === 0) return;\n            const currentUserId = this.currentUserId;\n            if (currentUserId && blockedUserIds.includes(currentUserId)) {\n                this.logger(\"info\", \"Leaving call because of being blocked\");\n                await this.leave({\n                    reason: \"user blocked\"\n                });\n            }\n        }));\n        this.leaveCallHooks.add(// watch for auto drop cancellation\n        createSubscription(this.state.callingState$, (callingState)=>{\n            if (!this.ringing) return;\n            if (callingState === CallingState.JOINED || callingState === CallingState.JOINING || callingState === CallingState.LEFT) {\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = undefined;\n            }\n        }));\n        this.leaveCallHooks.add(// \"ringing\" mode effects and event handlers\n        createSubscription(this.ringingSubject, (isRinging)=>{\n            if (!isRinging) return;\n            this.scheduleAutoDrop();\n            if (this.state.callingState === CallingState.IDLE) {\n                this.state.setCallingState(CallingState.RINGING);\n            }\n            this.leaveCallHooks.add(registerRingingCallEventHandlers(this));\n        }));\n    }\n    /**\n     * A flag indicating whether the call is \"ringing\" type of call.\n     */ get ringing() {\n        return getCurrentValue(this.ringingSubject);\n    }\n    /**\n     * Retrieves the current user ID.\n     */ get currentUserId() {\n        return this.clientStore.connectedUser?.id;\n    }\n    /**\n     * A flag indicating whether the call was created by the current user.\n     */ get isCreatedByMe() {\n        return this.state.createdBy?.id === this.currentUserId;\n    }\n    async initCamera(options) {\n        // Wait for any in progress camera operation\n        if (this.camera.enablePromise) {\n            await this.camera.enablePromise;\n        }\n        if (this.camera.disablePromise) {\n            await this.camera.disablePromise;\n        }\n        if (this.state.localParticipant?.videoStream || !this.permissionsContext.hasPermission(\"send-video\")) {\n            return;\n        }\n        // Set camera direction if it's not yet set\n        if (!this.camera.state.direction && !this.camera.state.selectedDevice) {\n            let defaultDirection = \"front\";\n            const backendSetting = this.state.settings?.video.camera_facing;\n            if (backendSetting) {\n                defaultDirection = backendSetting === \"front\" ? \"front\" : \"back\";\n            }\n            this.camera.state.setDirection(defaultDirection);\n        }\n        // Set target resolution\n        const targetResolution = this.state.settings?.video.target_resolution;\n        if (targetResolution) {\n            await this.camera.selectTargetResolution(targetResolution);\n        }\n        if (options.setStatus) {\n            // Publish already that was set before we joined\n            if (this.camera.state.status === \"enabled\" && this.camera.state.mediaStream && !this.publisher?.isPublishing(TrackType.VIDEO)) {\n                await this.publishVideoStream(this.camera.state.mediaStream, {\n                    preferredCodec: this.camera.preferredCodec\n                });\n            }\n            // Start camera if backend config specifies, and there is no local setting\n            if (this.camera.state.status === undefined && this.state.settings?.video.camera_default_on) {\n                await this.camera.enable();\n            }\n        }\n    }\n    async initMic(options) {\n        // Wait for any in progress mic operation\n        if (this.microphone.enablePromise) {\n            await this.microphone.enablePromise;\n        }\n        if (this.microphone.disablePromise) {\n            await this.microphone.disablePromise;\n        }\n        if (this.state.localParticipant?.audioStream || !this.permissionsContext.hasPermission(\"send-audio\")) {\n            return;\n        }\n        if (options.setStatus) {\n            // Publish media stream that was set before we joined\n            if (this.microphone.state.status === \"enabled\" && this.microphone.state.mediaStream && !this.publisher?.isPublishing(TrackType.AUDIO)) {\n                await this.publishAudioStream(this.microphone.state.mediaStream);\n            }\n            // Start mic if backend config specifies, and there is no local setting\n            if (this.microphone.state.status === undefined && this.state.settings?.audio.mic_default_on) {\n                await this.microphone.enable();\n            }\n        }\n    }\n}\nclass InsightMetrics {\n    constructor(){\n        this.connectionStartTimestamp = null;\n        this.wsTotalFailures = 0;\n        this.wsConsecutiveFailures = 0;\n        this.instanceClientId = randomId();\n    }\n}\n/**\n * postInsights is not supposed to be used by end users directly within chat application, and thus is kept isolated\n * from all the client/connection code/logic.\n *\n * @param insightType\n * @param insights\n */ const postInsights = async (insightType, insights)=>{\n    const maxAttempts = 3;\n    for(let i = 0; i < maxAttempts; i++){\n        try {\n            await axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].post(`https://chat-insights.getstream.io/insights/${insightType}`, insights);\n        } catch (e) {\n            await sleep((i + 1) * 3000);\n            continue;\n        }\n        break;\n    }\n};\nfunction buildWsFatalInsight(connection, event) {\n    return {\n        ...event,\n        ...buildWsBaseInsight(connection)\n    };\n}\nfunction buildWsBaseInsight(connection) {\n    const { client } = connection;\n    return {\n        ready_state: connection.ws?.readyState,\n        url: connection._buildUrl(),\n        api_key: client.key,\n        start_ts: client.insightMetrics.connectionStartTimestamp,\n        end_ts: new Date().getTime(),\n        auth_type: client.getAuthType(),\n        token: client.tokenManager.token,\n        user_id: client.userID,\n        user_details: client._user,\n        // device: client.options.device,\n        device: \"browser\",\n        client_id: connection.connectionID,\n        ws_details: connection.ws,\n        ws_consecutive_failures: client.insightMetrics.wsConsecutiveFailures,\n        ws_total_failures: client.insightMetrics.wsTotalFailures,\n        request_id: connection.requestID,\n        online: typeof navigator !== \"undefined\" ? navigator?.onLine : null,\n        user_agent: typeof navigator !== \"undefined\" ? navigator?.userAgent : null,\n        instance_client_id: client.insightMetrics.instanceClientId\n    };\n}\nfunction buildWsSuccessAfterFailureInsight(connection) {\n    return buildWsBaseInsight(connection);\n}\n// Type guards to check WebSocket error type\nconst isCloseEvent = (res)=>res.code !== undefined;\nconst isErrorEvent = (res)=>res.error !== undefined;\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */ class StableWSConnection {\n    constructor(client){\n        this._log = (msg, extra = {}, level = \"info\")=>{\n            this.client.logger(level, \"connection:\" + msg, {\n                ...extra\n            });\n        };\n        this.setClient = (client)=>{\n            this.client = client;\n        };\n        /**\n         * Builds and returns the url for websocket.\n         * @private\n         * @returns url string\n         */ this._buildUrl = ()=>{\n            const params = new URLSearchParams();\n            // const qs = encodeURIComponent(this.client._buildWSPayload(this.requestID));\n            // params.set('json', qs);\n            params.set(\"api_key\", this.client.key);\n            params.set(\"stream-auth-type\", this.client.getAuthType());\n            params.set(\"X-Stream-Client\", this.client.getUserAgent());\n            // params.append('authorization', this.client._getToken()!);\n            return `${this.client.wsBaseURL}/connect?${params.toString()}`;\n        };\n        /**\n         * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n         *\n         * @param {Event} event Event with type online or offline\n         *\n         */ this.onlineStatusChanged = (event)=>{\n            if (event.type === \"offline\") {\n                // mark the connection as down\n                this._log(\"onlineStatusChanged() - Status changing to offline\");\n                // we know that the app is offline so dispatch the unhealthy connection event immediately\n                this._setHealth(false, true);\n            } else if (event.type === \"online\") {\n                // retry right now...\n                // We check this.isHealthy, not sure if it's always\n                // smart to create a new WS connection if the old one is still up and running.\n                // it's possible we didn't miss any messages, so this process is just expensive and not needed.\n                this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);\n                if (!this.isHealthy) {\n                    this._reconnect({\n                        interval: 10\n                    });\n                }\n            }\n        };\n        this.onopen = (wsID)=>{\n            if (this.wsID !== wsID) return;\n            const user = this.client.user;\n            if (!user) {\n                this.client.logger(\"error\", `User not set, can't connect to WS`);\n                return;\n            }\n            const token = this.client._getToken();\n            if (!token) {\n                this.client.logger(\"error\", `Token not set, can't connect authenticate`);\n                return;\n            }\n            const authMessage = {\n                token,\n                user_details: {\n                    id: user.id,\n                    name: user.name,\n                    image: user.image,\n                    custom: user.custom\n                }\n            };\n            this.authenticationSent = true;\n            this.ws?.send(JSON.stringify(authMessage));\n            this._log(\"onopen() - onopen callback\", {\n                wsID\n            });\n        };\n        this.onmessage = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onmessage() - onmessage callback\", {\n                event,\n                wsID\n            });\n            const data = typeof event.data === \"string\" ? JSON.parse(event.data) : null;\n            // we wait till the first message before we consider the connection open.\n            // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n            // after that a ws.onclose.\n            if (!this.isResolved && data && data.type === \"connection.error\") {\n                this.isResolved = true;\n                if (data.error) {\n                    // @ts-expect-error - the types of _errorFromWSEvent are incorrect\n                    this.rejectPromise?.(this._errorFromWSEvent(data, false));\n                    return;\n                }\n            }\n            // trigger the event..\n            this.lastEvent = new Date();\n            if (data && (data.type === \"health.check\" || data.type === \"connection.ok\")) {\n                // the initial health-check should come from the client\n                this.scheduleNextPing();\n            }\n            if (data && data.type === \"connection.ok\") {\n                this.resolvePromise?.(data);\n                this._setHealth(true);\n            }\n            if (data && data.type === \"connection.error\" && data.error) {\n                const { code } = data.error;\n                this.isHealthy = false;\n                this.isConnecting = false;\n                this.consecutiveFailures += 1;\n                if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                    clearTimeout(this.connectionCheckTimeoutRef);\n                    this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                    this._reconnect({\n                        refreshToken: true\n                    });\n                }\n            }\n            if (data) {\n                this.client.dispatchEvent(data);\n            }\n            this.scheduleConnectionCheck();\n        };\n        this.onclose = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onclose() - onclose callback - \" + event.code, {\n                event,\n                wsID\n            });\n            if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {\n                // this is a permanent error raised by stream..\n                // usually caused by invalid auth details\n                const error = new Error(`WS connection reject with error ${event.reason}`);\n                error.reason = event.reason;\n                error.code = event.code;\n                error.wasClean = event.wasClean;\n                error.target = event.target;\n                this.rejectPromise?.(error);\n                this._log(`onclose() - WS connection reject with error ${event.reason}`, {\n                    event\n                });\n            } else {\n                this.consecutiveFailures += 1;\n                this.totalFailures += 1;\n                this._setHealth(false);\n                this.isConnecting = false;\n                this.rejectPromise?.(this._errorFromWSEvent(event));\n                this._log(`onclose() - WS connection closed. Calling reconnect ...`, {\n                    event\n                });\n                // reconnect if its an abnormal failure\n                this._reconnect();\n            }\n        };\n        this.onerror = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this.consecutiveFailures += 1;\n            this.totalFailures += 1;\n            this._setHealth(false);\n            this.isConnecting = false;\n            this.rejectPromise?.(this._errorFromWSEvent(event));\n            this._log(`onerror() - WS connection resulted into error`, {\n                event\n            });\n            this._reconnect();\n        };\n        /**\n         * _setHealth - Sets the connection to healthy or unhealthy.\n         * Broadcasts an event in case the connection status changed.\n         *\n         * @param {boolean} healthy boolean indicating if the connection is healthy or not\n         * @param {boolean} dispatchImmediately boolean indicating to dispatch event immediately even if the connection is unhealthy\n         *\n         */ this._setHealth = (healthy, dispatchImmediately = false)=>{\n            if (healthy === this.isHealthy) return;\n            this.isHealthy = healthy;\n            if (this.isHealthy || dispatchImmediately) {\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n                return;\n            }\n            // we're offline, wait few seconds and fire and event if still offline\n            setTimeout(()=>{\n                if (this.isHealthy) return;\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n            }, 5000);\n        };\n        /**\n         * _errorFromWSEvent - Creates an error object for the WS event\n         *\n         */ this._errorFromWSEvent = (event, isWSFailure = true)=>{\n            let code;\n            let statusCode;\n            let message;\n            if (isCloseEvent(event)) {\n                code = event.code;\n                statusCode = \"unknown\";\n                message = event.reason;\n            }\n            if (isErrorEvent(event)) {\n                code = event.error.code;\n                statusCode = event.error.StatusCode;\n                message = event.error.message;\n            }\n            // Keeping this `warn` level log, to avoid cluttering of error logs from ws failures.\n            this._log(`_errorFromWSEvent() - WS failed with code ${code}`, {\n                event\n            }, \"warn\");\n            const error = new Error(`WS failed with code ${code} and reason - ${message}`);\n            error.code = code;\n            /**\n             * StatusCode does not exist on any event types but has been left\n             * as is to preserve JS functionality during the TS implementation\n             */ error.StatusCode = statusCode;\n            error.isWSFailure = isWSFailure;\n            return error;\n        };\n        /**\n         * _setupPromise - sets up the this.connectOpen promise\n         */ this._setupConnectionPromise = ()=>{\n            this.isResolved = false;\n            /** a promise that is resolved once ws.open is called */ this.connectionOpen = new Promise((resolve, reject)=>{\n                this.resolvePromise = resolve;\n                this.rejectPromise = reject;\n            });\n        };\n        /**\n         * Schedules a next health check ping for websocket.\n         */ this.scheduleNextPing = ()=>{\n            if (this.healthCheckTimeoutRef) {\n                clearTimeout(this.healthCheckTimeoutRef);\n            }\n            // 30 seconds is the recommended interval (messenger uses this)\n            this.healthCheckTimeoutRef = setTimeout(()=>{\n                // send the healthcheck..., server replies with a health check event\n                const data = [\n                    {\n                        type: \"health.check\",\n                        client_id: this.client.clientID\n                    }\n                ];\n                // try to send on the connection\n                try {\n                    this.ws?.send(JSON.stringify(data));\n                } catch (e) {\n                // error will already be detected elsewhere\n                }\n            }, this.pingInterval);\n        };\n        /**\n         * scheduleConnectionCheck - schedules a check for time difference between last received event and now.\n         * If the difference is more than 35 seconds, it means our health check logic has failed and websocket needs\n         * to be reconnected.\n         */ this.scheduleConnectionCheck = ()=>{\n            if (this.connectionCheckTimeoutRef) {\n                clearTimeout(this.connectionCheckTimeoutRef);\n            }\n            this.connectionCheckTimeoutRef = setTimeout(()=>{\n                const now = new Date();\n                if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {\n                    this._log(\"scheduleConnectionCheck - going to reconnect\");\n                    this._setHealth(false);\n                    this._reconnect();\n                }\n            }, this.connectionCheckTimeout);\n        };\n        this.client = client;\n        /** consecutive failures influence the duration of the timeout */ this.consecutiveFailures = 0;\n        /** keep track of the total number of failures */ this.totalFailures = 0;\n        /** We only make 1 attempt to reconnect at the same time.. */ this.isConnecting = false;\n        /** True after the auth payload is sent to the server */ this.authenticationSent = false;\n        /** To avoid reconnect if client is disconnected */ this.isDisconnected = false;\n        /** Boolean that indicates if the connection promise is resolved */ this.isResolved = false;\n        /** Boolean that indicates if we have a working connection to the server */ this.isHealthy = false;\n        /** Incremented when a new WS connection is made */ this.wsID = 1;\n        /** Store the last event time for health checks */ this.lastEvent = null;\n        /** Send a health check message every 25 seconds */ this.pingInterval = 25 * 1000;\n        this.connectionCheckTimeout = this.pingInterval + 10 * 1000;\n        addConnectionEventListeners(this.onlineStatusChanged);\n    }\n    /**\n     * connect - Connect to the WS URL\n     * the default 15s timeout allows between 2~3 tries\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async connect(timeout = 15000) {\n        if (this.isConnecting) {\n            throw Error(`You've called connect twice, can only attempt 1 connection at the time`);\n        }\n        this.isDisconnected = false;\n        try {\n            const healthCheck = await this._connect();\n            this.consecutiveFailures = 0;\n            this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (// @ts-ignore\n            error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                this._reconnect({\n                    refreshToken: true\n                });\n            } else {\n                // @ts-ignore\n                if (!error.isWSFailure) {\n                    // API rejected the connection and we should not retry\n                    throw new Error(JSON.stringify({\n                        // @ts-ignore\n                        code: error.code,\n                        // @ts-ignore\n                        StatusCode: error.StatusCode,\n                        // @ts-ignore\n                        message: error.message,\n                        // @ts-ignore\n                        isWSFailure: error.isWSFailure\n                    }));\n                }\n            }\n        }\n        return await this._waitForHealthy(timeout);\n    }\n    /**\n     * _waitForHealthy polls the promise connection to see if its resolved until it times out\n     * the default 15s timeout allows between 2~3 tries\n     * @param timeout duration(ms)\n     */ async _waitForHealthy(timeout = 15000) {\n        return Promise.race([\n            (async ()=>{\n                const interval = 50; // ms\n                for(let i = 0; i <= timeout; i += interval){\n                    try {\n                        return await this.connectionOpen;\n                    } catch (error) {\n                        if (i === timeout) {\n                            throw new Error(JSON.stringify({\n                                code: error.code,\n                                StatusCode: error.StatusCode,\n                                message: error.message,\n                                isWSFailure: error.isWSFailure\n                            }));\n                        }\n                        await sleep(interval);\n                    }\n                }\n            })(),\n            (async ()=>{\n                await sleep(timeout);\n                this.isConnecting = false;\n                throw new Error(JSON.stringify({\n                    code: \"\",\n                    StatusCode: \"\",\n                    message: \"initial WS connection could not be established\",\n                    isWSFailure: true\n                }));\n            })()\n        ]);\n    }\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */ disconnect(timeout) {\n        this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);\n        this.wsID += 1;\n        this.isConnecting = false;\n        this.isDisconnected = true;\n        // start by removing all the listeners\n        if (this.healthCheckTimeoutRef) {\n            clearInterval(this.healthCheckTimeoutRef);\n        }\n        if (this.connectionCheckTimeoutRef) {\n            clearInterval(this.connectionCheckTimeoutRef);\n        }\n        removeConnectionEventListeners(this.onlineStatusChanged);\n        this.isHealthy = false;\n        // remove ws handlers...\n        if (this.ws && this.ws.removeAllListeners) {\n            this.ws.removeAllListeners();\n        }\n        let isClosedPromise;\n        // and finally close...\n        // Assigning to local here because we will remove it from this before the\n        // promise resolves.\n        const { ws } = this;\n        if (ws && ws.close && ws.readyState === ws.OPEN) {\n            isClosedPromise = new Promise((resolve)=>{\n                const onclose = (event)=>{\n                    this._log(`disconnect() - resolving isClosedPromise ${event ? \"with\" : \"without\"} close frame`, {\n                        event\n                    });\n                    resolve();\n                };\n                ws.onclose = onclose;\n                // In case we don't receive close frame websocket server in time,\n                // lets not wait for more than 1 second.\n                setTimeout(onclose, timeout != null ? timeout : 1000);\n            });\n            this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);\n            ws.close(KnownCodes.WS_CLOSED_SUCCESS, \"Manually closed connection by calling client.disconnect()\");\n        } else {\n            this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);\n            isClosedPromise = Promise.resolve();\n        }\n        delete this.ws;\n        return isClosedPromise;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async _connect() {\n        if (this.isConnecting || this.isDisconnected && this.client.options.enableWSFallback) return; // simply ignore _connect if it's currently trying to connect\n        this.isConnecting = true;\n        this.requestID = randomId();\n        this.client.insightMetrics.connectionStartTimestamp = new Date().getTime();\n        let isTokenReady = false;\n        try {\n            this._log(`_connect() - waiting for token`);\n            await this.client.tokenManager.tokenReady();\n            isTokenReady = true;\n        } catch (e) {\n        // token provider has failed before, so try again\n        }\n        try {\n            if (!isTokenReady) {\n                this._log(`_connect() - tokenProvider failed before, so going to retry`);\n                await this.client.tokenManager.loadToken();\n            }\n            this._setupConnectionPromise();\n            const wsURL = this._buildUrl();\n            this._log(`_connect() - Connecting to ${wsURL}`, {\n                wsURL,\n                requestID: this.requestID\n            });\n            this.ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(wsURL);\n            this.ws.onopen = this.onopen.bind(this, this.wsID);\n            this.ws.onclose = this.onclose.bind(this, this.wsID);\n            this.ws.onerror = this.onerror.bind(this, this.wsID);\n            this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n            const response = await this.connectionOpen;\n            this.isConnecting = false;\n            if (response) {\n                this.connectionID = response.connection_id;\n                this.client.resolveConnectionId?.(this.connectionID);\n                if (this.client.insightMetrics.wsConsecutiveFailures > 0 && this.client.options.enableInsights) {\n                    postInsights(\"ws_success_after_failure\", buildWsSuccessAfterFailureInsight(this));\n                    this.client.insightMetrics.wsConsecutiveFailures = 0;\n                }\n                return response;\n            }\n        } catch (err) {\n            this.isConnecting = false;\n            // @ts-ignore\n            this._log(`_connect() - Error - `, err);\n            if (this.client.options.enableInsights) {\n                this.client.insightMetrics.wsConsecutiveFailures++;\n                this.client.insightMetrics.wsTotalFailures++;\n                const insights = buildWsFatalInsight(this, convertErrorToJson(err));\n                postInsights?.(\"ws_fatal\", insights);\n            }\n            this.client.rejectConnectionId?.();\n            throw err;\n        }\n    }\n    /**\n     * _reconnect - Retry the connection to WS endpoint\n     *\n     * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available\n     *\n     * - `interval`\t{int}\t\t\tnumber of ms that function should wait before reconnecting\n     * - `refreshToken` {boolean}\treload/refresh user token be refreshed before attempting reconnection.\n     */ async _reconnect(options = {}) {\n        this._log(\"_reconnect() - Initiating the reconnect\");\n        // only allow 1 connection at the time\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (1) since already connecting or healthy\");\n            return;\n        }\n        // reconnect in case of on error or on close\n        // also reconnect if the health check cycle fails\n        let interval = options.interval;\n        if (!interval) {\n            interval = retryInterval(this.consecutiveFailures);\n        }\n        // reconnect, or try again after a little while...\n        await sleep(interval);\n        // Check once again if by some other call to _reconnect is active or connection is\n        // already restored, then no need to proceed.\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (2) since already connecting or healthy\");\n            return;\n        }\n        if (this.isDisconnected && this.client.options.enableWSFallback) {\n            this._log(\"_reconnect() - Abort (3) since disconnect() is called\");\n            return;\n        }\n        this._log(\"_reconnect() - Destroying current WS connection\");\n        // cleanup the old connection\n        this._destroyCurrentWSConnection();\n        if (options.refreshToken) {\n            await this.client.tokenManager.loadToken();\n        }\n        try {\n            await this._connect();\n            this._log(\"_reconnect() - Waiting for recoverCallBack\");\n            // await this.client.recoverState();\n            this._log(\"_reconnect() - Finished recoverCallBack\");\n            this.consecutiveFailures = 0;\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                return this._reconnect({\n                    refreshToken: true\n                });\n            }\n            // reconnect on WS failures, don't reconnect if there is a code bug\n            if (error.isWSFailure) {\n                this._log(\"_reconnect() - WS failure, so going to try to reconnect\");\n                this._reconnect();\n            }\n        }\n        this._log(\"_reconnect() - == END ==\");\n    }\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connection\n     *\n     */ _destroyCurrentWSConnection() {\n        // increment the ID, meaning we will ignore all messages from the old\n        // ws connection from now on.\n        this.wsID += 1;\n        try {\n            this?.ws?.removeAllListeners();\n            this?.ws?.close();\n        } catch (e) {\n        // we don't care\n        }\n    }\n}\nfunction isString(arrayOrString) {\n    return typeof arrayOrString === \"string\";\n}\nfunction isMapStringCallback(arrayOrString, callback) {\n    return !!callback && isString(arrayOrString);\n}\nfunction map(arrayOrString, callback) {\n    const res = [];\n    if (isString(arrayOrString) && isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (arrayOrString.charAt(k)) {\n                const kValue = arrayOrString.charAt(k);\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    } else if (!isString(arrayOrString) && !isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (k in arrayOrString) {\n                const kValue = arrayOrString[k];\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    }\n    return res;\n}\nconst encodeBase64 = (data)=>(0,base64_js__WEBPACK_IMPORTED_MODULE_8__.fromByteArray)(new Uint8Array(map(data, (char)=>char.charCodeAt(0))));\n// base-64 decoder throws exception if encoded string is not padded by '=' to make string length\n// in multiples of 4. So gonna use our own method for this purpose to keep backwards compatibility\n// https://github.com/beatgammit/base64-js/blob/master/index.js#L26\nconst decodeBase64 = (s)=>{\n    const e = {}, w = String.fromCharCode, L = s.length;\n    let i, b = 0, c, x, l = 0, a, r = \"\";\n    const A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(i = 0; i < 64; i++){\n        e[A.charAt(i)] = i;\n    }\n    for(x = 0; x < L; x++){\n        c = e[s.charAt(x)];\n        b = (b << 6) + c;\n        l += 6;\n        while(l >= 8){\n            ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n        }\n    }\n    return r;\n};\n/**\n * Creates the JWT token that can be used for a UserSession\n * @method JWTUserToken\n * @memberof signing\n * @private\n * @param {Secret} apiSecret - API Secret key\n * @param {string} userId - The user_id key in the JWT payload\n * @param {UR} [extraData] - Extra that should be part of the JWT token\n * @param {SignOptions} [jwtOptions] - Options that can be past to jwt.sign\n * @return {string} JWT Token\n */ function JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== \"string\") {\n        throw new TypeError(\"userId should be a string\");\n    }\n    const payload = {\n        user_id: userId,\n        ...extraData\n    };\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true\n    };\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction UserFromToken(token) {\n    const fragments = token.split(\".\");\n    if (fragments.length !== 3) {\n        return \"\";\n    }\n    const b64Payload = fragments[1];\n    const payload = decodeBase64(b64Payload);\n    const data = JSON.parse(payload);\n    return data.user_id;\n}\n/**\n *\n * @param {string} userId the id of the user\n * @return {string}\n */ function DevToken(userId) {\n    return [\n        \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n        encodeBase64(JSON.stringify({\n            user_id: userId\n        })),\n        \"devtoken\"\n    ].join(\".\");\n}\n/**\n * TokenManager\n *\n * Handles all the operations around user token.\n */ class TokenManager {\n    /**\n     * Constructor\n     *\n     * @param {Secret} secret\n     */ constructor(secret){\n        /**\n         * Set the static string token or token provider.\n         * Token provider should return a token string or a promise which resolves to string token.\n         *\n         * @param {TokenOrProvider} tokenOrProvider - the token or token provider.\n         * @param {UserResponse} user - the user object.\n         * @param {boolean} isAnonymous - whether the user is anonymous or not.\n         */ this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous)=>{\n            this.validateToken(tokenOrProvider, user, isAnonymous);\n            this.user = user;\n            if (isFunction(tokenOrProvider)) {\n                this.tokenProvider = tokenOrProvider;\n                this.type = \"provider\";\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                this.token = tokenOrProvider;\n                this.type = \"static\";\n            }\n            if (!tokenOrProvider && this.user && this.secret) {\n                this.token = JWTUserToken(this.secret, user.id, {}, {});\n                this.type = \"static\";\n            }\n            await this.loadToken();\n        };\n        /**\n         * Resets the token manager.\n         * Useful for client disconnection or switching user.\n         */ this.reset = ()=>{\n            this.token = undefined;\n            this.user = undefined;\n            this.loadTokenPromise = null;\n        };\n        // Validates the user token.\n        this.validateToken = (tokenOrProvider, user, isAnonymous)=>{\n            // allow empty token for anon user\n            if (user && isAnonymous && !tokenOrProvider) return;\n            // Don't allow empty token for non-server side client.\n            if (!this.secret && !tokenOrProvider) {\n                throw new Error(\"UserWithId token can not be empty\");\n            }\n            if (tokenOrProvider && typeof tokenOrProvider !== \"string\" && !isFunction(tokenOrProvider)) {\n                throw new Error(\"user token should either be a string or a function\");\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                // Allow empty token for anonymous users\n                if (isAnonymous && tokenOrProvider === \"\") return;\n                const tokenUserId = UserFromToken(tokenOrProvider);\n                if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === \"\" || !isAnonymous && tokenUserId !== user.id)) {\n                    throw new Error(\"userToken does not have a user_id or is not matching with user.id\");\n                }\n            }\n        };\n        // Resolves when token is ready. This function is simply to check if loadToken is in progress, in which\n        // case a function should wait.\n        this.tokenReady = ()=>this.loadTokenPromise;\n        // Fetches a token from tokenProvider function and sets in tokenManager.\n        // In case of static token, it will simply resolve to static token.\n        this.loadToken = ()=>{\n            // eslint-disable-next-line no-async-promise-executor\n            this.loadTokenPromise = new Promise(async (resolve, reject)=>{\n                if (this.type === \"static\") {\n                    return resolve(this.token);\n                }\n                if (this.tokenProvider && typeof this.tokenProvider !== \"string\") {\n                    try {\n                        this.token = await this.tokenProvider();\n                    } catch (e) {\n                        return reject(new Error(`Call to tokenProvider failed with message: ${e}`));\n                    }\n                    resolve(this.token);\n                }\n            });\n            return this.loadTokenPromise;\n        };\n        // Returns a current token\n        this.getToken = ()=>{\n            if (this.token) {\n                return this.token;\n            }\n            if (this.user && !this.token) {\n                return this.token;\n            }\n            if (this.secret) {\n                return JWTServerToken(this.secret);\n            }\n            throw new Error(`Both secret and user tokens are not set. Either client.connectUser wasn't called or client.disconnect was called`);\n        };\n        this.isStatic = ()=>this.type === \"static\";\n        this.loadTokenPromise = null;\n        if (secret) {\n            this.secret = secret;\n        }\n        this.type = \"static\";\n        if (this.secret) {\n            this.token = JWTServerToken(this.secret);\n        }\n    }\n}\nconst APIErrorCodes = {\n    \"-1\": {\n        name: \"InternalSystemError\",\n        retryable: true\n    },\n    \"2\": {\n        name: \"AccessKeyError\",\n        retryable: false\n    },\n    \"3\": {\n        name: \"AuthenticationFailedError\",\n        retryable: true\n    },\n    \"4\": {\n        name: \"InputError\",\n        retryable: false\n    },\n    \"6\": {\n        name: \"DuplicateUsernameError\",\n        retryable: false\n    },\n    \"9\": {\n        name: \"RateLimitError\",\n        retryable: true\n    },\n    \"16\": {\n        name: \"DoesNotExistError\",\n        retryable: false\n    },\n    \"17\": {\n        name: \"NotAllowedError\",\n        retryable: false\n    },\n    \"18\": {\n        name: \"EventNotSupportedError\",\n        retryable: false\n    },\n    \"19\": {\n        name: \"ChannelFeatureNotSupportedError\",\n        retryable: false\n    },\n    \"20\": {\n        name: \"MessageTooLongError\",\n        retryable: false\n    },\n    \"21\": {\n        name: \"MultipleNestingLevelError\",\n        retryable: false\n    },\n    \"22\": {\n        name: \"PayloadTooBigError\",\n        retryable: false\n    },\n    \"23\": {\n        name: \"RequestTimeoutError\",\n        retryable: true\n    },\n    \"24\": {\n        name: \"MaxHeaderSizeExceededError\",\n        retryable: false\n    },\n    \"40\": {\n        name: \"AuthErrorTokenExpired\",\n        retryable: false\n    },\n    \"41\": {\n        name: \"AuthErrorTokenNotValidYet\",\n        retryable: false\n    },\n    \"42\": {\n        name: \"AuthErrorTokenUsedBeforeIssuedAt\",\n        retryable: false\n    },\n    \"43\": {\n        name: \"AuthErrorTokenSignatureInvalid\",\n        retryable: false\n    },\n    \"44\": {\n        name: \"CustomCommandEndpointMissingError\",\n        retryable: false\n    },\n    \"45\": {\n        name: \"CustomCommandEndpointCallError\",\n        retryable: true\n    },\n    \"46\": {\n        name: \"ConnectionIDNotFoundError\",\n        retryable: false\n    },\n    \"60\": {\n        name: \"CoolDownError\",\n        retryable: true\n    },\n    \"69\": {\n        name: \"ErrWrongRegion\",\n        retryable: false\n    },\n    \"70\": {\n        name: \"ErrQueryChannelPermissions\",\n        retryable: false\n    },\n    \"71\": {\n        name: \"ErrTooManyConnections\",\n        retryable: true\n    },\n    \"99\": {\n        name: \"AppSuspendedError\",\n        retryable: false\n    }\n};\nfunction isAPIError(error) {\n    return error.code !== undefined;\n}\nfunction isErrorRetryable(error) {\n    if (!error.code) return false;\n    const err = APIErrorCodes[`${error.code}`];\n    if (!err) return false;\n    return err.retryable;\n}\nfunction isConnectionIDError(error) {\n    return error.code === 46; // ConnectionIDNotFoundError\n}\nfunction isWSFailure(err) {\n    if (typeof err.isWSFailure === \"boolean\") {\n        return err.isWSFailure;\n    }\n    try {\n        return JSON.parse(err.message).isWSFailure;\n    } catch (_) {\n        return false;\n    }\n}\nfunction isErrorResponse(res) {\n    return !res.status || res.status < 200 || 300 <= res.status;\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Closed\"] = \"CLOSED\";\n    ConnectionState[\"Connected\"] = \"CONNECTED\";\n    ConnectionState[\"Connecting\"] = \"CONNECTING\";\n    ConnectionState[\"Disconnected\"] = \"DISCONNECTED\";\n    ConnectionState[\"Init\"] = \"INIT\";\n})(ConnectionState || (ConnectionState = {}));\nclass WSConnectionFallback {\n    constructor(client){\n        /** @private */ this._onlineStatusChanged = (event)=>{\n            this._log(`_onlineStatusChanged() - ${event.type}`);\n            if (event.type === \"offline\") {\n                this._setState(ConnectionState.Closed);\n                this.cancelToken?.cancel(\"disconnect() is called\");\n                this.cancelToken = undefined;\n                return;\n            }\n            if (event.type === \"online\" && this.state === ConnectionState.Closed) {\n                this.connect(true);\n            }\n        };\n        /** @private */ this._req = async (params, config, retry)=>{\n            if (!this.cancelToken && !params.close) {\n                this.cancelToken = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].CancelToken.source();\n            }\n            try {\n                const res = await this.client.doAxiosRequest(\"get\", this.client.baseURL.replace(\":3030\", \":8900\") + \"/longpoll\", undefined, {\n                    config: {\n                        ...config,\n                        cancelToken: this.cancelToken?.token\n                    },\n                    params,\n                    publicEndpoint: true\n                });\n                this.consecutiveFailures = 0; // always reset in case of no error\n                return res;\n            } catch (err) {\n                this.consecutiveFailures += 1;\n                // @ts-ignore\n                if (retry && isErrorRetryable(err)) {\n                    this._log(`_req() - Retryable error, retrying request`);\n                    await sleep(retryInterval(this.consecutiveFailures));\n                    return this._req(params, config, retry);\n                }\n                throw err;\n            }\n        };\n        /** @private */ this._poll = async ()=>{\n            while(this.state === ConnectionState.Connected){\n                try {\n                    const data = await this._req({}, {\n                        timeout: 30000\n                    }, true); // 30s => API responds in 20s if there is no event\n                    if (data.events?.length) {\n                        for(let i = 0; i < data.events.length; i++){\n                            this.client.dispatchEvent(data.events[i]);\n                        }\n                    }\n                } catch (err) {\n                    if (axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].isCancel(err)) {\n                        this._log(`_poll() - axios canceled request`);\n                        return;\n                    }\n                    /** client.doAxiosRequest will take care of TOKEN_EXPIRED error */ // @ts-ignore\n                    if (isConnectionIDError(err)) {\n                        this._log(`_poll() - ConnectionID error, connecting without ID...`);\n                        this._setState(ConnectionState.Disconnected);\n                        this.connect(true);\n                        return;\n                    }\n                    // @ts-ignore\n                    if (isAPIError(err) && !isErrorRetryable(err)) {\n                        this._setState(ConnectionState.Closed);\n                        return;\n                    }\n                    await sleep(retryInterval(this.consecutiveFailures));\n                }\n            }\n        };\n        /**\n         * connect try to open a longpoll request\n         * @param reconnect should be false for first call and true for subsequent calls to keep the connection alive and call recoverState\n         */ this.connect = async (reconnect = false)=>{\n            if (this.state === ConnectionState.Connecting) {\n                this._log(\"connect() - connecting already in progress\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            if (this.state === ConnectionState.Connected) {\n                this._log(\"connect() - already connected and polling\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            this._setState(ConnectionState.Connecting);\n            this.connectionID = undefined; // connect should be sent with empty connection_id so API creates one\n            try {\n                const { event } = await this._req({\n                    json: this.client._buildWSPayload()\n                }, {\n                    timeout: 8000\n                }, reconnect);\n                this._setState(ConnectionState.Connected);\n                this.connectionID = event.connection_id;\n                this.client.resolveConnectionId?.();\n                // @ts-expect-error\n                this.client.dispatchEvent(event);\n                this._poll();\n                return event;\n            } catch (err) {\n                this._setState(ConnectionState.Closed);\n                this.client.rejectConnectionId?.();\n                throw err;\n            }\n        };\n        /**\n         * isHealthy checks if there is a connectionID and connection is in Connected state\n         */ this.isHealthy = ()=>{\n            return !!this.connectionID && this.state === ConnectionState.Connected;\n        };\n        this.disconnect = async (timeout = 2000)=>{\n            removeConnectionEventListeners(this._onlineStatusChanged);\n            this._setState(ConnectionState.Disconnected);\n            this.cancelToken?.cancel(\"disconnect() is called\");\n            this.cancelToken = undefined;\n            const connection_id = this.connectionID;\n            this.connectionID = undefined;\n            try {\n                await this._req({\n                    close: true,\n                    connection_id\n                }, {\n                    timeout\n                }, false);\n                this._log(`disconnect() - Closed connectionID`);\n            } catch (err) {\n                this._log(`disconnect() - Failed`, {\n                    err\n                }, \"error\");\n            }\n        };\n        this.client = client;\n        this.state = ConnectionState.Init;\n        this.consecutiveFailures = 0;\n        addConnectionEventListeners(this._onlineStatusChanged);\n    }\n    _log(msg, extra = {}, level = \"info\") {\n        this.client.logger(level, \"WSConnectionFallback:\" + msg, {\n            ...extra\n        });\n    }\n    _setState(state) {\n        this._log(`_setState() - ${state}`);\n        // transition from connecting => connected\n        if (this.state === ConnectionState.Connecting && state === ConnectionState.Connected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: true\n            });\n        }\n        if (state === ConnectionState.Closed || state === ConnectionState.Disconnected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: false\n            });\n        }\n        this.state = state;\n    }\n}\nconst logger = getLogger([\n    \"location\"\n]);\nconst HINT_URL = `https://hint.stream-io-video.com/`;\nconst getLocationHint = async (hintUrl = HINT_URL, timeout = 2000)=>{\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(()=>abortController.abort(), timeout);\n    try {\n        const response = await fetch(hintUrl, {\n            method: \"HEAD\",\n            signal: abortController.signal\n        });\n        const awsPop = response.headers.get(\"x-amz-cf-pop\") || \"ERR\";\n        logger(\"debug\", `Location header: ${awsPop}`);\n        return awsPop.substring(0, 3); // AMS1-P2 -> AMS\n    } catch (e) {\n        logger(\"warn\", `Failed to get location hint from ${hintUrl}`, e);\n        return \"ERR\";\n    } finally{\n        clearTimeout(timeoutId);\n    }\n};\nclass StreamClient {\n    /**\n     * Initialize a client.\n     *\n     * @param {string} key - the api key\n     * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance\n     * @param {string} [options.secret] - the api secret\n     * @param {boolean} [options.browser] - enforce the client to be in browser mode\n     * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests\n     * @param {Logger} [options.Logger] - custom logger\n     * @param {number} [options.timeout] - default to 3000\n     * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()\n     */ constructor(key, options){\n        this.listeners = {};\n        this.nextRequestAbortController = null;\n        this.devToken = (userID)=>{\n            return DevToken(userID);\n        };\n        this.getAuthType = ()=>{\n            return this.anonymous ? \"anonymous\" : \"jwt\";\n        };\n        this.setBaseURL = (baseURL)=>{\n            this.baseURL = baseURL;\n            this.wsBaseURL = this.baseURL.replace(\"http\", \"ws\").replace(\":3030\", \":8800\");\n        };\n        this.getLocationHint = async (hintUrl, timeout)=>{\n            const hint = await this.locationHint;\n            if (!hint || hint === \"ERR\") {\n                this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout ?? this.options.locationHintTimeout);\n                return this.locationHint;\n            }\n            return hint;\n        };\n        this._getConnectionID = ()=>this.wsConnection?.connectionID || this.wsFallback?.connectionID;\n        this._hasConnectionID = ()=>Boolean(this._getConnectionID());\n        /**\n         * connectUser - Set the current user and open a WebSocket connection\n         *\n         * @param user Data about this user. IE {name: \"john\"}\n         * @param {TokenOrProvider} userTokenOrProvider Token or provider\n         *\n         * @return {ConnectAPIResponse} Returns a promise that resolves when the connection is setup\n         */ this.connectUser = async (user, userTokenOrProvider)=>{\n            if (!user.id) {\n                throw new Error('The \"id\" field on the user is missing');\n            }\n            /**\n             * Calling connectUser multiple times is potentially the result of a  bad integration, however,\n             * If the user id remains the same we don't throw error\n             */ if (this.userID === user.id && this.setUserPromise) {\n                this.logger(\"warn\", \"Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.\");\n                return this.setUserPromise;\n            }\n            if (this.userID) {\n                throw new Error(\"Use client.disconnect() before trying to connect as a different user. connectUser was called twice.\");\n            }\n            if ((this._isUsingServerAuth() || this.node) && !this.options.allowServerSideConnect) {\n                this.logger(\"warn\", 'Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add \"allowServerSideConnect: true\" to the client options to disable this warning.');\n            }\n            // we generate the client id client side\n            this.userID = user.id;\n            this.anonymous = false;\n            const setTokenPromise = this._setToken(user, userTokenOrProvider, this.anonymous);\n            this._setUser(user);\n            const wsPromise = this.openConnection();\n            this.setUserPromise = Promise.all([\n                setTokenPromise,\n                wsPromise\n            ]).then((result)=>result[1]);\n            try {\n                return await this.setUserPromise;\n            } catch (err) {\n                if (this.persistUserOnConnectionFailure) {\n                    // cleanup client to allow the user to retry connectUser again\n                    this.closeConnection();\n                } else {\n                    this.disconnectUser();\n                }\n                throw err;\n            }\n        };\n        this._setToken = (user, userTokenOrProvider, isAnonymous)=>this.tokenManager.setTokenOrProvider(userTokenOrProvider, user, isAnonymous);\n        this._setUser = (user)=>{\n            /**\n             * This one is used by the frontend. This is a copy of the current user object stored on backend.\n             * It contains reserved properties and own user properties which are not present in `this._user`.\n             */ this.user = user;\n            this.userID = user.id;\n            // this one is actually used for requests. This is a copy of current user provided to `connectUser` function.\n            this._user = {\n                ...user\n            };\n        };\n        /**\n         * Disconnects the websocket connection, without removing the user set on client.\n         * client.closeConnection will not trigger default auto-retry mechanism for reconnection. You need\n         * to call client.openConnection to reconnect to websocket.\n         *\n         * This is mainly useful on mobile side. You can only receive push notifications\n         * if you don't have active websocket connection.\n         * So when your app goes to background, you can call `client.closeConnection`.\n         * And when app comes back to foreground, call `client.openConnection`.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming succesful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.closeConnection = async (timeout)=>{\n            if (this.cleaningIntervalRef != null) {\n                clearInterval(this.cleaningIntervalRef);\n                this.cleaningIntervalRef = undefined;\n            }\n            await Promise.all([\n                this.wsConnection?.disconnect(timeout),\n                this.wsFallback?.disconnect(timeout)\n            ]);\n            return Promise.resolve();\n        };\n        /**\n         * Creates a new WebSocket connection with the current user. Returns empty promise, if there is an active connection\n         */ this.openConnection = async ()=>{\n            if (!this.userID) {\n                throw Error(\"UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead\");\n            }\n            if (this.wsConnection?.isConnecting && this.wsPromise) {\n                this.logger(\"info\", \"client:openConnection() - connection already in progress\");\n                return this.wsPromise;\n            }\n            if ((this.wsConnection?.isHealthy || this.wsFallback?.isHealthy()) && this._hasConnectionID()) {\n                this.logger(\"info\", \"client:openConnection() - openConnection called twice, healthy connection already exists\");\n                return Promise.resolve();\n            }\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.clientID = `${this.userID}--${randomId()}`;\n            this.wsPromise = this.connect();\n            return this.wsPromise;\n        };\n        this._normalizeDate = (before)=>{\n            if (before instanceof Date) {\n                before = before.toISOString();\n            }\n            if (before === \"\") {\n                throw new Error(\"Don't pass blank string for since, use null instead if resetting the token revoke\");\n            }\n            return before;\n        };\n        /**\n         * Disconnects the websocket and removes the user from client.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            this.logger(\"info\", \"client:disconnect() - Disconnecting the client\");\n            // remove the user specific fields\n            delete this.user;\n            delete this._user;\n            delete this.userID;\n            this.anonymous = false;\n            await this.closeConnection(timeout);\n            this.tokenManager.reset();\n            this.connectionIdPromise = undefined;\n            this.rejectConnectionId = undefined;\n            this.resolveConnectionId = undefined;\n        };\n        this.connectGuestUser = async (user)=>{\n            this.guestUserCreatePromise = this.doAxiosRequest(\"post\", \"/guest\", {\n                user: {\n                    ...user,\n                    role: \"guest\"\n                }\n            }, {\n                publicEndpoint: true\n            });\n            const response = await this.guestUserCreatePromise;\n            this.guestUserCreatePromise.finally(()=>this.guestUserCreatePromise = undefined);\n            return this.connectUser(response.user, response.access_token);\n        };\n        /**\n         * connectAnonymousUser - Set an anonymous user and open a WebSocket connection\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.anonymous = true;\n            await this._setToken(user, tokenOrProvider, this.anonymous);\n            this._setUser(user);\n            // some endpoints require a connection_id to be resolved.\n            // as anonymous users aren't allowed to open WS connections, we just\n            // resolve the connection_id here.\n            this.resolveConnectionId?.();\n        };\n        /**\n         * on - Listen to events on all channels and users your watching\n         *\n         * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n         *\n         * @param eventName The event type to listen for (optional)\n         * @param callback The callback to call\n         *\n         * @return  Returns a function which, when called, unsubscribes the event handler.\n         */ this.on = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Adding listener for ${eventName} event`);\n            this.listeners[eventName]?.push(callback);\n            return ()=>{\n                this.off(eventName, callback);\n            };\n        };\n        /**\n         * off - Remove the event handler\n         */ this.off = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Removing listener for ${eventName} event`);\n            this.listeners[eventName] = this.listeners[eventName]?.filter((value)=>value !== callback);\n        };\n        this._logApiRequest = (type, url, data, config)=>{\n            this.logger(\"trace\", `client: ${type} - Request - ${url}`, {\n                payload: data,\n                config\n            });\n        };\n        this._logApiResponse = (type, url, response)=>{\n            this.logger(\"trace\", `client:${type} - Response - url: ${url} > status ${response.status}`, {\n                response\n            });\n        };\n        this._logApiError = (type, url, error)=>{\n            this.logger(\"error\", `client:${type} - Error - url: ${url}`, {\n                url,\n                error\n            });\n        };\n        this.doAxiosRequest = async (type, url, data, options = {})=>{\n            if (!options.publicEndpoint) {\n                await Promise.all([\n                    this.tokenManager.tokenReady(),\n                    this.guestUserCreatePromise,\n                    this.connectionIdPromise\n                ]);\n            }\n            const requestConfig = this._enrichAxiosOptions(options);\n            try {\n                let response;\n                this._logApiRequest(type, url, data, requestConfig);\n                switch(type){\n                    case \"get\":\n                        response = await this.axiosInstance.get(url, requestConfig);\n                        break;\n                    case \"delete\":\n                        response = await this.axiosInstance.delete(url, requestConfig);\n                        break;\n                    case \"post\":\n                        response = await this.axiosInstance.post(url, data, requestConfig);\n                        break;\n                    case \"put\":\n                        response = await this.axiosInstance.put(url, data, requestConfig);\n                        break;\n                    case \"patch\":\n                        response = await this.axiosInstance.patch(url, data, requestConfig);\n                        break;\n                    case \"options\":\n                        response = await this.axiosInstance.options(url, requestConfig);\n                        break;\n                    default:\n                        throw new Error(\"Invalid request type\");\n                }\n                this._logApiResponse(type, url, response);\n                this.consecutiveFailures = 0;\n                return this.handleResponse(response);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            } catch (e /**TODO: generalize error types  */ ) {\n                e.client_request_id = requestConfig.headers?.[\"x-client-request-id\"];\n                this.consecutiveFailures += 1;\n                if (e.response) {\n                    this._logApiError(type, url, e.response);\n                    /** connection_fallback depends on this token expiration logic */ if (e.response.data.code === KnownCodes.TOKEN_EXPIRED && !this.tokenManager.isStatic()) {\n                        if (this.consecutiveFailures > 1) {\n                            await sleep(retryInterval(this.consecutiveFailures));\n                        }\n                        await this.tokenManager.loadToken();\n                        return await this.doAxiosRequest(type, url, data, options);\n                    }\n                    return this.handleResponse(e.response);\n                } else {\n                    this._logApiError(type, url, e);\n                    // eslint-disable-next-line no-throw-literal\n                    throw e;\n                }\n            }\n        };\n        this.get = (url, params)=>{\n            return this.doAxiosRequest(\"get\", url, null, {\n                params\n            });\n        };\n        this.put = (url, data, params)=>{\n            return this.doAxiosRequest(\"put\", url, data, {\n                params\n            });\n        };\n        this.post = (url, data, params)=>{\n            return this.doAxiosRequest(\"post\", url, data, {\n                params\n            });\n        };\n        this.patch = (url, data, params)=>{\n            return this.doAxiosRequest(\"patch\", url, data, {\n                params\n            });\n        };\n        this.delete = (url, params)=>{\n            return this.doAxiosRequest(\"delete\", url, null, {\n                params\n            });\n        };\n        this.errorFromResponse = (response)=>{\n            let err;\n            err = new ErrorFromResponse(`Stream error HTTP code: ${response.status}`);\n            if (response.data && response.data.code) {\n                err = new Error(`Stream error code ${response.data.code}: ${response.data.message}`);\n                err.code = response.data.code;\n            }\n            err.response = response;\n            err.status = response.status;\n            return err;\n        };\n        this.handleResponse = (response)=>{\n            const data = response.data;\n            if (isErrorResponse(response)) {\n                throw this.errorFromResponse(response);\n            }\n            return data;\n        };\n        this.dispatchEvent = (event)=>{\n            if (!event.received_at) event.received_at = new Date();\n            this.logger(\"debug\", `Dispatching event: ${event.type}`, event);\n            if (!this.listeners) return;\n            // call generic listeners\n            for (const listener of this.listeners.all || []){\n                listener(event);\n            }\n            // call type specific listeners\n            for (const listener of this.listeners[event.type] || []){\n                listener(event);\n            }\n        };\n        /**\n         * @private\n         */ this.connect = async ()=>{\n            if (!this.userID || !this._user) {\n                throw Error(\"Call connectUser or connectAnonymousUser before starting the connection\");\n            }\n            if (!this.wsBaseURL) {\n                throw Error(\"Websocket base url not set\");\n            }\n            if (!this.clientID) {\n                throw Error(\"clientID is not set\");\n            }\n            if (!this.wsConnection && (this.options.warmUp || this.options.enableInsights)) {\n                this._sayHi();\n            }\n            // The StableWSConnection handles all the reconnection logic.\n            if (this.options.wsConnection && this.node) {\n                // Intentionally avoiding adding ts generics on wsConnection in options since its only useful for unit test purpose.\n                this.options.wsConnection.setClient(this);\n                this.wsConnection = this.options.wsConnection;\n            } else {\n                this.wsConnection = new StableWSConnection(this);\n            }\n            try {\n                // if fallback is used before, continue using it instead of waiting for WS to fail\n                if (this.wsFallback) {\n                    return await this.wsFallback.connect();\n                }\n                this.logger(\"info\", \"StreamClient.connect: this.wsConnection.connect()\");\n                // if WSFallback is enabled, ws connect should timeout faster so fallback can try\n                return await this.wsConnection.connect(this.options.enableWSFallback ? this.defaultWSTimeoutWithFallback : this.defaultWSTimeout);\n            } catch (err) {\n                // run fallback only if it's WS/Network error and not a normal API error\n                // make sure browser is online before even trying the longpoll\n                if (this.options.enableWSFallback && // @ts-ignore\n                isWSFailure(err) && isOnline(this.logger)) {\n                    this.logger(\"warn\", \"client:connect() - WS failed, fallback to longpoll\");\n                    this.dispatchEvent({\n                        type: \"transport.changed\",\n                        mode: \"longpoll\"\n                    });\n                    this.wsConnection._destroyCurrentWSConnection();\n                    this.wsConnection.disconnect().then(); // close WS so no retry\n                    this.wsFallback = new WSConnectionFallback(this);\n                    return await this.wsFallback.connect();\n                }\n                throw err;\n            }\n        };\n        /**\n         * Check the connectivity with server for warmup purpose.\n         *\n         * @private\n         */ this._sayHi = ()=>{\n            const client_request_id = randomId();\n            const opts = {\n                headers: axios__WEBPACK_IMPORTED_MODULE_1__.AxiosHeaders.from({\n                    \"x-client-request-id\": client_request_id\n                })\n            };\n            this.doAxiosRequest(\"get\", this.baseURL + \"/hi\", null, opts).catch((e)=>{\n                if (this.options.enableInsights) {\n                    postInsights(\"http_hi_failed\", {\n                        api_key: this.key,\n                        err: e,\n                        client_request_id\n                    });\n                }\n            });\n        };\n        this.getUserAgent = ()=>{\n            const version = \"0.6.10\";\n            return this.userAgent || `stream-video-javascript-client-${this.node ? \"node\" : \"browser\"}-${version}`;\n        };\n        this.setUserAgent = (userAgent)=>{\n            this.userAgent = userAgent;\n        };\n        /**\n         * _isUsingServerAuth - Returns true if we're using server side auth\n         */ this._isUsingServerAuth = ()=>!!this.secret;\n        this._enrichAxiosOptions = (options = {\n            params: {},\n            headers: {},\n            config: {}\n        })=>{\n            const token = options.publicEndpoint && !this.user ? undefined : this._getToken();\n            const authorization = token ? {\n                Authorization: token\n            } : undefined;\n            let signal = null;\n            if (this.nextRequestAbortController !== null) {\n                signal = this.nextRequestAbortController.signal;\n                this.nextRequestAbortController = null;\n            }\n            if (!options.headers?.[\"x-client-request-id\"]) {\n                options.headers = {\n                    ...options.headers,\n                    \"x-client-request-id\": randomId()\n                };\n            }\n            return {\n                params: {\n                    user_id: this.userID,\n                    connection_id: this._getConnectionID(),\n                    api_key: this.key,\n                    ...options.params\n                },\n                headers: {\n                    ...authorization,\n                    \"stream-auth-type\": options.publicEndpoint && !this.user ? \"anonymous\" : this.getAuthType(),\n                    \"X-Stream-Client\": this.getUserAgent(),\n                    ...options.headers\n                },\n                ...signal ? {\n                    signal\n                } : {},\n                ...options.config,\n                ...this.options.axiosRequestConfig\n            };\n        };\n        this._getToken = ()=>{\n            if (!this.tokenManager) return null;\n            return this.tokenManager.getToken();\n        };\n        /**\n         * encode ws url payload\n         * @private\n         * @returns json string\n         */ this._buildWSPayload = (client_request_id)=>{\n            return JSON.stringify({\n                user_id: this.userID,\n                user_details: this._user,\n                client_request_id\n            });\n        };\n        /**\n         * creates an abort controller that will be used by the next HTTP Request.\n         */ this.createAbortControllerForNextRequest = ()=>{\n            return this.nextRequestAbortController = new AbortController();\n        };\n        /**\n         * createToken - Creates a token to authenticate this user. This function is used server side.\n         * The resulting token should be passed to the client side when the users registers or logs in.\n         *\n         * @param {string} userID The UserWithId ID\n         * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n         * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n         *\n         * @return {string} Returns a token\n         */ this.createToken = (userID, exp, iat, call_cids)=>{\n            if (this.secret == null) {\n                throw Error(`tokens can only be created server-side using the API Secret`);\n            }\n            const extra = {};\n            if (exp) {\n                extra.exp = exp;\n            }\n            if (iat) {\n                extra.iat = iat;\n            }\n            if (call_cids) {\n                extra.call_cids = call_cids;\n            }\n            return JWTUserToken(this.secret, userID, extra, {});\n        };\n        // set the key\n        this.key = key;\n        // set the secret\n        this.secret = options?.secret;\n        // set the options... and figure out defaults...\n        const inputOptions = options ? options : {\n            browser: \"undefined\" !== \"undefined\"\n        };\n        this.browser = inputOptions.browser || \"undefined\" !== \"undefined\";\n        this.node = !this.browser;\n        if (this.browser) {\n            this.locationHint = getLocationHint(options?.locationHintUrl, options?.locationHintTimeout);\n        }\n        this.options = {\n            timeout: 5000,\n            withCredentials: false,\n            warmUp: false,\n            ...inputOptions\n        };\n        if (this.node && !this.options.httpsAgent) {\n            this.options.httpsAgent = new (https__WEBPACK_IMPORTED_MODULE_5___default().Agent)({\n                keepAlive: true,\n                keepAliveMsecs: 3000\n            });\n        }\n        this.setBaseURL(this.options.baseURL || \"https://video.stream-io-api.com/video\");\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_RUN) {\n            this.setBaseURL(\"http://localhost:3030/video\");\n        }\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_HOST) {\n            this.setBaseURL(`http://${process.env.STREAM_LOCAL_TEST_HOST}/video`);\n        }\n        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].create({\n            ...this.options,\n            baseURL: this.baseURL\n        });\n        // WS connection is initialized when setUser is called\n        this.wsConnection = null;\n        this.wsPromise = null;\n        this.setUserPromise = null;\n        // mapping between channel groups and configs\n        this.anonymous = false;\n        this.persistUserOnConnectionFailure = this.options?.persistUserOnConnectionFailure;\n        // If it is a server-side client, then lets initialize the tokenManager, since token will be\n        // generated from secret.\n        this.tokenManager = new TokenManager(this.secret);\n        this.consecutiveFailures = 0;\n        this.insightMetrics = new InsightMetrics();\n        this.defaultWSTimeoutWithFallback = 6000;\n        this.defaultWSTimeout = 15000;\n        this.logger = isFunction(inputOptions.logger) ? inputOptions.logger : ()=>null;\n    }\n}\n/**\n * A `StreamVideoClient` instance lets you communicate with our API, and authenticate users.\n */ class StreamVideoClient {\n    constructor(apiKeyOrArgs, opts){\n        this.logLevel = \"warn\";\n        this.eventHandlersToUnregister = [];\n        /**\n         * Disconnects the currently connected user from the client.\n         *\n         * If the connection is successfully disconnected, the connected user [state variable](#readonlystatestore) will be updated accordingly\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            if (!this.streamClient.user && !this.connectionPromise) {\n                return;\n            }\n            const disconnectUser = ()=>this.streamClient.disconnectUser(timeout);\n            this.disconnectionPromise = this.connectionPromise ? this.connectionPromise.then(()=>disconnectUser()) : disconnectUser();\n            this.disconnectionPromise.finally(()=>this.disconnectionPromise = undefined);\n            await this.disconnectionPromise;\n            this.eventHandlersToUnregister.forEach((unregister)=>unregister());\n            this.eventHandlersToUnregister = [];\n            this.writeableStateStore.setConnectedUser(undefined);\n        };\n        /**\n         * You can subscribe to WebSocket events provided by the API.\n         * To remove a subscription, call the `off` method or, execute the returned unsubscribe function.\n         * Please note that subscribing to WebSocket events is an advanced use-case, for most use-cases it should be enough to watch for changes in the reactive [state store](#readonlystatestore).\n         *\n         * @param eventName the event name or 'all'.\n         * @param callback the callback which will be called when the event is emitted.\n         * @returns an unsubscribe function.\n         */ this.on = (eventName, callback)=>{\n            return this.streamClient.on(eventName, callback);\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param callback the callback which was passed to the `on` method.\n         */ this.off = (eventName, callback)=>{\n            return this.streamClient.off(eventName, callback);\n        };\n        /**\n         * Creates a new call.\n         *\n         * @param type the type of the call.\n         * @param id the id of the call.\n         */ this.call = (type, id)=>{\n            return new Call({\n                streamClient: this.streamClient,\n                id: id,\n                type: type,\n                clientStore: this.writeableStateStore\n            });\n        };\n        /**\n         * Creates a new guest user with the given data.\n         *\n         * @param data the data for the guest user.\n         */ this.createGuestUser = async (data)=>{\n            return this.streamClient.doAxiosRequest(\"post\", \"/guest\", data, {\n                publicEndpoint: true\n            });\n        };\n        /**\n         * Will query the API for calls matching the given filters.\n         *\n         * @param data the query data.\n         */ this.queryCalls = async (data = {})=>{\n            const response = await this.streamClient.post(\"/calls\", data);\n            const calls = response.calls.map((c)=>{\n                const call = new Call({\n                    streamClient: this.streamClient,\n                    id: c.call.id,\n                    type: c.call.type,\n                    members: c.members,\n                    ownCapabilities: c.own_capabilities,\n                    watching: data.watch,\n                    clientStore: this.writeableStateStore\n                });\n                call.state.updateFromCallResponse(c.call);\n                call.applyDeviceConfig();\n                if (data.watch) {\n                    this.writeableStateStore.registerCall(call);\n                }\n                return call;\n            });\n            return {\n                ...response,\n                calls: calls\n            };\n        };\n        /**\n         * Retrieve the list of available call statistics reports matching a particular condition.\n         *\n         * @param data Filter and sort conditions for retrieving available call report summaries.\n         * @returns List with summary of available call reports matching the condition.\n         */ this.queryCallStats = async (data = {})=>{\n            return this.streamClient.post(`/call/stats`, data);\n        };\n        /**\n         * Returns a list of available data centers available for hosting calls.\n         */ this.edges = async ()=>{\n            return this.streamClient.get(`/edges`);\n        };\n        /**\n         * addDevice - Adds a push device for a user.\n         *\n         * @param {string} id the device id\n         * @param {string} push_provider the push provider name (eg. apn, firebase)\n         * @param {string} push_provider_name user provided push provider name\n         * @param {string} [userID] the user id (defaults to current user)\n         * @param {boolean} [voip_token] enables use of VoIP token for push notifications on iOS platform\n         */ this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token)=>{\n            return await this.streamClient.post(\"/devices\", {\n                id,\n                push_provider,\n                voip_token,\n                ...userID != null ? {\n                    user_id: userID\n                } : {},\n                ...push_provider_name != null ? {\n                    push_provider_name\n                } : {}\n            });\n        };\n        /**\n         * getDevices - Returns the devices associated with a current user\n         * @param {string} [userID] User ID. Only works on serverside\n         */ this.getDevices = async (userID)=>{\n            return await this.streamClient.get(\"/devices\", userID ? {\n                user_id: userID\n            } : {});\n        };\n        /**\n         * removeDevice - Removes the device with the given id.\n         *\n         * @param {string} id The device id\n         * @param {string} [userID] The user id. Only specify this for serverside requests\n         */ this.removeDevice = async (id, userID)=>{\n            return await this.streamClient.delete(\"/devices\", {\n                id,\n                ...userID ? {\n                    user_id: userID\n                } : {}\n            });\n        };\n        /**\n         * A callback that can be used to create ringing calls from push notifications. If the call already exists, it will do nothing.\n         * @param call_cid\n         * @returns\n         */ this.onRingingCall = async (call_cid)=>{\n            // if we find the call and is already ringing, we don't need to create a new call\n            // as client would have received the call.ring state because the app had WS alive when receiving push notifications\n            let call = this.readOnlyStateStore.calls.find((c)=>c.cid === call_cid && c.ringing);\n            if (!call) {\n                // if not it means that WS is not alive when receiving the push notifications and we need to fetch the call\n                const [callType, callId] = call_cid.split(\":\");\n                call = new Call({\n                    streamClient: this.streamClient,\n                    type: callType,\n                    id: callId,\n                    clientStore: this.writeableStateStore,\n                    ringing: true\n                });\n                await call.get();\n            }\n            return call;\n        };\n        /**\n         * Connects the given anonymous user to the client.\n         *\n         * @param user the user to connect.\n         * @param tokenOrProvider a token or a function that returns a token.\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            const connectAnonymousUser = ()=>this.streamClient.connectAnonymousUser(user, tokenOrProvider);\n            this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectAnonymousUser()) : connectAnonymousUser();\n            this.connectionPromise.finally(()=>this.connectionPromise = undefined);\n            return this.connectionPromise;\n        };\n        let logger = logToConsole;\n        let logLevel = \"warn\";\n        if (typeof apiKeyOrArgs === \"string\") {\n            logLevel = opts?.logLevel || logLevel;\n            logger = opts?.logger || logger;\n        } else {\n            logLevel = apiKeyOrArgs.options?.logLevel || logLevel;\n            logger = apiKeyOrArgs.options?.logger || logger;\n        }\n        setLogger(logger, logLevel);\n        this.logger = getLogger([\n            \"client\"\n        ]);\n        if (typeof apiKeyOrArgs === \"string\") {\n            this.streamClient = new StreamClient(apiKeyOrArgs, {\n                persistUserOnConnectionFailure: true,\n                ...opts,\n                logLevel,\n                logger: this.logger\n            });\n        } else {\n            this.streamClient = new StreamClient(apiKeyOrArgs.apiKey, {\n                persistUserOnConnectionFailure: true,\n                ...apiKeyOrArgs.options,\n                logLevel,\n                logger: this.logger\n            });\n            const sdkInfo = getSdkInfo();\n            if (sdkInfo) {\n                this.streamClient.setUserAgent(this.streamClient.getUserAgent() + `-video-${SdkType[sdkInfo.type].toLowerCase()}-sdk-${sdkInfo.major}.${sdkInfo.minor}.${sdkInfo.patch}`);\n            }\n        }\n        this.writeableStateStore = new StreamVideoWriteableStateStore();\n        this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);\n        if (typeof apiKeyOrArgs !== \"string\") {\n            const user = apiKeyOrArgs.user;\n            const token = apiKeyOrArgs.token || apiKeyOrArgs.tokenProvider;\n            if (user) {\n                this.connectUser(user, token);\n            }\n        }\n    }\n    /**\n     * Return the reactive state store, use this if you want to be notified about changes to the client state\n     */ get state() {\n        return this.readOnlyStateStore;\n    }\n    /**\n     * Connects the given user to the client.\n     * Only one user can connect at a time, if you want to change users, call `disconnectUser` before connecting a new user.\n     * If the connection is successful, the connected user [state variable](#readonlystatestore) will be updated accordingly.\n     *\n     * @param user the user to connect.\n     * @param token a token or a function that returns a token.\n     */ async connectUser(user, token) {\n        if (user.type === \"anonymous\") {\n            user.id = \"!anon\";\n            return this.connectAnonymousUser(user, token);\n        }\n        let connectUser = ()=>{\n            return this.streamClient.connectUser(user, token);\n        };\n        if (user.type === \"guest\") {\n            connectUser = async ()=>{\n                return this.streamClient.connectGuestUser(user);\n            };\n        }\n        this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectUser()) : connectUser();\n        this.connectionPromise?.finally(()=>this.connectionPromise = undefined);\n        const connectUserResponse = await this.connectionPromise;\n        // connectUserResponse will be void if connectUser called twice for the same user\n        if (connectUserResponse?.me) {\n            this.writeableStateStore.setConnectedUser(connectUserResponse.me);\n        }\n        this.eventHandlersToUnregister.push(this.on(\"connection.changed\", (event)=>{\n            if (event.online) {\n                const callsToReWatch = this.writeableStateStore.calls.filter((call)=>call.watching).map((call)=>call.cid);\n                this.logger(\"info\", `Rewatching calls after connection changed ${callsToReWatch.join(\", \")}`);\n                if (callsToReWatch.length > 0) {\n                    this.queryCalls({\n                        watch: true,\n                        filter_conditions: {\n                            cid: {\n                                $in: callsToReWatch\n                            }\n                        },\n                        sort: [\n                            {\n                                field: \"cid\",\n                                direction: 1\n                            }\n                        ]\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to re-watch calls\", err);\n                    });\n                }\n            }\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.created\", (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"warn\", \"Received `call.created` sent by the current user\");\n                return;\n            }\n            this.logger(\"info\", `New call created and registered: ${call.cid}`);\n            const newCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore\n            });\n            newCall.state.updateFromCallResponse(call);\n            this.writeableStateStore.registerCall(newCall);\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.ring\", async (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"debug\", \"Received `call.ring` sent by the current user so ignoring the event\");\n                return;\n            }\n            // The call might already be tracked by the client,\n            // if `call.created` was received before `call.ring`.\n            // In that case, we cleanup the already tracked call.\n            const prevCall = this.writeableStateStore.findCall(call.type, call.id);\n            await prevCall?.leave({\n                reason: \"cleaning-up in call.ring\"\n            });\n            // we create a new call\n            const theCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore,\n                ringing: true\n            });\n            theCall.state.updateFromCallResponse(call);\n            // we fetch the latest metadata for the call from the server\n            await theCall.get();\n            this.writeableStateStore.registerCall(theCall);\n        }));\n        return connectUserResponse;\n    }\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider name (eg. apn, firebase)\n     * @param {string} push_provider_name user provided push provider name\n     * @param {string} [userID] the user id (defaults to current user)\n     */ async addVoipDevice(id, push_provider, push_provider_name, userID) {\n        return await this.addDevice(id, push_provider, push_provider_name, userID, true);\n    }\n}\n/**\n * @deprecated Please use the `@stream-io/node-sdk` package instead.\n *\n * @see https://getstream.io/video/docs/api/\n */ class StreamVideoServerClient extends StreamVideoClient {\n    constructor(apiKey, options){\n        super({\n            apiKey,\n            options\n        });\n        this.getCallTypes = ()=>{\n            return this.streamClient.get(\"/calltypes\");\n        };\n        this.getCallType = (name)=>{\n            return this.streamClient.get(`/calltypes/${name}`);\n        };\n        this.createCallType = (data)=>{\n            return this.streamClient.post(\"/calltypes\", data);\n        };\n        this.deleteCallType = (name)=>{\n            return this.streamClient.delete(`/calltypes/${name}`);\n        };\n        this.updateCallType = (name, data)=>{\n            return this.streamClient.put(`/calltypes/${name}`, data);\n        };\n        this.listExternalStorage = ()=>{\n            return this.streamClient.get(\"/external_storage\");\n        };\n        this.createExternalStorage = (request)=>{\n            return this.streamClient.post(\"/external_storage\", request);\n        };\n        this.deleteExternalStorage = (name)=>{\n            return this.streamClient.delete(`/external_storage/${name}`);\n        };\n        this.updateExternalStorage = (name, request)=>{\n            return this.streamClient.put(`/external_storage/${name}`, request);\n        };\n        this.checkExternalStorage = (name)=>{\n            return this.streamClient.get(`/external_storage/${name}/check`);\n        };\n    }\n    /**\n     * createToken - Creates a token to authenticate this user. This function is used server side.\n     * The resulting token should be passed to the client side when the users register or logs in.\n     *\n     * @param {string} userID The User ID\n     * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n     * @param {number} [iat] The timestamp when a token has been issued\n     * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n     *\n     * @return {string} Returns a token\n     */ createToken(userID, exp, iat, call_cids) {\n        return this.streamClient.createToken(userID, exp, iat, call_cids);\n    }\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0cmVhbS1pbyt2aWRlby1jbGllbnRAMC42LjEwL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLWNsaWVudC9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDeUg7QUFDMUU7QUFDM0I7QUFDVDtBQUNnQztBQUNnTDtBQUM5TTtBQUNHO0FBQ0Y7QUFDWjtBQUNLO0FBQ2Y7QUFDMEI7QUFFMUM7O0NBRUMsR0FDRCxNQUFNc0MsaUNBQWlDO0lBQ25DQyxTQUFTO0lBQ1RDLFVBQVU7QUFDZDtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsd0NBQXdDO0lBQzFDRixTQUFTO0lBQ1RDLFVBQVU7QUFDZDtBQUNBOztDQUVDLEdBQ0QsTUFBTUUsc0NBQXNDO0lBQ3hDQyxVQUFVO0lBQ1ZDLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtJQUMzQkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLGdDQUFnQztJQUNsQ0wsV0FBVztJQUNYQyxNQUFNO0lBQ05DLG9CQUFvQjtJQUNwQkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDQTs7O0NBR0MsR0FDRCxNQUFNRSxnQkFBZ0I7SUFDbEJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxpQkFBaUI7SUFDakJDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxXQUFXO0lBQ1hDLGlCQUFpQjtJQUNqQkMsWUFBWTtJQUNaQyxrQkFBa0I7SUFDbEJDLFdBQVc7SUFDWEMsb0JBQW9CO0lB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QztRQUNqQztRQUNBLElBQUksQ0FBQ3E3QixxQkFBcUIsR0FBRyxDQUFDeHVCO1lBQzFCLE9BQU8sSUFBSSxDQUFDMFYsWUFBWSxDQUFDelYsSUFBSSxDQUFDLHFCQUFxQkQ7UUFDdkQ7UUFDQSxJQUFJLENBQUN5dUIscUJBQXFCLEdBQUcsQ0FBQ2oxRDtZQUMxQixPQUFPLElBQUksQ0FBQ2s4QyxZQUFZLENBQUN4Z0IsTUFBTSxDQUFDLENBQUMsa0JBQWtCLEVBQUUxN0IsS0FBSyxDQUFDO1FBQy9EO1FBQ0EsSUFBSSxDQUFDazFELHFCQUFxQixHQUFHLENBQUNsMUQsTUFBTXdtQztZQUNoQyxPQUFPLElBQUksQ0FBQzBWLFlBQVksQ0FBQzhVLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixFQUFFaHhELEtBQUssQ0FBQyxFQUFFd21DO1FBQzlEO1FBQ0EsSUFBSSxDQUFDMnVCLG9CQUFvQixHQUFHLENBQUNuMUQ7WUFDekIsT0FBTyxJQUFJLENBQUNrOEMsWUFBWSxDQUFDdmlCLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixFQUFFMzVCLEtBQUssTUFBTSxDQUFDO1FBQ2xFO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QreEQsWUFBWTNNLE1BQU0sRUFBRTRNLEdBQUcsRUFBRXpHLEdBQUcsRUFBRTBHLFNBQVMsRUFBRTtRQUNyQyxPQUFPLElBQUksQ0FBQy9WLFlBQVksQ0FBQzZWLFdBQVcsQ0FBQzNNLFFBQVE0TSxLQUFLekcsS0FBSzBHO0lBQzNEO0FBQ0o7QUFFNmpELENBQzdqRCxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b29tLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdHJlYW0taW8rdmlkZW8tY2xpZW50QDAuNi4xMC9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1jbGllbnQvZGlzdC9pbmRleC5lcy5qcz9kYzJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnd2VicnRjLWFkYXB0ZXInO1xuaW1wb3J0IHsgTWVzc2FnZVR5cGUsIGlzSnNvbk9iamVjdCwgdHlwZW9mSnNvblZhbHVlLCByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsLCBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSwgUGJMb25nIH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuaW1wb3J0IHsgU2VydmljZVR5cGUsIHN0YWNrSW50ZXJjZXB0IH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUtcnBjJztcbmltcG9ydCBheGlvcywgeyBBeGlvc0hlYWRlcnMgfSBmcm9tICdheGlvcyc7XG5leHBvcnQgeyBBeGlvc0Vycm9yIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgVHdpcnBGZXRjaFRyYW5zcG9ydCB9IGZyb20gJ0Bwcm90b2J1Zi10cy90d2lycC10cmFuc3BvcnQnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCwgY29tYmluZUxhdGVzdCwgQmVoYXZpb3JTdWJqZWN0LCBtYXAgYXMgbWFwJDEsIHNoYXJlUmVwbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgdGFrZVdoaWxlLCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCwgbWVyZ2UsIGZyb20sIE9ic2VydmFibGUsIGRlYm91bmNlVGltZSwgY29uY2F0TWFwLCBwYWlyd2lzZSwgb2YsIGZpbHRlciwgZGVib3VuY2UsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgKiBhcyBTRFAgZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBVQVBhcnNlciB9IGZyb20gJ3VhLXBhcnNlci1qcyc7XG5pbXBvcnQgV2ViU29ja2V0IGZyb20gJ2lzb21vcnBoaWMtd3MnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCAnY3J5cHRvJztcbmltcG9ydCB7IGZyb21CeXRlQXJyYXkgfSBmcm9tICdiYXNlNjQtanMnO1xuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtID0ge1xuICAgIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgICBFQVJQSUVDRTogJ2VhcnBpZWNlJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZScsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBMYXlvdXRTZXR0aW5nc05hbWVFbnVtID0ge1xuICAgIFNQT1RMSUdIVDogJ3Nwb3RsaWdodCcsXG4gICAgR1JJRDogJ2dyaWQnLFxuICAgIFNJTkdMRV9QQVJUSUNJUEFOVDogJ3NpbmdsZS1wYXJ0aWNpcGFudCcsXG4gICAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgICBDVVNUT006ICdjdXN0b20nLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBMYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJyxcbn07XG4vKipcbiAqIEFsbCBwb3NzaWJpbGl0eSBvZiBzdHJpbmcgdG8gdXNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE93bkNhcGFiaWxpdHkgPSB7XG4gICAgQkxPQ0tfVVNFUlM6ICdibG9jay11c2VycycsXG4gICAgQ1JFQVRFX0NBTEw6ICdjcmVhdGUtY2FsbCcsXG4gICAgQ1JFQVRFX1JFQUNUSU9OOiAnY3JlYXRlLXJlYWN0aW9uJyxcbiAgICBFTkRfQ0FMTDogJ2VuZC1jYWxsJyxcbiAgICBKT0lOX0JBQ0tTVEFHRTogJ2pvaW4tYmFja3N0YWdlJyxcbiAgICBKT0lOX0NBTEw6ICdqb2luLWNhbGwnLFxuICAgIEpPSU5fRU5ERURfQ0FMTDogJ2pvaW4tZW5kZWQtY2FsbCcsXG4gICAgTVVURV9VU0VSUzogJ211dGUtdXNlcnMnLFxuICAgIFBJTl9GT1JfRVZFUllPTkU6ICdwaW4tZm9yLWV2ZXJ5b25lJyxcbiAgICBSRUFEX0NBTEw6ICdyZWFkLWNhbGwnLFxuICAgIFJFTU9WRV9DQUxMX01FTUJFUjogJ3JlbW92ZS1jYWxsLW1lbWJlcicsXG4gICAgU0NSRUVOU0hBUkU6ICdzY3JlZW5zaGFyZScsXG4gICAgU0VORF9BVURJTzogJ3NlbmQtYXVkaW8nLFxuICAgIFNFTkRfVklERU86ICdzZW5kLXZpZGVvJyxcbiAgICBTVEFSVF9CUk9BRENBU1RfQ0FMTDogJ3N0YXJ0LWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVEFSVF9SRUNPUkRfQ0FMTDogJ3N0YXJ0LXJlY29yZC1jYWxsJyxcbiAgICBTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdGFydC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFNUT1BfQlJPQURDQVNUX0NBTEw6ICdzdG9wLWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVE9QX1JFQ09SRF9DQUxMOiAnc3RvcC1yZWNvcmQtY2FsbCcsXG4gICAgU1RPUF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdG9wLXRyYW5zY3JpcHRpb24tY2FsbCcsXG4gICAgVVBEQVRFX0NBTEw6ICd1cGRhdGUtY2FsbCcsXG4gICAgVVBEQVRFX0NBTExfTUVNQkVSOiAndXBkYXRlLWNhbGwtbWVtYmVyJyxcbiAgICBVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUzogJ3VwZGF0ZS1jYWxsLXBlcm1pc3Npb25zJyxcbiAgICBVUERBVEVfQ0FMTF9TRVRUSU5HUzogJ3VwZGF0ZS1jYWxsLXNldHRpbmdzJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbicsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtID0ge1xuICAgIF8zNjBQOiAnMzYwcCcsXG4gICAgXzQ4MFA6ICc0ODBwJyxcbiAgICBfNzIwUDogJzcyMHAnLFxuICAgIF8xMDgwUDogJzEwODBwJyxcbiAgICBfMTQ0MFA6ICcxNDQwcCcsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbicsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc1JlcXVlc3RDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn07XG5cbmNsYXNzIEVycm9yRnJvbVJlc3BvbnNlIGV4dGVuZHMgRXJyb3Ige1xufVxuXG4vKipcbiAqIGBOdWxsVmFsdWVgIGlzIGEgc2luZ2xldG9uIGVudW1lcmF0aW9uIHRvIHJlcHJlc2VudCB0aGUgbnVsbCB2YWx1ZSBmb3IgdGhlXG4gKiBgVmFsdWVgIHR5cGUgdW5pb24uXG4gKlxuICogIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBgTnVsbFZhbHVlYCBpcyBKU09OIGBudWxsYC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXG4gKi9cbnZhciBOdWxsVmFsdWU7XG4oZnVuY3Rpb24gKE51bGxWYWx1ZSkge1xuICAgIC8qKlxuICAgICAqIE51bGwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogTlVMTF9WQUxVRSA9IDA7XG4gICAgICovXG4gICAgTnVsbFZhbHVlW051bGxWYWx1ZVtcIk5VTExfVkFMVUVcIl0gPSAwXSA9IFwiTlVMTF9WQUxVRVwiO1xufSkoTnVsbFZhbHVlIHx8IChOdWxsVmFsdWUgPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3RydWN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdnb29nbGUucHJvdG9idWYuU3RydWN0JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmaWVsZHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtYXAnLFxuICAgICAgICAgICAgICAgIEs6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgICAgIFY6IHsga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBWYWx1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBgU3RydWN0YCB0byBKU09OIG9iamVjdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBqc29uID0ge307XG4gICAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhtZXNzYWdlLmZpZWxkcykpIHtcbiAgICAgICAgICAgIGpzb25ba10gPSBWYWx1ZS50b0pzb24odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBgU3RydWN0YCBmcm9tIEpTT04gb2JqZWN0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBtZXNzYWdlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICAgICAgICcgZnJvbSBKU09OICcgK1xuICAgICAgICAgICAgICAgIHR5cGVvZkpzb25WYWx1ZShqc29uKSArXG4gICAgICAgICAgICAgICAgJy4nKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBmb3IgKGxldCBbaywgdl0gb2YgZ2xvYmFsVGhpcy5PYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpZWxkc1trXSA9IFZhbHVlLmZyb21Kc29uKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZmllbGRzID0ge307XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UmVhZE1hcDEobWVzc2FnZS5maWVsZHMsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGJpbmFyeVJlYWRNYXAxKG1hcCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBsZW4gPSByZWFkZXIudWludDMyKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW4sIGtleSwgdmFsO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBWYWx1ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndW5rbm93biBtYXAgZW50cnkgZmllbGQgZm9yIGZpZWxkIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZmllbGRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2tleSA/PyAnJ10gPSB2YWwgPz8gVmFsdWUuY3JlYXRlKCk7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgayBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKSkge1xuICAgICAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAgICAgLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAgICAgLmZvcmsoKVxuICAgICAgICAgICAgICAgIC50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgICAgIC5zdHJpbmcoayk7XG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgICAgICAgICAgVmFsdWUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmZpZWxkc1trXSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdyaXRlci5qb2luKCkuam9pbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuU3RydWN0XG4gKi9cbmNvbnN0IFN0cnVjdCA9IG5ldyBTdHJ1Y3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmFsdWUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5WYWx1ZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnVsbF92YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAna2luZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlJywgTnVsbFZhbHVlXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ251bWJlcl92YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAxIC8qU2NhbGFyVHlwZS5ET1VCTEUqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N0cmluZ192YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Jvb2xfdmFsdWUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAna2luZCcsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3RydWN0X3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBTdHJ1Y3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsaXN0X3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBMaXN0VmFsdWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGBWYWx1ZWAgdG8gSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgICAgICBjYXNlICdib29sVmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmtpbmQuYm9vbFZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnbnVsbFZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlclZhbHVlJzpcbiAgICAgICAgICAgICAgICBsZXQgbnVtYmVyVmFsdWUgPSBtZXNzYWdlLmtpbmQubnVtYmVyVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW1iZXJWYWx1ZSA9PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKG51bWJlclZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmdWYWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2Uua2luZC5zdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ2xpc3RWYWx1ZSc6XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZUZpZWxkID0gdGhpcy5maWVsZHMuZmluZCgoZikgPT4gZi5ubyA9PT0gNik7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RWYWx1ZUZpZWxkPy5raW5kICE9PSAnbWVzc2FnZScpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RWYWx1ZUZpZWxkLlQoKS50b0pzb24obWVzc2FnZS5raW5kLmxpc3RWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdzdHJ1Y3RWYWx1ZSc6XG4gICAgICAgICAgICAgICAgbGV0IHN0cnVjdFZhbHVlRmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKChmKSA9PiBmLm5vID09PSA1KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RydWN0VmFsdWVGaWVsZD8ua2luZCAhPT0gJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RWYWx1ZUZpZWxkLlQoKS50b0pzb24obWVzc2FnZS5raW5kLnN0cnVjdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYFZhbHVlYCBmcm9tIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uUmVhZChqc29uLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdudW1iZXJWYWx1ZScsIG51bWJlclZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdzdHJpbmdWYWx1ZScsIHN0cmluZ1ZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICB0YXJnZXQua2luZCA9IHsgb25lb2ZLaW5kOiAnYm9vbFZhbHVlJywgYm9vbFZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnbnVsbFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxWYWx1ZTogTnVsbFZhbHVlLk5VTExfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2xpc3RWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWU6IExpc3RWYWx1ZS5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3RydWN0VmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0VmFsdWU6IFN0cnVjdC5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCdVbmFibGUgdG8gcGFyc2UgJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGZyb20gSlNPTiAnICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mSnNvblZhbHVlKGpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmtpbmQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUgbnVsbF92YWx1ZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdudWxsVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFZhbHVlOiByZWFkZXIuaW50MzIoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBkb3VibGUgbnVtYmVyX3ZhbHVlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ251bWJlclZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlclZhbHVlOiByZWFkZXIuZG91YmxlKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHN0cmluZ192YWx1ZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdzdHJpbmdWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogcmVhZGVyLnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgYm9vbF92YWx1ZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdib29sVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbFZhbHVlOiByZWFkZXIuYm9vbCgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3Qgc3RydWN0X3ZhbHVlICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3N0cnVjdFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdFZhbHVlOiBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmtpbmQuc3RydWN0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbGlzdF92YWx1ZSAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdsaXN0VmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFZhbHVlOiBMaXN0VmFsdWUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmtpbmQubGlzdFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBudWxsX3ZhbHVlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdudWxsVmFsdWUnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uua2luZC5udWxsVmFsdWUpO1xuICAgICAgICAvKiBkb3VibGUgbnVtYmVyX3ZhbHVlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdudW1iZXJWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkJpdDY0KS5kb3VibGUobWVzc2FnZS5raW5kLm51bWJlclZhbHVlKTtcbiAgICAgICAgLyogc3RyaW5nIHN0cmluZ192YWx1ZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnc3RyaW5nVmFsdWUnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmtpbmQuc3RyaW5nVmFsdWUpO1xuICAgICAgICAvKiBib29sIGJvb2xfdmFsdWUgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ2Jvb2xWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmtpbmQuYm9vbFZhbHVlKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBzdHJ1Y3RfdmFsdWUgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ3N0cnVjdFZhbHVlJylcbiAgICAgICAgICAgIFN0cnVjdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uua2luZC5zdHJ1Y3RWYWx1ZSwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIGxpc3RfdmFsdWUgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ2xpc3RWYWx1ZScpXG4gICAgICAgICAgICBMaXN0VmFsdWUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmtpbmQubGlzdFZhbHVlLCB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVmFsdWVcbiAqL1xuY29uc3QgVmFsdWUgPSBuZXcgVmFsdWUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgTGlzdFZhbHVlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZXMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZhbHVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBgTGlzdFZhbHVlYCB0byBKU09OIGFycmF5LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudmFsdWVzLm1hcCgodikgPT4gVmFsdWUudG9Kc29uKHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGBMaXN0VmFsdWVgIGZyb20gSlNPTiBhcnJheS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25SZWFkKGpzb24sIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCdVbmFibGUgdG8gcGFyc2UgJyArXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArXG4gICAgICAgICAgICAgICAgJyBmcm9tIEpTT04gJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mSnNvblZhbHVlKGpzb24pKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBsZXQgdmFsdWVzID0ganNvbi5tYXAoKHYpID0+IFZhbHVlLmZyb21Kc29uKHYpKTtcbiAgICAgICAgdGFyZ2V0LnZhbHVlcy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSB2YWx1ZXMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaChWYWx1ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIHZhbHVlcyA9IDE7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBWYWx1ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXG4gKi9cbmNvbnN0IExpc3RWYWx1ZSA9IG5ldyBMaXN0VmFsdWUkVHlwZSgpO1xuXG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUaW1lc3RhbXAkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2Vjb25kcycsIGtpbmQ6ICdzY2FsYXInLCBUOiAzIC8qU2NhbGFyVHlwZS5JTlQ2NCovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnbmFub3MnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGltZXN0YW1wYCBmb3IgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKi9cbiAgICBub3coKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGNvbnN0IG1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbXNnLnNlY29uZHMgPSBQYkxvbmcuZnJvbShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLnRvU3RyaW5nKCk7XG4gICAgICAgIG1zZy5uYW5vcyA9IChtcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgRGF0ZS5cbiAgICAgKi9cbiAgICB0b0RhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoUGJMb25nLmZyb20obWVzc2FnZS5zZWNvbmRzKS50b051bWJlcigpICogMTAwMCArXG4gICAgICAgICAgICBNYXRoLmNlaWwobWVzc2FnZS5uYW5vcyAvIDEwMDAwMDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBKYXZhU2NyaXB0IERhdGUgdG8gYSBgVGltZXN0YW1wYC5cbiAgICAgKi9cbiAgICBmcm9tRGF0ZShkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGNvbnN0IG1zID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIG1zZy5zZWNvbmRzID0gUGJMb25nLmZyb20oTWF0aC5mbG9vcihtcyAvIDEwMDApKS50b1N0cmluZygpO1xuICAgICAgICBtc2cubmFub3MgPSAobXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIEpTT04gZm9ybWF0LCB0aGUgYFRpbWVzdGFtcGAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIFJGQyAzMzM5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBtcyA9IFBiTG9uZy5mcm9tKG1lc3NhZ2Uuc2Vjb25kcykudG9OdW1iZXIoKSAqIDEwMDA7XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoJzAwMDEtMDEtMDFUMDA6MDA6MDBaJykgfHxcbiAgICAgICAgICAgIG1zID4gRGF0ZS5wYXJzZSgnOTk5OS0xMi0zMVQyMzo1OTo1OVonKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGVuY29kZSBUaW1lc3RhbXAgdG8gSlNPTi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS4nKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubmFub3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZW5jb2RlIGludmFsaWQgVGltZXN0YW1wIHRvIEpTT04uIE5hbm9zIG11c3Qgbm90IGJlIG5lZ2F0aXZlLicpO1xuICAgICAgICBsZXQgeiA9ICdaJztcbiAgICAgICAgaWYgKG1lc3NhZ2UubmFub3MgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbmFub3NTdHIgPSAobWVzc2FnZS5uYW5vcyArIDEwMDAwMDAwMDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKG5hbm9zU3RyLnN1YnN0cmluZygzKSA9PT0gJzAwMDAwMCcpXG4gICAgICAgICAgICAgICAgeiA9ICcuJyArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArICdaJztcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gJzAwMCcpXG4gICAgICAgICAgICAgICAgeiA9ICcuJyArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArICdaJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB6ID0gJy4nICsgbmFub3NTdHIgKyAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJy4wMDBaJywgeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIEpTT04gZm9ybWF0LCB0aGUgYFRpbWVzdGFtcGAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIFJGQyAzMzM5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25SZWFkKGpzb24sIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTiAnICsgdHlwZW9mSnNvblZhbHVlKGpzb24pICsgJy4nKTtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTi4gSW52YWxpZCBmb3JtYXQuJyk7XG4gICAgICAgIGxldCBtcyA9IERhdGUucGFyc2UobWF0Y2hlc1sxXSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbWF0Y2hlc1syXSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbWF0Y2hlc1szXSArXG4gICAgICAgICAgICAnVCcgK1xuICAgICAgICAgICAgbWF0Y2hlc1s0XSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgbWF0Y2hlc1s1XSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgbWF0Y2hlc1s2XSArXG4gICAgICAgICAgICAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiAnWicpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OLiBJbnZhbGlkIHZhbHVlLicpO1xuICAgICAgICBpZiAobXMgPCBEYXRlLnBhcnNlKCcwMDAxLTAxLTAxVDAwOjAwOjAwWicpIHx8XG4gICAgICAgICAgICBtcyA+IERhdGUucGFyc2UoJzk5OTktMTItMzFUMjM6NTk6NTlaJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcignVW5hYmxlIHRvIHBhcnNlIFRpbWVzdGFtcCBmcm9tIEpTT04uIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuJyk7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgdGFyZ2V0LnNlY29uZHMgPSBQYkxvbmcuZnJvbShtcyAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIHRhcmdldC5uYW5vcyA9IDA7XG4gICAgICAgIGlmIChtYXRjaGVzWzddKVxuICAgICAgICAgICAgdGFyZ2V0Lm5hbm9zID1cbiAgICAgICAgICAgICAgICBwYXJzZUludCgnMScgKyBtYXRjaGVzWzddICsgJzAnLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtXG4gICAgICAgICAgICAgICAgICAgIDEwMDAwMDAwMDA7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vjb25kcyA9ICcwJztcbiAgICAgICAgbWVzc2FnZS5uYW5vcyA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDY0IHNlY29uZHMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWNvbmRzID0gcmVhZGVyLmludDY0KCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBuYW5vcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbm9zID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGludDY0IHNlY29uZHMgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZWNvbmRzICE9PSAnMCcpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50NjQobWVzc2FnZS5zZWNvbmRzKTtcbiAgICAgICAgLyogaW50MzIgbmFub3MgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uYW5vcyAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm5hbm9zKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcbiAqL1xuY29uc3QgVGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcCRUeXBlKCk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGVcbiAqL1xudmFyIFBlZXJUeXBlO1xuKGZ1bmN0aW9uIChQZWVyVHlwZSkge1xuICAgIC8qKlxuICAgICAqIHRvZG8gZml4IG1lIChtYXJjZWxvKVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBFRVJfVFlQRV9QVUJMSVNIRVJfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFBlZXJUeXBlW1BlZXJUeXBlW1wiUFVCTElTSEVSX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlBVQkxJU0hFUl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQRUVSX1RZUEVfU1VCU0NSSUJFUiA9IDE7XG4gICAgICovXG4gICAgUGVlclR5cGVbUGVlclR5cGVbXCJTVUJTQ1JJQkVSXCJdID0gMV0gPSBcIlNVQlNDUklCRVJcIjtcbn0pKFBlZXJUeXBlIHx8IChQZWVyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5XG4gKi9cbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogQ09OTkVDVElPTl9RVUFMSVRZX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9QT09SID0gMTtcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIlBPT1JcIl0gPSAxXSA9IFwiUE9PUlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBDT05ORUNUSU9OX1FVQUxJVFlfR09PRCA9IDI7XG4gICAgICovXG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJHT09EXCJdID0gMl0gPSBcIkdPT0RcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogQ09OTkVDVElPTl9RVUFMSVRZX0VYQ0VMTEVOVCA9IDM7XG4gICAgICovXG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJFWENFTExFTlRcIl0gPSAzXSA9IFwiRVhDRUxMRU5UXCI7XG59KShDb25uZWN0aW9uUXVhbGl0eSB8fCAoQ29ubmVjdGlvblF1YWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHlcbiAqL1xudmFyIFZpZGVvUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9RdWFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfTE9XX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkxPV19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBWSURFT19RVUFMSVRZX01JRCA9IDE7XG4gICAgICovXG4gICAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1JRFwiXSA9IDFdID0gXCJNSURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVklERU9fUVVBTElUWV9ISUdIID0gMjtcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiSElHSFwiXSA9IDJdID0gXCJISUdIXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfT0ZGID0gMztcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiT0ZGXCJdID0gM10gPSBcIk9GRlwiO1xufSkoVmlkZW9RdWFsaXR5IHx8IChWaWRlb1F1YWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGVcbiAqL1xudmFyIFRyYWNrVHlwZTtcbihmdW5jdGlvbiAoVHJhY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJVTlNQRUNJRklFRFwiXSA9IDBdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX0FVRElPID0gMTtcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiQVVESU9cIl0gPSAxXSA9IFwiQVVESU9cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVFlQRV9WSURFTyA9IDI7XG4gICAgICovXG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlZJREVPXCJdID0gMl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFID0gMztcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiU0NSRUVOX1NIQVJFXCJdID0gM10gPSBcIlNDUkVFTl9TSEFSRVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1NDUkVFTl9TSEFSRV9BVURJTyA9IDQ7XG4gICAgICovXG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlNDUkVFTl9TSEFSRV9BVURJT1wiXSA9IDRdID0gXCJTQ1JFRU5fU0hBUkVfQVVESU9cIjtcbn0pKFRyYWNrVHlwZSB8fCAoVHJhY2tUeXBlID0ge30pKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX05PVF9GT1VORCA9IDEwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUFVCTElTSF9UUkFDS19OT1RfRk9VTkRcIl0gPSAxMDBdID0gXCJQVUJMSVNIX1RSQUNLX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BVQkxJU0hfVFJBQ0tTX01JU01BVENIID0gMTAxO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQVUJMSVNIX1RSQUNLU19NSVNNQVRDSFwiXSA9IDEwMV0gPSBcIlBVQkxJU0hfVFJBQ0tTX01JU01BVENIXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUFVCTElTSF9UUkFDS19PVVRfT0ZfT1JERVIgPSAxMDI7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBVQkxJU0hfVFJBQ0tfT1VUX09GX09SREVSXCJdID0gMTAyXSA9IFwiUFVCTElTSF9UUkFDS19PVVRfT0ZfT1JERVJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORCA9IDEwMztcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUFVCTElTSF9UUkFDS19WSURFT19MQVlFUl9OT1RfRk9VTkRcIl0gPSAxMDNdID0gXCJQVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0xJVkVfRU5ERUQgPSAxMDQ7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkxJVkVfRU5ERURcIl0gPSAxMDRdID0gXCJMSVZFX0VOREVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTk9UX0ZPVU5EID0gMjAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9OT1RfRk9VTkRcIl0gPSAyMDBdID0gXCJQQVJUSUNJUEFOVF9OT1RfRk9VTkRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9NSUdSQVRJTkdfT1VUID0gMjAxO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdfT1VUXCJdID0gMjAxXSA9IFwiUEFSVElDSVBBTlRfTUlHUkFUSU5HX09VVFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01JR1JBVElPTl9GQUlMRUQgPSAyMDI7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX01JR1JBVElPTl9GQUlMRURcIl0gPSAyMDJdID0gXCJQQVJUSUNJUEFOVF9NSUdSQVRJT05fRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUlHUkFUSU5HID0gMjAzO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdcIl0gPSAyMDNdID0gXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEID0gMjA0O1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEXCJdID0gMjA0XSA9IFwiUEFSVElDSVBBTlRfUkVDT05ORUNUX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01FRElBX1RSQU5TUE9SVF9GQUlMVVJFID0gMjA1O1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NRURJQV9UUkFOU1BPUlRfRkFJTFVSRVwiXSA9IDIwNV0gPSBcIlBBUlRJQ0lQQU5UX01FRElBX1RSQU5TUE9SVF9GQUlMVVJFXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfQ0FMTF9OT1RfRk9VTkQgPSAzMDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNBTExfTk9UX0ZPVU5EXCJdID0gMzAwXSA9IFwiQ0FMTF9OT1RfRk9VTkRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9SRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEID0gNDAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJSRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEXCJdID0gNDAwXSA9IFwiUkVRVUVTVF9WQUxJREFUSU9OX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1VOQVVUSEVOVElDQVRFRCA9IDQwMTtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gNDAxXSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEVSTUlTU0lPTl9ERU5JRUQgPSA0MDM7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gNDAzXSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9UT09fTUFOWV9SRVFVRVNUUyA9IDQyOTtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVE9PX01BTllfUkVRVUVTVFNcIl0gPSA0MjldID0gXCJUT09fTUFOWV9SRVFVRVNUU1wiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0lOVEVSTkFMX1NFUlZFUl9FUlJPUiA9IDUwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCJdID0gNTAwXSA9IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfU0ZVX1NIVVRUSU5HX0RPV04gPSA2MDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlNGVV9TSFVUVElOR19ET1dOXCJdID0gNjAwXSA9IFwiU0ZVX1NIVVRUSU5HX0RPV05cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9TRlVfRlVMTCA9IDcwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU0ZVX0ZVTExcIl0gPSA3MDBdID0gXCJTRlVfRlVMTFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlXG4gKi9cbnZhciBTZGtUeXBlO1xuKGZ1bmN0aW9uIChTZGtUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJVTlNQRUNJRklFRFwiXSA9IDBdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9SRUFDVCA9IDE7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiUkVBQ1RcIl0gPSAxXSA9IFwiUkVBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfQU5HVUxBUiA9IDI7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiQU5HVUxBUlwiXSA9IDJdID0gXCJBTkdVTEFSXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX0FORFJPSUQgPSAzO1xuICAgICAqL1xuICAgIFNka1R5cGVbU2RrVHlwZVtcIkFORFJPSURcIl0gPSAzXSA9IFwiQU5EUk9JRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9JT1MgPSA0O1xuICAgICAqL1xuICAgIFNka1R5cGVbU2RrVHlwZVtcIklPU1wiXSA9IDRdID0gXCJJT1NcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfRkxVVFRFUiA9IDU7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiRkxVVFRFUlwiXSA9IDVdID0gXCJGTFVUVEVSXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1JFQUNUX05BVElWRSA9IDY7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiUkVBQ1RfTkFUSVZFXCJdID0gNl0gPSBcIlJFQUNUX05BVElWRVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9VTklUWSA9IDc7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiVU5JVFlcIl0gPSA3XSA9IFwiVU5JVFlcIjtcbn0pKFNka1R5cGUgfHwgKFNka1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvblxuICovXG52YXIgVHJhY2tVbnB1Ymxpc2hSZWFzb247XG4oZnVuY3Rpb24gKFRyYWNrVW5wdWJsaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZSB3aGljaCBpcyB1c2VkIHdoZW4gdGhlIHNwZWNpZmljIHJlYXNvblxuICAgICAqIGZvciBtdXRpbmcgdGhlIHRyYWNrIGlzIG5vdCBrbm93bi5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB1c2VyIG11dGluZyB0aGVpciB0cmFja3MuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9VU0VSX01VVEVEID0gMTtcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIlVTRVJfTVVURURcIl0gPSAxXSA9IFwiVVNFUl9NVVRFRFwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgbXV0aW5nIHRoZSB0cmFjayBiZWNhdXNlIHRoZSBwZXJtaXNzaW9uIHRvXG4gICAgICogcHVibGlzaCB0aGUgdHJhY2sgaGFzIGJlZW4gcmV2b2tlZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1BFUk1JU1NJT05fUkVWT0tFRCA9IDI7XG4gICAgICovXG4gICAgVHJhY2tVbnB1Ymxpc2hSZWFzb25bVHJhY2tVbnB1Ymxpc2hSZWFzb25bXCJQRVJNSVNTSU9OX1JFVk9LRURcIl0gPSAyXSA9IFwiUEVSTUlTU0lPTl9SRVZPS0VEXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBtdXRpbmcgdGhlIHRyYWNrIGR1ZSB0byBtb2RlcmF0aW9uIGFjdGlvbnMuXG4gICAgICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBwZXJtaXNzaW9uIHJldm9rZWQgYmVjYXVzZSB0aGVcbiAgICAgKiBwYXJ0aWNpcGFudCBjYW4gdW5tdXRlIHRoZW1zZWx2ZXMgaGVyZSB3aGVyZWFzIGluIGNhc2VcbiAgICAgKiBvZiBcInBlcm1pc3Npb24gcmV2b2tlXCIgaXQgaXMgbm90IHBvc3NpYmxlIHVudGlsIHRoZVxuICAgICAqIGNhbGwgcGVybWlzc2lvbnMgYXJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9NT0RFUkFUSU9OID0gMztcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIk1PREVSQVRJT05cIl0gPSAzXSA9IFwiTU9ERVJBVElPTlwiO1xufSkoVHJhY2tVbnB1Ymxpc2hSZWFzb24gfHwgKFRyYWNrVW5wdWJsaXNoUmVhc29uID0ge30pKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuR29Bd2F5UmVhc29uXG4gKi9cbnZhciBHb0F3YXlSZWFzb247XG4oZnVuY3Rpb24gKEdvQXdheVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBHT19BV0FZX1JFQVNPTl9VTlNQRUNJRklFRCA9IDA7XG4gICAgICovXG4gICAgR29Bd2F5UmVhc29uW0dvQXdheVJlYXNvbltcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEdPX0FXQVlfUkVBU09OX1NIVVRUSU5HX0RPV04gPSAxO1xuICAgICAqL1xuICAgIEdvQXdheVJlYXNvbltHb0F3YXlSZWFzb25bXCJTSFVUVElOR19ET1dOXCJdID0gMV0gPSBcIlNIVVRUSU5HX0RPV05cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogR09fQVdBWV9SRUFTT05fUkVCQUxBTkNFID0gMjtcbiAgICAgKi9cbiAgICBHb0F3YXlSZWFzb25bR29Bd2F5UmVhc29uW1wiUkVCQUxBTkNFXCJdID0gMl0gPSBcIlJFQkFMQU5DRVwiO1xufSkoR29Bd2F5UmVhc29uIHx8IChHb0F3YXlSZWFzb24gPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbFN0YXRlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcnRpY2lwYW50cycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3N0YXJ0ZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9jb3VudCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwaW5zJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5waW5zID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50cyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cy5wdXNoKFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgc3RhcnRlZF9hdCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0YXJ0ZWRBdCA9IFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuc3RhcnRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRDb3VudCA9IFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGlucy5wdXNoKFBpbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnRzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcnRpY2lwYW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudHNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydGVkX2F0ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5zdGFydGVkQXQsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zID0gNDsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBQaW4uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBpbnNbaV0sIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZVxuICovXG5jb25zdCBDYWxsU3RhdGUkMSA9IG5ldyBDYWxsU3RhdGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRDb3VudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd0b3RhbCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdhbm9ueW1vdXMnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnRvdGFsID0gMDtcbiAgICAgICAgbWVzc2FnZS5hbm9ueW1vdXMgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgdG90YWwgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3RhbCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgYW5vbnltb3VzICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYW5vbnltb3VzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiB1aW50MzIgdG90YWwgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50b3RhbCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS50b3RhbCk7XG4gICAgICAgIC8qIHVpbnQzMiBhbm9ueW1vdXMgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5hbm9ueW1vdXMgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYW5vbnltb3VzKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50Q291bnRcbiAqL1xuY29uc3QgUGFydGljaXBhbnRDb3VudCA9IG5ldyBQYXJ0aWNpcGFudENvdW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBpbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluXG4gKi9cbmNvbnN0IFBpbiA9IG5ldyBQaW4kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3B1Ymxpc2hlZF90cmFja3MnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdqb2luZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja19sb29rdXBfcHJlZml4JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdDT05ORUNUSU9OX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICdpc19zcGVha2luZycsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaXNfZG9taW5hbnRfc3BlYWtlcicsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDksIG5hbWU6ICdhdWRpb19sZXZlbCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAyIC8qU2NhbGFyVHlwZS5GTE9BVCovIH0sXG4gICAgICAgICAgICB7IG5vOiAxMCwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDExLCBuYW1lOiAnaW1hZ2UnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDEyLCBuYW1lOiAnY3VzdG9tJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTdHJ1Y3QgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3JvbGVzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MgPSBbXTtcbiAgICAgICAgbWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCA9ICcnO1xuICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gMDtcbiAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuaW1hZ2UgPSAnJztcbiAgICAgICAgbWVzc2FnZS5yb2xlcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgcHVibGlzaGVkX3RyYWNrcyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSByZWFkZXIuaW50MzIoKSArIHJlYWRlci5wb3M7IHJlYWRlci5wb3MgPCBlOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcy5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBqb2luZWRfYXQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5qb2luZWRBdCA9IFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuam9pbmVkQXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0cmFja19sb29rdXBfcHJlZml4ICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXggPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGlzX3NwZWFraW5nICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNTcGVha2luZyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpc19kb21pbmFudF9zcGVha2VyICovIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGZsb2F0IGF1ZGlvX2xldmVsICovIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGltYWdlICovIDExOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmltYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tICovIDEyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1c3RvbSA9IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJpbmcgcm9sZXMgKi8gMTM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uucm9sZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSBwdWJsaXNoZWRfdHJhY2tzID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgd3JpdGVyLmludDMyKG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzW2ldKTtcbiAgICAgICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBqb2luZWRfYXQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5qb2luZWRBdClcbiAgICAgICAgICAgIFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uuam9pbmVkQXQsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyaW5nIHRyYWNrX2xvb2t1cF9wcmVmaXggPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXgpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eSBjb25uZWN0aW9uX3F1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5KTtcbiAgICAgICAgLyogYm9vbCBpc19zcGVha2luZyA9IDc7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmlzU3BlYWtpbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc1NwZWFraW5nKTtcbiAgICAgICAgLyogYm9vbCBpc19kb21pbmFudF9zcGVha2VyID0gODsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg4LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc0RvbWluYW50U3BlYWtlcik7XG4gICAgICAgIC8qIGZsb2F0IGF1ZGlvX2xldmVsID0gOTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXVkaW9MZXZlbCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoOSwgV2lyZVR5cGUuQml0MzIpLmZsb2F0KG1lc3NhZ2UuYXVkaW9MZXZlbCk7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMTA7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgLyogc3RyaW5nIGltYWdlID0gMTE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmltYWdlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMTEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaW1hZ2UpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSA9IDEyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jdXN0b20pXG4gICAgICAgICAgICBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmN1c3RvbSwgd3JpdGVyLnRhZygxMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyaW5nIHJvbGVzID0gMTM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5yb2xlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMTMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uucm9sZXNbaV0pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRcbiAqL1xuY29uc3QgUGFydGljaXBhbnQgPSBuZXcgUGFydGljaXBhbnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3RyZWFtUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU3RyZWFtUXVhbGl0eScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmlkZW9fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eScsXG4gICAgICAgICAgICAgICAgICAgIFZpZGVvUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgJ1ZJREVPX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnZpZGVvUXVhbGl0eSA9IDA7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmlkZW9RdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudmlkZW9RdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudmlkZW9RdWFsaXR5KTtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TdHJlYW1RdWFsaXR5XG4gKi9cbmNvbnN0IFN0cmVhbVF1YWxpdHkgPSBuZXcgU3RyZWFtUXVhbGl0eSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb0RpbWVuc2lvbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnd2lkdGgnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnaGVpZ2h0Jywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS53aWR0aCA9IDA7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIHdpZHRoICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIGhlaWdodCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogdWludDMyIHdpZHRoID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2lkdGggIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2Uud2lkdGgpO1xuICAgICAgICAvKiB1aW50MzIgaGVpZ2h0ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVpZ2h0ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvblxuICovXG5jb25zdCBWaWRlb0RpbWVuc2lvbiA9IG5ldyBWaWRlb0RpbWVuc2lvbiRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb0xheWVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3JpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlb19kaW1lbnNpb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0RpbWVuc2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAnYml0cmF0ZScsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdmcHMnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3F1YWxpdHknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHknLFxuICAgICAgICAgICAgICAgICAgICBWaWRlb1F1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdWSURFT19RVUFMSVRZXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJpZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLmJpdHJhdGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmZwcyA9IDA7XG4gICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyByaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gdmlkZW9fZGltZW5zaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmlkZW9EaW1lbnNpb24gPSBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UudmlkZW9EaW1lbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBiaXRyYXRlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYml0cmF0ZSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgZnBzICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnBzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSBxdWFsaXR5ICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgcmlkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmlkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5yaWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiB2aWRlb19kaW1lbnNpb24gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS52aWRlb0RpbWVuc2lvbilcbiAgICAgICAgICAgIFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS52aWRlb0RpbWVuc2lvbiwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiB1aW50MzIgYml0cmF0ZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmJpdHJhdGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYml0cmF0ZSk7XG4gICAgICAgIC8qIHVpbnQzMiBmcHMgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mcHMgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuZnBzKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5xdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucXVhbGl0eSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyXG4gKi9cbmNvbnN0IFZpZGVvTGF5ZXIgPSBuZXcgVmlkZW9MYXllciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb2RlYyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BheWxvYWRfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnZm10cF9saW5lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nsb2NrX3JhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2VuY29kaW5nX3BhcmFtZXRlcnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnZmVlZGJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLmZtdHBMaW5lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY2xvY2tSYXRlID0gMDtcbiAgICAgICAgbWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMgPSAnJztcbiAgICAgICAgbWVzc2FnZS5mZWVkYmFja3MgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIHBheWxvYWRfdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWRUeXBlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZm10cF9saW5lICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZm10cExpbmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIGNsb2NrX3JhdGUgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbG9ja1JhdGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGVuY29kaW5nX3BhcmFtZXRlcnMgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyaW5nIGZlZWRiYWNrcyAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZlZWRiYWNrcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHVpbnQzMiBwYXlsb2FkX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5wYXlsb2FkVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIHN0cmluZyBmbXRwX2xpbmUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mbXRwTGluZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZm10cExpbmUpO1xuICAgICAgICAvKiB1aW50MzIgY2xvY2tfcmF0ZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNsb2NrUmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5jbG9ja1JhdGUpO1xuICAgICAgICAvKiBzdHJpbmcgZW5jb2RpbmdfcGFyYW1ldGVycyA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVuY29kaW5nUGFyYW1ldGVycyAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXJcbiAgICAgICAgICAgICAgICAudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgICAgICAuc3RyaW5nKG1lc3NhZ2UuZW5jb2RpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyaW5nIGZlZWRiYWNrcyA9IDY7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5mZWVkYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZmVlZGJhY2tzW2ldKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjXG4gKi9cbmNvbnN0IENvZGVjID0gbmV3IENvZGVjJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmxldCBJQ0VUcmlja2xlJFR5cGUkMSA9IGNsYXNzIElDRVRyaWNrbGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ljZV9jYW5kaWRhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5pY2VDYW5kaWRhdGUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWNlX2NhbmRpZGF0ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlQ2FuZGlkYXRlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufTtcbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlXG4gKi9cbmNvbnN0IElDRVRyaWNrbGUkMSA9IG5ldyBJQ0VUcmlja2xlJFR5cGUkMSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVHJhY2tJbmZvJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndHJhY2tfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6ICdtaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICdkdHgnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA4LCBuYW1lOiAnc3RlcmVvJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogOSwgbmFtZTogJ3JlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIG1lc3NhZ2UubWlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuZHR4ID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2Uuc3RlcmVvID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UucmVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0cmFja19pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyIGxheWVycyAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKFZpZGVvTGF5ZXIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1pZCAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGR0eCAqLyA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmR0eCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBzdGVyZW8gKi8gODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGVyZW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgcmVkICovIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHRyYWNrX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHJhY2tJZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9MYXllciBsYXllcnMgPSA1OyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UubGF5ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVmlkZW9MYXllci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubGF5ZXJzW2ldLCB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmluZyBtaWQgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5taWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1pZCk7XG4gICAgICAgIC8qIGJvb2wgZHR4ID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZHR4ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoNywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuZHR4KTtcbiAgICAgICAgLyogYm9vbCBzdGVyZW8gPSA4OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zdGVyZW8gIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg4LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5zdGVyZW8pO1xuICAgICAgICAvKiBib29sIHJlZCA9IDk7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlZCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDksIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnJlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm9cbiAqL1xuY29uc3QgVHJhY2tJbmZvID0gbmV3IFRyYWNrSW5mbyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3R5cGUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjcmVhdGVkX2J5X3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaG9zdF91c2VyX2lkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiAnY3VzdG9tJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTdHJ1Y3QgfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6ICdjcmVhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICd1cGRhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLmlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuaG9zdFVzZXJJZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGlkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNyZWF0ZWRfYnlfdXNlcl9pZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWRCeVVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaG9zdF91c2VyX2lkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaG9zdFVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1c3RvbSA9IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGNyZWF0ZWRfYXQgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkQXQgPSBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNyZWF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB1cGRhdGVkX2F0ICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS51cGRhdGVkQXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICAvKiBzdHJpbmcgY3JlYXRlZF9ieV91c2VyX2lkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jcmVhdGVkQnlVc2VySWQpO1xuICAgICAgICAvKiBzdHJpbmcgaG9zdF91c2VyX2lkID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaG9zdFVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaG9zdFVzZXJJZCk7XG4gICAgICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3VzdG9tKVxuICAgICAgICAgICAgU3RydWN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jdXN0b20sIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBjcmVhdGVkX2F0ID0gNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jcmVhdGVkQXQsIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB1cGRhdGVkX2F0ID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS51cGRhdGVkQXQsIHdyaXRlci50YWcoNywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxcbiAqL1xuY29uc3QgQ2FsbCQxID0gbmV3IENhbGwkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xubGV0IEVycm9yJFR5cGUkMSA9IGNsYXNzIEVycm9yJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yQ29kZScsXG4gICAgICAgICAgICAgICAgICAgIEVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ0VSUk9SX0NPREVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtZXNzYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnc2hvdWxkX3JldHJ5Jywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jb2RlID0gMDtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlIGNvZGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1lc3NhZ2UgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgc2hvdWxkX3JldHJ5ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvckNvZGUgY29kZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb2RlKTtcbiAgICAgICAgLyogc3RyaW5nIG1lc3NhZ2UgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgLyogYm9vbCBzaG91bGRfcmV0cnkgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zaG91bGRSZXRyeSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnNob3VsZFJldHJ5KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufTtcbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvclxuICovXG5jb25zdCBFcnJvciQyID0gbmV3IEVycm9yJFR5cGUkMSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2xpZW50RGV0YWlscyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2xpZW50RGV0YWlscycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZGsnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFNkayB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ29zJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBPUyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ2Jyb3dzZXInLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IEJyb3dzZXIgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdkZXZpY2UnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IERldmljZSB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrIHNkayAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkayA9IFNkay5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuc2RrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUyBvcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9zID0gT1MuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLm9zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyIGJyb3dzZXIgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5icm93c2VyID0gQnJvd3Nlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuYnJvd3Nlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRGV2aWNlIGRldmljZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRldmljZSA9IERldmljZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrIHNkayA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkaylcbiAgICAgICAgICAgIFNkay5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uuc2RrLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLk9TIG9zID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3MpXG4gICAgICAgICAgICBPUy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uub3MsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlciBicm93c2VyID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnJvd3NlcilcbiAgICAgICAgICAgIEJyb3dzZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmJyb3dzZXIsIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRGV2aWNlIGRldmljZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRldmljZSlcbiAgICAgICAgICAgIERldmljZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZGV2aWNlLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzXG4gKi9cbmNvbnN0IENsaWVudERldGFpbHMgPSBuZXcgQ2xpZW50RGV0YWlscyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZGskVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlNkaycsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrVHlwZScsIFNka1R5cGUsICdTREtfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnbWFqb3InLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdtaW5vcicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ3BhdGNoJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLm1ham9yID0gJyc7XG4gICAgICAgIG1lc3NhZ2UubWlub3IgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wYXRjaCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1ham9yICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFqb3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1pbm9yICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWlub3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBhdGNoICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0Y2ggPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1R5cGUgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIG1ham9yID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWFqb3IgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1ham9yKTtcbiAgICAgICAgLyogc3RyaW5nIG1pbm9yID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWlub3IgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1pbm9yKTtcbiAgICAgICAgLyogc3RyaW5nIHBhdGNoID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF0Y2ggIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBhdGNoKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1xuICovXG5jb25zdCBTZGsgPSBuZXcgU2RrJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIE9TJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmNoaXRlY3R1cmUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAnJztcbiAgICAgICAgbWVzc2FnZS5hcmNoaXRlY3R1cmUgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB2ZXJzaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgYXJjaGl0ZWN0dXJlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXJjaGl0ZWN0dXJlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICAvKiBzdHJpbmcgYXJjaGl0ZWN0dXJlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXJjaGl0ZWN0dXJlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5hcmNoaXRlY3R1cmUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuT1NcbiAqL1xuY29uc3QgT1MgPSBuZXcgT1MkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQnJvd3NlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlcicsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHZlcnNpb24gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlclxuICovXG5jb25zdCBCcm93c2VyID0gbmV3IEJyb3dzZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgRGV2aWNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnbmFtZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3ZlcnNpb24nLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB2ZXJzaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgLyogc3RyaW5nIHZlcnNpb24gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZVxuICovXG5jb25zdCBEZXZpY2UgPSBuZXcgRGV2aWNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENhbGxHcmFudHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHMnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nhbl9wdWJsaXNoX2F1ZGlvJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYW5fcHVibGlzaF92aWRlbycsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2FuX3NjcmVlbnNoYXJlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5jYW5TY3JlZW5zaGFyZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9wdWJsaXNoX2F1ZGlvICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9wdWJsaXNoX3ZpZGVvICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuUHVibGlzaFZpZGVvID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9zY3JlZW5zaGFyZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhblNjcmVlbnNoYXJlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogYm9vbCBjYW5fcHVibGlzaF9hdWRpbyA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhblB1Ymxpc2hBdWRpbyAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmNhblB1Ymxpc2hBdWRpbyk7XG4gICAgICAgIC8qIGJvb2wgY2FuX3B1Ymxpc2hfdmlkZW8gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8pO1xuICAgICAgICAvKiBib29sIGNhbl9zY3JlZW5zaGFyZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhblNjcmVlbnNoYXJlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuY2FuU2NyZWVuc2hhcmUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50c1xuICovXG5jb25zdCBDYWxsR3JhbnRzID0gbmV3IENhbGxHcmFudHMkVHlwZSgpO1xuXG52YXIgbW9kZWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBCcm93c2VyOiBCcm93c2VyLFxuICAgIENhbGw6IENhbGwkMSxcbiAgICBDYWxsR3JhbnRzOiBDYWxsR3JhbnRzLFxuICAgIENhbGxTdGF0ZTogQ2FsbFN0YXRlJDEsXG4gICAgQ2xpZW50RGV0YWlsczogQ2xpZW50RGV0YWlscyxcbiAgICBDb2RlYzogQ29kZWMsXG4gICAgZ2V0IENvbm5lY3Rpb25RdWFsaXR5ICgpIHsgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5OyB9LFxuICAgIERldmljZTogRGV2aWNlLFxuICAgIEVycm9yOiBFcnJvciQyLFxuICAgIGdldCBFcnJvckNvZGUgKCkgeyByZXR1cm4gRXJyb3JDb2RlOyB9LFxuICAgIGdldCBHb0F3YXlSZWFzb24gKCkgeyByZXR1cm4gR29Bd2F5UmVhc29uOyB9LFxuICAgIElDRVRyaWNrbGU6IElDRVRyaWNrbGUkMSxcbiAgICBPUzogT1MsXG4gICAgUGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LFxuICAgIFBhcnRpY2lwYW50Q291bnQ6IFBhcnRpY2lwYW50Q291bnQsXG4gICAgZ2V0IFBlZXJUeXBlICgpIHsgcmV0dXJuIFBlZXJUeXBlOyB9LFxuICAgIFBpbjogUGluLFxuICAgIFNkazogU2RrLFxuICAgIGdldCBTZGtUeXBlICgpIHsgcmV0dXJuIFNka1R5cGU7IH0sXG4gICAgU3RyZWFtUXVhbGl0eTogU3RyZWFtUXVhbGl0eSxcbiAgICBUcmFja0luZm86IFRyYWNrSW5mbyxcbiAgICBnZXQgVHJhY2tUeXBlICgpIHsgcmV0dXJuIFRyYWNrVHlwZTsgfSxcbiAgICBnZXQgVHJhY2tVbnB1Ymxpc2hSZWFzb24gKCkgeyByZXR1cm4gVHJhY2tVbnB1Ymxpc2hSZWFzb247IH0sXG4gICAgVmlkZW9EaW1lbnNpb246IFZpZGVvRGltZW5zaW9uLFxuICAgIFZpZGVvTGF5ZXI6IFZpZGVvTGF5ZXIsXG4gICAgZ2V0IFZpZGVvUXVhbGl0eSAoKSB7IHJldHVybiBWaWRlb1F1YWxpdHk7IH1cbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQGdlbmVyYXRlZCBieSBwcm90b2J1Zi10cyAyLjkuMyB3aXRoIHBhcmFtZXRlciBsb25nX3R5cGVfc3RyaW5nLGNsaWVudF9nZW5lcmljLHNlcnZlcl9ub25lLGVzbGludF9kaXNhYmxlXG4vLyBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmlsZSBcInZpZGVvL3NmdS9zaWduYWxfcnBjL3NpZ25hbC5wcm90b1wiIChwYWNrYWdlIFwic3RyZWFtLnZpZGVvLnNmdS5zaWduYWxcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZW5kU3RhdHNSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9zdGF0cycsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwdWJsaXNoZXJfc3RhdHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnd2VicnRjX3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdzZGsnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2RrX3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlclN0YXRzID0gJyc7XG4gICAgICAgIG1lc3NhZ2UucHVibGlzaGVyU3RhdHMgPSAnJztcbiAgICAgICAgbWVzc2FnZS53ZWJydGNWZXJzaW9uID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2RrID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2RrVmVyc2lvbiA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zdGF0cyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJTdGF0cyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcHVibGlzaGVyX3N0YXRzICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaGVyU3RhdHMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHdlYnJ0Y192ZXJzaW9uICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2VicnRjVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RrICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RrID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZGtfdmVyc2lvbiAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNka1ZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zdGF0cyA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnN1YnNjcmliZXJTdGF0cyAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc3Vic2NyaWJlclN0YXRzKTtcbiAgICAgICAgLyogc3RyaW5nIHB1Ymxpc2hlcl9zdGF0cyA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnB1Ymxpc2hlclN0YXRzICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5wdWJsaXNoZXJTdGF0cyk7XG4gICAgICAgIC8qIHN0cmluZyB3ZWJydGNfdmVyc2lvbiA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLndlYnJ0Y1ZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLndlYnJ0Y1ZlcnNpb24pO1xuICAgICAgICAvKiBzdHJpbmcgc2RrID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RrICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZGspO1xuICAgICAgICAvKiBzdHJpbmcgc2RrX3ZlcnNpb24gPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZGtWZXJzaW9uICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZGtWZXJzaW9uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1JlcXVlc3RcbiAqL1xuY29uc3QgU2VuZFN0YXRzUmVxdWVzdCA9IG5ldyBTZW5kU3RhdHNSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNlbmRTdGF0c1Jlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZVxuICovXG5jb25zdCBTZW5kU3RhdHNSZXNwb25zZSA9IG5ldyBTZW5kU3RhdHNSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VSZXN0YXJ0UmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXF1ZXN0XG4gKi9cbmNvbnN0IElDRVJlc3RhcnRSZXF1ZXN0ID0gbmV3IElDRVJlc3RhcnRSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVJlc3RhcnRSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZVxuICovXG5jb25zdCBJQ0VSZXN0YXJ0UmVzcG9uc2UgPSBuZXcgSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ211dGVfc3RhdGVzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja011dGVTdGF0ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLm11dGVTdGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGUgbXV0ZV9zdGF0ZXMgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlU3RhdGVzLnB1c2goVHJhY2tNdXRlU3RhdGUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZSBtdXRlX3N0YXRlcyA9IDM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5tdXRlU3RhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVHJhY2tNdXRlU3RhdGUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLm11dGVTdGF0ZXNbaV0sIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0XG4gKi9cbmNvbnN0IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0ID0gbmV3IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZVxuICovXG5jb25zdCBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UgPSBuZXcgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrTXV0ZVN0YXRlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtdXRlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgbXV0ZWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAgICAgLyogYm9vbCBtdXRlZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm11dGVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXV0ZWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGVcbiAqL1xuY29uc3QgVHJhY2tNdXRlU3RhdGUgPSBuZXcgVHJhY2tNdXRlU3RhdGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9NdXRlQ2hhbmdlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuQXVkaW9NdXRlQ2hhbmdlZCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdtdXRlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBtdXRlZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogYm9vbCBtdXRlZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm11dGVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXV0ZWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuQXVkaW9NdXRlQ2hhbmdlZFxuICovXG5uZXcgQXVkaW9NdXRlQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb011dGVDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5WaWRlb011dGVDaGFuZ2VkJywgW1xuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ211dGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIG11dGVkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBib29sIG11dGVkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5WaWRlb011dGVDaGFuZ2VkXG4gKi9cbm5ldyBWaWRlb011dGVDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyB0cmFja3MgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja3MucHVzaChUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgdHJhY2tzID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UudHJhY2tzW2ldLCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdFxuICovXG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCA9IG5ldyBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2VcbiAqL1xuY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja190eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2RpbWVuc2lvbicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gVmlkZW9EaW1lbnNpb24gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiBkaW1lbnNpb24gKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1lbnNpb24gPSBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRyYWNrVHlwZSk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIGRpbWVuc2lvbiA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRpbWVuc2lvbilcbiAgICAgICAgICAgIFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5kaW1lbnNpb24sIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1xuICovXG5jb25zdCBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgPSBuZXcgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNlbmRBbnN3ZXJSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZScsIFBlZXJUeXBlLCAnUEVFUl9UWVBFXyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVxdWVzdFxuICovXG5jb25zdCBTZW5kQW5zd2VyUmVxdWVzdCA9IG5ldyBTZW5kQW5zd2VyUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZW5kQW5zd2VyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVzcG9uc2VcbiAqL1xuY29uc3QgU2VuZEFuc3dlclJlc3BvbnNlID0gbmV3IFNlbmRBbnN3ZXJSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VUcmlja2xlUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2VcbiAqL1xuY29uc3QgSUNFVHJpY2tsZVJlc3BvbnNlID0gbmV3IElDRVRyaWNrbGVSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZXRQdWJsaXNoZXJSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja0luZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50cmFja3MgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gdHJhY2tzICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tzLnB1c2goVHJhY2tJbmZvLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIHRyYWNrcyA9IDM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS50cmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBUcmFja0luZm8uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnRyYWNrc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVxdWVzdFxuICovXG5jb25zdCBTZXRQdWJsaXNoZXJSZXF1ZXN0ID0gbmV3IFNldFB1Ymxpc2hlclJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdpY2VfcmVzdGFydCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5pY2VSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpY2VfcmVzdGFydCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBFcnJvciQyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBib29sIGljZV9yZXN0YXJ0ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlUmVzdGFydCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmljZVJlc3RhcnQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlc3BvbnNlXG4gKi9cbmNvbnN0IFNldFB1Ymxpc2hlclJlc3BvbnNlID0gbmV3IFNldFB1Ymxpc2hlclJlc3BvbnNlJFR5cGUoKTtcbi8qKlxuICogQGdlbmVyYXRlZCBTZXJ2aWNlVHlwZSBmb3IgcHJvdG9idWYgc2VydmljZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TaWduYWxTZXJ2ZXJcbiAqL1xuY29uc3QgU2lnbmFsU2VydmVyID0gbmV3IFNlcnZpY2VUeXBlKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TaWduYWxTZXJ2ZXInLCBbXG4gICAge1xuICAgICAgICBuYW1lOiAnU2V0UHVibGlzaGVyJyxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIEk6IFNldFB1Ymxpc2hlclJlcXVlc3QsXG4gICAgICAgIE86IFNldFB1Ymxpc2hlclJlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnU2VuZEFuc3dlcicsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgICAgICAgTzogU2VuZEFuc3dlclJlc3BvbnNlLFxuICAgIH0sXG4gICAgeyBuYW1lOiAnSWNlVHJpY2tsZScsIG9wdGlvbnM6IHt9LCBJOiBJQ0VUcmlja2xlJDEsIE86IElDRVRyaWNrbGVSZXNwb25zZSB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1VwZGF0ZVN1YnNjcmlwdGlvbnMnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QsXG4gICAgICAgIE86IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1VwZGF0ZU11dGVTdGF0ZXMnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QsXG4gICAgICAgIE86IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0ljZVJlc3RhcnQnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogSUNFUmVzdGFydFJlcXVlc3QsXG4gICAgICAgIE86IElDRVJlc3RhcnRSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1NlbmRTdGF0cycsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBTZW5kU3RhdHNSZXF1ZXN0LFxuICAgICAgICBPOiBTZW5kU3RhdHNSZXNwb25zZSxcbiAgICB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eVxuICovXG52YXIgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHk7XG4oZnVuY3Rpb24gKFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5KSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX0hJR0hfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1ZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1wiSElHSF9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJISUdIX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX0xPVyA9IDE7XG4gICAgICovXG4gICAgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbXCJMT1dcIl0gPSAxXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX01FRElVTSA9IDI7XG4gICAgICovXG4gICAgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbXCJNRURJVU1cIl0gPSAyXSA9IFwiTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX1ZFUllfTE9XID0gMztcbiAgICAgKi9cbiAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtcIlZFUllfTE9XXCJdID0gM10gPSBcIlZFUllfTE9XXCI7XG59KShWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSB8fCAoVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkgPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2Z1RXZlbnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1RXZlbnQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1YnNjcmliZXJfb2ZmZXInLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gU3Vic2NyaWJlck9mZmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAncHVibGlzaGVyX2Fuc3dlcicsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQdWJsaXNoZXJBbnN3ZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpb19sZXZlbF9jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWNlX3RyaWNrbGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSUNFVHJpY2tsZSQxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hhbmdlX3B1Ymxpc2hfcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEwLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9qb2luZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRKb2luZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGFydGljaXBhbnRfbGVmdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQYXJ0aWNpcGFudExlZnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnZG9taW5hbnRfc3BlYWtlcl9jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IERvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnam9pbl9yZXNwb25zZScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBKb2luUmVzcG9uc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaGVhbHRoX2NoZWNrX3Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEhlYWx0aENoZWNrUmVzcG9uc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxNixcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfcHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrUHVibGlzaGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrX3VucHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrVW5wdWJsaXNoZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gRXJyb3IkMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDE5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYWxsX2dyYW50c191cGRhdGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IENhbGxHcmFudHNVcGRhdGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMjAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvX2F3YXknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gR29Bd2F5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMjEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ljZV9yZXN0YXJ0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IElDRVJlc3RhcnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyMixcbiAgICAgICAgICAgICAgICBuYW1lOiAncGluc191cGRhdGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBpbnNDaGFuZ2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlciBzdWJzY3JpYmVyX29mZmVyICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3Vic2NyaWJlck9mZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuc3Vic2NyaWJlck9mZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlciBwdWJsaXNoZXJfYW5zd2VyICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAncHVibGlzaGVyQW5zd2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlckFuc3dlcjogUHVibGlzaGVyQW5zd2VyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQucHVibGlzaGVyQW5zd2VyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCBjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZCBhdWRpb19sZXZlbF9jaGFuZ2VkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnYXVkaW9MZXZlbENoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9MZXZlbENoYW5nZWQ6IEF1ZGlvTGV2ZWxDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuYXVkaW9MZXZlbENoYW5nZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUgaWNlX3RyaWNrbGUgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdpY2VUcmlja2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljZVRyaWNrbGU6IElDRVRyaWNrbGUkMS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmljZVRyaWNrbGUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHkgY2hhbmdlX3B1Ymxpc2hfcXVhbGl0eSAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNoYW5nZVB1Ymxpc2hRdWFsaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCAqLyAxMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwYXJ0aWNpcGFudEpvaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudEpvaW5lZDogUGFydGljaXBhbnRKb2luZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudEpvaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudExlZnQgcGFydGljaXBhbnRfbGVmdCAqLyAxMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwYXJ0aWNpcGFudExlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRMZWZ0OiBQYXJ0aWNpcGFudExlZnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudExlZnQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZCBkb21pbmFudF9zcGVha2VyX2NoYW5nZWQgKi8gMTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21pbmFudFNwZWFrZXJDaGFuZ2VkOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuZG9taW5hbnRTcGVha2VyQ2hhbmdlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSAqLyAxMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdqb2luUmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pblJlc3BvbnNlOiBKb2luUmVzcG9uc2UuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5qb2luUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZSBoZWFsdGhfY2hlY2tfcmVzcG9uc2UgKi8gMTQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnaGVhbHRoQ2hlY2tSZXNwb25zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhDaGVja1Jlc3BvbnNlOiBIZWFsdGhDaGVja1Jlc3BvbnNlLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuaGVhbHRoQ2hlY2tSZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZCB0cmFja19wdWJsaXNoZWQgKi8gMTY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAndHJhY2tQdWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tQdWJsaXNoZWQ6IFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tQdWJsaXNoZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCAqLyAxNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICd0cmFja1VucHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVW5wdWJsaXNoZWQ6IFRyYWNrVW5wdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC50cmFja1VucHVibGlzaGVkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yIGVycm9yICovIDE4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBFcnJvciQxLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQgY2FsbF9ncmFudHNfdXBkYXRlZCAqLyAxOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdjYWxsR3JhbnRzVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsR3JhbnRzVXBkYXRlZDogQ2FsbEdyYW50c1VwZGF0ZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5jYWxsR3JhbnRzVXBkYXRlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXkgZ29fYXdheSAqLyAyMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdnb0F3YXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ29Bd2F5OiBHb0F3YXkuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5nb0F3YXkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCAqLyAyMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdpY2VSZXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljZVJlc3RhcnQ6IElDRVJlc3RhcnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5pY2VSZXN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkIHBpbnNfdXBkYXRlZCAqLyAyMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwaW5zVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5zVXBkYXRlZDogUGluc0NoYW5nZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5waW5zVXBkYXRlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU3Vic2NyaWJlck9mZmVyIHN1YnNjcmliZXJfb2ZmZXIgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnc3Vic2NyaWJlck9mZmVyJylcbiAgICAgICAgICAgIFN1YnNjcmliZXJPZmZlci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnN1YnNjcmliZXJPZmZlciwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlciBwdWJsaXNoZXJfYW5zd2VyID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3B1Ymxpc2hlckFuc3dlcicpXG4gICAgICAgICAgICBQdWJsaXNoZXJBbnN3ZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5wdWJsaXNoZXJBbnN3ZXIsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgY29ubmVjdGlvbl9xdWFsaXR5X2NoYW5nZWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJylcbiAgICAgICAgICAgIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkIGF1ZGlvX2xldmVsX2NoYW5nZWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnYXVkaW9MZXZlbENoYW5nZWQnKVxuICAgICAgICAgICAgQXVkaW9MZXZlbENoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5hdWRpb0xldmVsQ2hhbmdlZCwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlIGljZV90cmlja2xlID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2ljZVRyaWNrbGUnKVxuICAgICAgICAgICAgSUNFVHJpY2tsZSQxLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaWNlVHJpY2tsZSwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNoYW5nZVB1Ymxpc2hRdWFsaXR5IGNoYW5nZV9wdWJsaXNoX3F1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY2hhbmdlUHVibGlzaFF1YWxpdHknKVxuICAgICAgICAgICAgQ2hhbmdlUHVibGlzaFF1YWxpdHkuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5jaGFuZ2VQdWJsaXNoUXVhbGl0eSwgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCA9IDEwOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncGFydGljaXBhbnRKb2luZWQnKVxuICAgICAgICAgICAgUGFydGljaXBhbnRKb2luZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudEpvaW5lZCwgd3JpdGVyLnRhZygxMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudExlZnQgcGFydGljaXBhbnRfbGVmdCA9IDExOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncGFydGljaXBhbnRMZWZ0JylcbiAgICAgICAgICAgIFBhcnRpY2lwYW50TGVmdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBhcnRpY2lwYW50TGVmdCwgd3JpdGVyLnRhZygxMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Eb21pbmFudFNwZWFrZXJDaGFuZ2VkIGRvbWluYW50X3NwZWFrZXJfY2hhbmdlZCA9IDEyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcpXG4gICAgICAgICAgICBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuZG9taW5hbnRTcGVha2VyQ2hhbmdlZCwgd3JpdGVyLnRhZygxMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSA9IDEzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnam9pblJlc3BvbnNlJylcbiAgICAgICAgICAgIEpvaW5SZXNwb25zZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmpvaW5SZXNwb25zZSwgd3JpdGVyLnRhZygxMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlIGhlYWx0aF9jaGVja19yZXNwb25zZSA9IDE0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaGVhbHRoQ2hlY2tSZXNwb25zZScpXG4gICAgICAgICAgICBIZWFsdGhDaGVja1Jlc3BvbnNlLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaGVhbHRoQ2hlY2tSZXNwb25zZSwgd3JpdGVyLnRhZygxNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZCB0cmFja19wdWJsaXNoZWQgPSAxNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3RyYWNrUHVibGlzaGVkJylcbiAgICAgICAgICAgIFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tQdWJsaXNoZWQsIHdyaXRlci50YWcoMTYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCA9IDE3OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpXG4gICAgICAgICAgICBUcmFja1VucHVibGlzaGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tVbnB1Ymxpc2hlZCwgd3JpdGVyLnRhZygxNywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvciBlcnJvciA9IDE4OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZXJyb3InKVxuICAgICAgICAgICAgRXJyb3IkMS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmVycm9yLCB3cml0ZXIudGFnKDE4LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkIGNhbGxfZ3JhbnRzX3VwZGF0ZWQgPSAxOTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2NhbGxHcmFudHNVcGRhdGVkJylcbiAgICAgICAgICAgIENhbGxHcmFudHNVcGRhdGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuY2FsbEdyYW50c1VwZGF0ZWQsIHdyaXRlci50YWcoMTksIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5IGdvX2F3YXkgPSAyMDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2dvQXdheScpXG4gICAgICAgICAgICBHb0F3YXkuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5nb0F3YXksIHdyaXRlci50YWcoMjAsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCA9IDIxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaWNlUmVzdGFydCcpXG4gICAgICAgICAgICBJQ0VSZXN0YXJ0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaWNlUmVzdGFydCwgd3JpdGVyLnRhZygyMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QaW5zQ2hhbmdlZCBwaW5zX3VwZGF0ZWQgPSAyMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3BpbnNVcGRhdGVkJylcbiAgICAgICAgICAgIFBpbnNDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQucGluc1VwZGF0ZWQsIHdyaXRlci50YWcoMjIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlNmdUV2ZW50XG4gKi9cbmNvbnN0IFNmdUV2ZW50ID0gbmV3IFNmdUV2ZW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBpbnNDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwaW5zJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5waW5zID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGlucy5wdXNoKFBpbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGlucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFBpbi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGluc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QaW5zQ2hhbmdlZFxuICovXG5jb25zdCBQaW5zQ2hhbmdlZCA9IG5ldyBQaW5zQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBFcnJvciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvcicsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yXG4gKi9cbmNvbnN0IEVycm9yJDEgPSBuZXcgRXJyb3IkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSUNFVHJpY2tsZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VUcmlja2xlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpY2VfY2FuZGlkYXRlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5pY2VDYW5kaWRhdGUgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWNlX2NhbmRpZGF0ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlQ2FuZGlkYXRlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VUcmlja2xlXG4gKi9cbmNvbnN0IElDRVRyaWNrbGUgPSBuZXcgSUNFVHJpY2tsZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VSZXN0YXJ0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVJlc3RhcnQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVJlc3RhcnRcbiAqL1xuY29uc3QgSUNFUmVzdGFydCA9IG5ldyBJQ0VSZXN0YXJ0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNmdVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1UmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnam9pbl9yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdyZXF1ZXN0UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSm9pblJlcXVlc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWFsdGhfY2hlY2tfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAncmVxdWVzdFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEhlYWx0aENoZWNrUmVxdWVzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0IGpvaW5fcmVxdWVzdCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnam9pblJlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pblJlcXVlc3Q6IEpvaW5SZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5qb2luUmVxdWVzdCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1JlcXVlc3QgaGVhbHRoX2NoZWNrX3JlcXVlc3QgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2hlYWx0aENoZWNrUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhDaGVja1JlcXVlc3Q6IEhlYWx0aENoZWNrUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQuaGVhbHRoQ2hlY2tSZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdCBqb2luX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5vbmVvZktpbmQgPT09ICdqb2luUmVxdWVzdCcpXG4gICAgICAgICAgICBKb2luUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucmVxdWVzdFBheWxvYWQuam9pblJlcXVlc3QsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1JlcXVlc3QgaGVhbHRoX2NoZWNrX3JlcXVlc3QgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5vbmVvZktpbmQgPT09ICdoZWFsdGhDaGVja1JlcXVlc3QnKVxuICAgICAgICAgICAgSGVhbHRoQ2hlY2tSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5oZWFsdGhDaGVja1JlcXVlc3QsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1UmVxdWVzdFxuICovXG5jb25zdCBTZnVSZXF1ZXN0ID0gbmV3IFNmdVJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSGVhbHRoQ2hlY2tSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCcsIFtdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0XG4gKi9cbmNvbnN0IEhlYWx0aENoZWNrUmVxdWVzdCA9IG5ldyBIZWFsdGhDaGVja1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSGVhbHRoQ2hlY2tSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9jb3VudCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQgPSBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2VcbiAqL1xuY29uc3QgSGVhbHRoQ2hlY2tSZXNwb25zZSA9IG5ldyBIZWFsdGhDaGVja1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrUHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUnLFxuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICdUUkFDS19UWVBFXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZFxuICovXG5jb25zdCBUcmFja1B1Ymxpc2hlZCA9IG5ldyBUcmFja1B1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1VucHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrVW5wdWJsaXNoZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2F1c2UnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvbicsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVW5wdWJsaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogJ3BhcnRpY2lwYW50Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBQYXJ0aWNpcGFudCB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5jYXVzZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uIGNhdXNlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F1c2UgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tVbnB1Ymxpc2hSZWFzb24gY2F1c2UgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYXVzZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNhdXNlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1VucHVibGlzaGVkXG4gKi9cbmNvbnN0IFRyYWNrVW5wdWJsaXNoZWQgPSBuZXcgVHJhY2tVbnB1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBKb2luUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd0b2tlbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9zZHAnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xpZW50X2RldGFpbHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDbGllbnREZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdtaWdyYXRpb24nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IE1pZ3JhdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmYXN0X3JlY29ubmVjdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudG9rZW4gPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyU2RwID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuZmFzdFJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdG9rZW4gKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zZHAgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyU2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHMgY2xpZW50X2RldGFpbHMgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGllbnREZXRhaWxzID0gQ2xpZW50RGV0YWlscy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY2xpZW50RGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb24gbWlncmF0aW9uICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWlncmF0aW9uID0gTWlncmF0aW9uLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5taWdyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgZmFzdF9yZWNvbm5lY3QgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mYXN0UmVjb25uZWN0ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHRva2VuID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW4gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnRva2VuKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmluZyBzdWJzY3JpYmVyX3NkcCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnN1YnNjcmliZXJTZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnN1YnNjcmliZXJTZHApO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzIGNsaWVudF9kZXRhaWxzID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2xpZW50RGV0YWlscylcbiAgICAgICAgICAgIENsaWVudERldGFpbHMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNsaWVudERldGFpbHMsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb24gbWlncmF0aW9uID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWlncmF0aW9uKVxuICAgICAgICAgICAgTWlncmF0aW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5taWdyYXRpb24sIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogYm9vbCBmYXN0X3JlY29ubmVjdCA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmZhc3RSZWNvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5mYXN0UmVjb25uZWN0KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlcXVlc3RcbiAqL1xuY29uc3QgSm9pblJlcXVlc3QgPSBuZXcgSm9pblJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgTWlncmF0aW9uJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50Lk1pZ3JhdGlvbicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZnJvbV9zZnVfaWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnYW5ub3VuY2VkX3RyYWNrcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tJbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZnJvbVNmdUlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuYW5ub3VuY2VkVHJhY2tzID0gW107XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZnJvbV9zZnVfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tU2Z1SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIGFubm91bmNlZF90cmFja3MgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbm5vdW5jZWRUcmFja3MucHVzaChUcmFja0luZm8uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHN1YnNjcmlwdGlvbnMgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb25zLnB1c2goVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgZnJvbV9zZnVfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mcm9tU2Z1SWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmZyb21TZnVJZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbyBhbm5vdW5jZWRfdHJhY2tzID0gMjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmFubm91bmNlZFRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuYW5ub3VuY2VkVHJhY2tzW2ldLCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyBzdWJzY3JpcHRpb25zID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnN1YnNjcmlwdGlvbnNbaV0sIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uXG4gKi9cbmNvbnN0IE1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSm9pblJlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdjYWxsX3N0YXRlJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBDYWxsU3RhdGUkMSB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3JlY29ubmVjdGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUgY2FsbF9zdGF0ZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxTdGF0ZSA9IENhbGxTdGF0ZSQxLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jYWxsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgcmVjb25uZWN0ZWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNvbm5lY3RlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZSBjYWxsX3N0YXRlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FsbFN0YXRlKVxuICAgICAgICAgICAgQ2FsbFN0YXRlJDEuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNhbGxTdGF0ZSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBib29sIHJlY29ubmVjdGVkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjb25uZWN0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5yZWNvbm5lY3RlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZVxuICovXG5jb25zdCBKb2luUmVzcG9uc2UgPSBuZXcgSm9pblJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBhcnRpY2lwYW50Sm9pbmVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfY2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNhbGxDaWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNhbGxfY2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FsbENpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIGNhbGxfY2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FsbENpZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuY2FsbENpZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGFydGljaXBhbnQsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRKb2luZWRcbiAqL1xuY29uc3QgUGFydGljaXBhbnRKb2luZWQgPSBuZXcgUGFydGljaXBhbnRKb2luZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRMZWZ0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdjYWxsX2NpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3BhcnRpY2lwYW50Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBQYXJ0aWNpcGFudCB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jYWxsQ2lkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBjYWxsX2NpZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxDaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5wYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBjYWxsX2NpZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhbGxDaWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNhbGxDaWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50LCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdFxuICovXG5jb25zdCBQYXJ0aWNpcGFudExlZnQgPSBuZXcgUGFydGljaXBhbnRMZWZ0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFN1YnNjcmliZXJPZmZlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TdWJzY3JpYmVyT2ZmZXInLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnaWNlX3Jlc3RhcnQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpY2VfcmVzdGFydCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGJvb2wgaWNlX3Jlc3RhcnQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VSZXN0YXJ0ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaWNlUmVzdGFydCk7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlclxuICovXG5jb25zdCBTdWJzY3JpYmVyT2ZmZXIgPSBuZXcgU3Vic2NyaWJlck9mZmVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFB1Ymxpc2hlckFuc3dlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QdWJsaXNoZXJBbnN3ZXInLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QdWJsaXNoZXJBbnN3ZXJcbiAqL1xuY29uc3QgUHVibGlzaGVyQW5zd2VyID0gbmV3IFB1Ymxpc2hlckFuc3dlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0aW9uX3F1YWxpdHlfdXBkYXRlcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIGNvbm5lY3Rpb25fcXVhbGl0eV91cGRhdGVzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzLnB1c2goQ29ubmVjdGlvblF1YWxpdHlJbmZvLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5SW5mbyBjb25uZWN0aW9uX3F1YWxpdHlfdXBkYXRlcyA9IDE7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBDb25uZWN0aW9uUXVhbGl0eUluZm8uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcbiAqL1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gbmV3IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUluZm8kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdDT05ORUNUSU9OX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eSBjb25uZWN0aW9uX3F1YWxpdHkgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUluZm9cbiAqL1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gbmV3IENvbm5lY3Rpb25RdWFsaXR5SW5mbyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBEb21pbmFudFNwZWFrZXJDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWRcbiAqL1xuY29uc3QgRG9taW5hbnRTcGVha2VyQ2hhbmdlZCA9IG5ldyBEb21pbmFudFNwZWFrZXJDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvTGV2ZWwkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ2xldmVsJywga2luZDogJ3NjYWxhcicsIFQ6IDIgLypTY2FsYXJUeXBlLkZMT0FUKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdpc19zcGVha2luZycsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UubGV2ZWwgPSAwO1xuICAgICAgICBtZXNzYWdlLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZmxvYXQgbGV2ZWwgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgaXNfc3BlYWtpbmcgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBmbG9hdCBsZXZlbCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmxldmVsICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5CaXQzMikuZmxvYXQobWVzc2FnZS5sZXZlbCk7XG4gICAgICAgIC8qIGJvb2wgaXNfc3BlYWtpbmcgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pc1NwZWFraW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaXNTcGVha2luZyk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxcbiAqL1xuY29uc3QgQXVkaW9MZXZlbCA9IG5ldyBBdWRpb0xldmVsJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvTGV2ZWxDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpb19sZXZlbHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTGV2ZWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVscyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbHMucHVzaChBdWRpb0xldmVsLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmF1ZGlvTGV2ZWxzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgQXVkaW9MZXZlbC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuYXVkaW9MZXZlbHNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWRcbiAqL1xuY29uc3QgQXVkaW9MZXZlbENoYW5nZWQgPSBuZXcgQXVkaW9MZXZlbENoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9NZWRpYVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2NoYW5uZWxfY291bnQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jaGFubmVsQ291bnQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBjaGFubmVsX2NvdW50ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhbm5lbENvdW50ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGludDMyIGNoYW5uZWxfY291bnQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsQ291bnQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jaGFubmVsQ291bnQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdFxuICovXG5jb25zdCBBdWRpb01lZGlhUmVxdWVzdCA9IG5ldyBBdWRpb01lZGlhUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBBdWRpb1NlbmRlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWVkaWFfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTWVkaWFSZXF1ZXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lZGlhUmVxdWVzdCA9IEF1ZGlvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5tZWRpYVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZWRpYVJlcXVlc3QpXG4gICAgICAgICAgICBBdWRpb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubWVkaWFSZXF1ZXN0LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZWMpXG4gICAgICAgICAgICBDb2RlYy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY29kZWMsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXJcbiAqL1xuY29uc3QgQXVkaW9TZW5kZXIgPSBuZXcgQXVkaW9TZW5kZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2lkZWFsX2hlaWdodCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnaWRlYWxfd2lkdGgnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpZGVhbF9mcmFtZV9yYXRlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSAwO1xuICAgICAgICBtZXNzYWdlLmlkZWFsV2lkdGggPSAwO1xuICAgICAgICBtZXNzYWdlLmlkZWFsRnJhbWVSYXRlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgaWRlYWxfaGVpZ2h0ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF93aWR0aCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZWFsV2lkdGggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF9mcmFtZV9yYXRlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlYWxGcmFtZVJhdGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogaW50MzIgaWRlYWxfaGVpZ2h0ID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxIZWlnaHQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbEhlaWdodCk7XG4gICAgICAgIC8qIGludDMyIGlkZWFsX3dpZHRoID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxXaWR0aCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmlkZWFsV2lkdGgpO1xuICAgICAgICAvKiBpbnQzMiBpZGVhbF9mcmFtZV9yYXRlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxGcmFtZVJhdGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0XG4gKi9cbmNvbnN0IFZpZGVvTWVkaWFSZXF1ZXN0ID0gbmV3IFZpZGVvTWVkaWFSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTGF5ZXJTZXR0aW5nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdhY3RpdmUnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnbWF4X2JpdHJhdGUnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDIgLypTY2FsYXJUeXBlLkZMT0FUKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcmlvcml0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHknLFxuICAgICAgICAgICAgICAgICAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgJ1BSSU9SSVRZXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA2LCBuYW1lOiAnY29kZWMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENvZGVjIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ21heF9mcmFtZXJhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5tYXhCaXRyYXRlID0gMDtcbiAgICAgICAgbWVzc2FnZS5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSAwO1xuICAgICAgICBtZXNzYWdlLnByaW9yaXR5ID0gMDtcbiAgICAgICAgbWVzc2FnZS5tYXhGcmFtZXJhdGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBhY3RpdmUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3RpdmUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIG1heF9iaXRyYXRlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4Qml0cmF0ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGZsb2F0IHNjYWxlX3Jlc29sdXRpb25fZG93bl9ieSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmlvcml0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBtYXhfZnJhbWVyYXRlICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4RnJhbWVyYXRlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBib29sIGFjdGl2ZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGl2ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmFjdGl2ZSk7XG4gICAgICAgIC8qIGludDMyIG1heF9iaXRyYXRlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4Qml0cmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm1heEJpdHJhdGUpO1xuICAgICAgICAvKiBmbG9hdCBzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zY2FsZVJlc29sdXRpb25Eb3duQnkgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkJpdDMyKS5mbG9hdChtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wcmlvcml0eSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnByaW9yaXR5KTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb2RlYylcbiAgICAgICAgICAgIENvZGVjLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jb2RlYywgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiB1aW50MzIgbWF4X2ZyYW1lcmF0ZSA9IDc7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1heEZyYW1lcmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNywgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5tYXhGcmFtZXJhdGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZ1xuICovXG5jb25zdCBWaWRlb0xheWVyU2V0dGluZyA9IG5ldyBWaWRlb0xheWVyU2V0dGluZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb1NlbmRlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWVkaWFfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvTWVkaWFSZXF1ZXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyU2V0dGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QgPSBWaWRlb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UubWVkaWFSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGVjID0gQ29kZWMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNvZGVjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nIGxheWVycyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKFZpZGVvTGF5ZXJTZXR0aW5nLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZWRpYVJlcXVlc3QpXG4gICAgICAgICAgICBWaWRlb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubWVkaWFSZXF1ZXN0LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZWMpXG4gICAgICAgICAgICBDb2RlYy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY29kZWMsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZyBsYXllcnMgPSAzOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UubGF5ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVmlkZW9MYXllclNldHRpbmcuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmxheWVyc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlclxuICovXG5jb25zdCBWaWRlb1NlbmRlciA9IG5ldyBWaWRlb1NlbmRlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXVkaW9fc2VuZGVycycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQXVkaW9TZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlb19zZW5kZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb1NlbmRlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmF1ZGlvU2VuZGVycyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnZpZGVvU2VuZGVycyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyIGF1ZGlvX3NlbmRlcnMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdWRpb1NlbmRlcnMucHVzaChBdWRpb1NlbmRlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyIHZpZGVvX3NlbmRlcnMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52aWRlb1NlbmRlcnMucHVzaChWaWRlb1NlbmRlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlciBhdWRpb19zZW5kZXJzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmF1ZGlvU2VuZGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIEF1ZGlvU2VuZGVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5hdWRpb1NlbmRlcnNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlciB2aWRlb19zZW5kZXJzID0gMjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnZpZGVvU2VuZGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFZpZGVvU2VuZGVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS52aWRlb1NlbmRlcnNbaV0sIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHlcbiAqL1xuY29uc3QgQ2hhbmdlUHVibGlzaFF1YWxpdHkgPSBuZXcgQ2hhbmdlUHVibGlzaFF1YWxpdHkkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbEdyYW50c1VwZGF0ZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnY3VycmVudF9ncmFudHMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENhbGxHcmFudHMgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtZXNzYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50cyBjdXJyZW50X2dyYW50cyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1cnJlbnRHcmFudHMgPSBDYWxsR3JhbnRzLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jdXJyZW50R3JhbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHMgY3VycmVudF9ncmFudHMgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jdXJyZW50R3JhbnRzKVxuICAgICAgICAgICAgQ2FsbEdyYW50cy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY3VycmVudEdyYW50cywgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJpbmcgbWVzc2FnZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DYWxsR3JhbnRzVXBkYXRlZFxuICovXG5jb25zdCBDYWxsR3JhbnRzVXBkYXRlZCA9IG5ldyBDYWxsR3JhbnRzVXBkYXRlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBHb0F3YXkkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWFzb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb24nLFxuICAgICAgICAgICAgICAgICAgICBHb0F3YXlSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICdHT19BV0FZX1JFQVNPTl8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5yZWFzb24gPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb24gcmVhc29uICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkdvQXdheVJlYXNvbiByZWFzb24gPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWFzb24gIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5yZWFzb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXlcbiAqL1xuY29uc3QgR29Bd2F5ID0gbmV3IEdvQXdheSRUeXBlKCk7XG5cbnZhciBldmVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEF1ZGlvTGV2ZWw6IEF1ZGlvTGV2ZWwsXG4gICAgQXVkaW9MZXZlbENoYW5nZWQ6IEF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICAgIEF1ZGlvTWVkaWFSZXF1ZXN0OiBBdWRpb01lZGlhUmVxdWVzdCxcbiAgICBBdWRpb1NlbmRlcjogQXVkaW9TZW5kZXIsXG4gICAgQ2FsbEdyYW50c1VwZGF0ZWQ6IENhbGxHcmFudHNVcGRhdGVkLFxuICAgIENoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcbiAgICBDb25uZWN0aW9uUXVhbGl0eUluZm86IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcbiAgICBEb21pbmFudFNwZWFrZXJDaGFuZ2VkOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLFxuICAgIEVycm9yOiBFcnJvciQxLFxuICAgIEdvQXdheTogR29Bd2F5LFxuICAgIEhlYWx0aENoZWNrUmVxdWVzdDogSGVhbHRoQ2hlY2tSZXF1ZXN0LFxuICAgIEhlYWx0aENoZWNrUmVzcG9uc2U6IEhlYWx0aENoZWNrUmVzcG9uc2UsXG4gICAgSUNFUmVzdGFydDogSUNFUmVzdGFydCxcbiAgICBJQ0VUcmlja2xlOiBJQ0VUcmlja2xlLFxuICAgIEpvaW5SZXF1ZXN0OiBKb2luUmVxdWVzdCxcbiAgICBKb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSxcbiAgICBNaWdyYXRpb246IE1pZ3JhdGlvbixcbiAgICBQYXJ0aWNpcGFudEpvaW5lZDogUGFydGljaXBhbnRKb2luZWQsXG4gICAgUGFydGljaXBhbnRMZWZ0OiBQYXJ0aWNpcGFudExlZnQsXG4gICAgUGluc0NoYW5nZWQ6IFBpbnNDaGFuZ2VkLFxuICAgIFB1Ymxpc2hlckFuc3dlcjogUHVibGlzaGVyQW5zd2VyLFxuICAgIFNmdUV2ZW50OiBTZnVFdmVudCxcbiAgICBTZnVSZXF1ZXN0OiBTZnVSZXF1ZXN0LFxuICAgIFN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyLFxuICAgIFRyYWNrUHVibGlzaGVkOiBUcmFja1B1Ymxpc2hlZCxcbiAgICBUcmFja1VucHVibGlzaGVkOiBUcmFja1VucHVibGlzaGVkLFxuICAgIFZpZGVvTGF5ZXJTZXR0aW5nOiBWaWRlb0xheWVyU2V0dGluZyxcbiAgICBnZXQgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkgKCkgeyByZXR1cm4gVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHk7IH0sXG4gICAgVmlkZW9NZWRpYVJlcXVlc3Q6IFZpZGVvTWVkaWFSZXF1ZXN0LFxuICAgIFZpZGVvU2VuZGVyOiBWaWRlb1NlbmRlclxufSk7XG5cbnZhciBWaXNpYmlsaXR5U3RhdGU7XG4oZnVuY3Rpb24gKFZpc2liaWxpdHlTdGF0ZSkge1xuICAgIFZpc2liaWxpdHlTdGF0ZVtcIlVOS05PV05cIl0gPSBcIlVOS05PV05cIjtcbiAgICBWaXNpYmlsaXR5U3RhdGVbXCJWSVNJQkxFXCJdID0gXCJWSVNJQkxFXCI7XG4gICAgVmlzaWJpbGl0eVN0YXRlW1wiSU5WSVNJQkxFXCJdID0gXCJJTlZJU0lCTEVcIjtcbn0pKFZpc2liaWxpdHlTdGF0ZSB8fCAoVmlzaWJpbGl0eVN0YXRlID0ge30pKTtcbnZhciBEZWJvdW5jZVR5cGU7XG4oZnVuY3Rpb24gKERlYm91bmNlVHlwZSkge1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJJTU1FRElBVEVcIl0gPSAyMF0gPSBcIklNTUVESUFURVwiO1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJGQVNUXCJdID0gMTAwXSA9IFwiRkFTVFwiO1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJNRURJVU1cIl0gPSA2MDBdID0gXCJNRURJVU1cIjtcbiAgICBEZWJvdW5jZVR5cGVbRGVib3VuY2VUeXBlW1wiU0xPV1wiXSA9IDEyMDBdID0gXCJTTE9XXCI7XG59KShEZWJvdW5jZVR5cGUgfHwgKERlYm91bmNlVHlwZSA9IHt9KSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHNlcnZpY2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2lnbmFsU2VydmVyXG4gKi9cbmNsYXNzIFNpZ25hbFNlcnZlckNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoX3RyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSBfdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gU2lnbmFsU2VydmVyLnR5cGVOYW1lO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBTaWduYWxTZXJ2ZXIubWV0aG9kcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gU2lnbmFsU2VydmVyLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldFB1Ymxpc2hlciBzZW5kcyB0aGUgV2ViUlRDIG9mZmVyIGZvciB0aGUgcGVlciBjb25uZWN0aW9uIHVzZWQgdG8gcHVibGlzaCBBL1ZcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNldFB1Ymxpc2hlcihzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXNwb25zZSk7XG4gICAgICovXG4gICAgc2V0UHVibGlzaGVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1swXSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYW5zd2VyIGlzIHNlbnQgYnkgdGhlIGNsaWVudCB0byB0aGUgU0ZVIGFmdGVyIHJlY2VpdmluZyBhIHN1YnNjcmliZXJfb2ZmZXIuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBTZW5kQW5zd2VyKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVzcG9uc2UpO1xuICAgICAqL1xuICAgIHNlbmRBbnN3ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzFdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kSUNFQ2FuZGlkYXRlIHNlbmRzIGFuIElDRSBjYW5kaWRhdGUgdG8gdGhlIGNsaWVudFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogSWNlVHJpY2tsZShzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlKSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2UpO1xuICAgICAqL1xuICAgIGljZVRyaWNrbGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzJdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVTdWJzY3JpYmVycyBpcyB1c2VkIHRvIG5vdGlmeSB0aGUgU0ZVIGFib3V0IHRoZSBsaXN0IG9mIHZpZGVvIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBUT0RPOiBzeW5jIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gdGhpcyArIHVwZGF0ZSB0cmFja3MgdXNpbmcgdGhlIGRpbWVuc2lvbiBpbmZvIHNlbnQgYnkgdGhlIHVzZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZVN1YnNjcmlwdGlvbnMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSk7XG4gICAgICovXG4gICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbM10sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZU11dGVTdGF0ZXMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSk7XG4gICAgICovXG4gICAgdXBkYXRlTXV0ZVN0YXRlcyhpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbNF0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IEljZVJlc3RhcnQoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZSk7XG4gICAgICovXG4gICAgaWNlUmVzdGFydChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbNV0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNlbmRTdGF0cyhzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kU3RhdHNSZXNwb25zZSk7XG4gICAgICovXG4gICAgc2VuZFN0YXRzKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1s2XSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGJhc2VVcmw6ICcnLFxuICAgIHNlbmRKc29uOiB0cnVlLFxuICAgIHRpbWVvdXQ6IDUgKiAxMDAwLCAvLyBtcy5cbiAgICBqc29uT3B0aW9uczoge1xuICAgICAgICBpZ25vcmVVbmtub3duRmllbGRzOiB0cnVlLFxuICAgIH0sXG59O1xuY29uc3Qgd2l0aEhlYWRlcnMgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyY2VwdFVuYXJ5KG5leHQsIG1ldGhvZCwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0YSA9IHsgLi4ub3B0aW9ucy5tZXRhLCAuLi5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4gbmV4dChtZXRob2QsIGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogQ3JlYXRlcyBuZXcgU2lnbmFsU2VydmVyQ2xpZW50IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSB0d2lycCBvcHRpb25zLlxuICovXG5jb25zdCBjcmVhdGVTaWduYWxDbGllbnQgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBUd2lycEZldGNoVHJhbnNwb3J0KHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxTZXJ2ZXJDbGllbnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgd2UgYXJlIHVzaW5nIFJlYWN0IE5hdGl2ZVxuICovXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdD8udG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJztcbn07XG5cbi8vIGxvZyBsZXZlbHMsIHNvcnRlZCBieSB2ZXJib3NpdHlcbmNvbnN0IGxvZ0xldmVscyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRyYWNlOiAwLFxuICAgIGRlYnVnOiAxLFxuICAgIGluZm86IDIsXG4gICAgd2FybjogMyxcbiAgICBlcnJvcjogNCxcbn0pO1xubGV0IGxvZ2dlciQ0O1xubGV0IGxldmVsID0gJ2luZm8nO1xuY29uc3QgbG9nVG9Db25zb2xlID0gKGxvZ0xldmVsLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGxvZ01ldGhvZDtcbiAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBXQVJOOiAke21lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLndhcm47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJhY2UnOlxuICAgICAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS50cmFjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbG9nTWV0aG9kKG1lc3NhZ2UsIC4uLmFyZ3MpO1xufTtcbmNvbnN0IHNldExvZ2dlciA9IChsLCBsdmwpID0+IHtcbiAgICBsb2dnZXIkNCA9IGw7XG4gICAgaWYgKGx2bCkge1xuICAgICAgICBzZXRMb2dMZXZlbChsdmwpO1xuICAgIH1cbn07XG5jb25zdCBzZXRMb2dMZXZlbCA9IChsKSA9PiB7XG4gICAgbGV2ZWwgPSBsO1xufTtcbmNvbnN0IGdldExvZ2dlciA9ICh3aXRoVGFncykgPT4ge1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZCA9IGxvZ2dlciQ0IHx8IGxvZ1RvQ29uc29sZTtcbiAgICBjb25zdCB0YWdzID0gKHdpdGhUYWdzIHx8IFtdKS5qb2luKCc6Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGxvZ0xldmVsLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChsb2dMZXZlbHNbbG9nTGV2ZWxdID49IGxvZ0xldmVsc1tsZXZlbF0pIHtcbiAgICAgICAgICAgIGxvZ2dlck1ldGhvZChsb2dMZXZlbCwgYFske3RhZ3N9XTogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0UHJlZmVycmVkQ29kZWNzID0gKGtpbmQsIHByZWZlcnJlZENvZGVjLCBjb2RlY1RvUmVtb3ZlKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnY29kZWNzJ10pO1xuICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICAgICAgbG9nZ2VyPy4oJ3dhcm4nLCAnUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FwID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICBpZiAoIWNhcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICBjb25zdCBwYXJ0aWFsTWF0Y2hlZCA9IFtdO1xuICAgIGNvbnN0IHVubWF0Y2hlZCA9IFtdO1xuICAgIGNhcC5jb2RlY3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBjb2RlYyA9IGMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9nZ2VyPy4oJ2RlYnVnJywgYEZvdW5kIHN1cHBvcnRlZCBjb2RlYzogJHtjb2RlY31gKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlQ29kZWMgPSBjb2RlY1RvUmVtb3ZlICYmIGNvZGVjID09PSBgJHtraW5kfS8ke2NvZGVjVG9SZW1vdmUudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQ29kZWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1hdGNoZXNDb2RlYyA9IGNvZGVjID09PSBgJHtraW5kfS8ke3ByZWZlcnJlZENvZGVjLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgaWYgKCFtYXRjaGVzQ29kZWMpIHtcbiAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBoMjY0IGNvZGVjcyB0aGF0IGhhdmUgc2RwRm10cExpbmUgYXZhaWxhYmxlLCB1c2Ugb25seSBpZiB0aGVcbiAgICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoY29kZWMgPT09ICdoMjY0Jykge1xuICAgICAgICAgICAgaWYgKGMuc2RwRm10cExpbmUgJiYgYy5zZHBGbXRwTGluZS5pbmNsdWRlcygncHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5tYXRjaGVkLCAuLi5wYXJ0aWFsTWF0Y2hlZCwgLi4udW5tYXRjaGVkXTtcbiAgICBsb2dnZXI/LignaW5mbycsIGBQcmVmZmVyZWQgY29kZWNzOiBgLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZ2V0R2VuZXJpY1NkcCA9IGFzeW5jIChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCB0ZW1wUGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oKTtcbiAgICB0ZW1wUGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywgeyBkaXJlY3Rpb24gfSk7XG4gICAgdGVtcFBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uIH0pO1xuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGVtcFBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgbGV0IHNkcCA9IG9mZmVyLnNkcCA/PyAnJztcbiAgICB0ZW1wUGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICB0LnN0b3AoKTtcbiAgICB9KTtcbiAgICB0ZW1wUGMuY2xvc2UoKTtcbiAgICByZXR1cm4gc2RwO1xufTtcblxuY29uc3Qgc2Z1RXZlbnRLaW5kcyA9IHtcbiAgICBzdWJzY3JpYmVyT2ZmZXI6IHVuZGVmaW5lZCxcbiAgICBwdWJsaXNoZXJBbnN3ZXI6IHVuZGVmaW5lZCxcbiAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IHVuZGVmaW5lZCxcbiAgICBhdWRpb0xldmVsQ2hhbmdlZDogdW5kZWZpbmVkLFxuICAgIGljZVRyaWNrbGU6IHVuZGVmaW5lZCxcbiAgICBjaGFuZ2VQdWJsaXNoUXVhbGl0eTogdW5kZWZpbmVkLFxuICAgIHBhcnRpY2lwYW50Sm9pbmVkOiB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnRMZWZ0OiB1bmRlZmluZWQsXG4gICAgZG9taW5hbnRTcGVha2VyQ2hhbmdlZDogdW5kZWZpbmVkLFxuICAgIGpvaW5SZXNwb25zZTogdW5kZWZpbmVkLFxuICAgIGhlYWx0aENoZWNrUmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB0cmFja1B1Ymxpc2hlZDogdW5kZWZpbmVkLFxuICAgIHRyYWNrVW5wdWJsaXNoZWQ6IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgIGNhbGxHcmFudHNVcGRhdGVkOiB1bmRlZmluZWQsXG4gICAgZ29Bd2F5OiB1bmRlZmluZWQsXG4gICAgaWNlUmVzdGFydDogdW5kZWZpbmVkLFxuICAgIHBpbnNVcGRhdGVkOiB1bmRlZmluZWQsXG59O1xuY29uc3QgaXNTZnVFdmVudCA9IChldmVudE5hbWUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNmdUV2ZW50S2luZHMsIGV2ZW50TmFtZSk7XG59O1xuY2xhc3MgRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnRGlzcGF0Y2hlciddKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50S2luZCA9IG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZDtcbiAgICAgICAgICAgIGlmICghZXZlbnRLaW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlLmV2ZW50UGF5bG9hZFtldmVudEtpbmRdO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYERpc3BhdGNoaW5nICR7ZXZlbnRLaW5kfWAsIHBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpYmVyc1tldmVudEtpbmRdO1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnTGlzdGVuZXIgZmFpbGVkIHdpdGggZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24gPSAoZXZlbnROYW1lLCBmbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKChfYSA9IHRoaXMuc3Vic2NyaWJlcnMpW2V2ZW50TmFtZV0gPz8gKF9hW2V2ZW50TmFtZV0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgZm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbZXZlbnROYW1lXSA9ICh0aGlzLnN1YnNjcmliZXJzW2V2ZW50TmFtZV0gfHwgW10pLmZpbHRlcigoZikgPT4gZiAhPT0gZm4pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9mZkFsbCA9IChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBidWZmZXIgZm9yIElDRSBDYW5kaWRhdGVzLiBVc2VkIGZvciBJQ0UgVHJpY2tsZTpcbiAqIC0gaHR0cHM6Ly9ibG9nZ2Vlay5tZS93ZWJydGNnbG9zc2FyeS90cmlja2xlLWljZS9cbiAqL1xuY2xhc3MgSWNlVHJpY2tsZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlckNhbmRpZGF0ZXMgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlckNhbmRpZGF0ZXMgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ3NmdS1jbGllbnQnXSk7XG4gICAgICAgIHRoaXMucHVzaCA9IChpY2VUcmlja2xlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaWNlVHJpY2tsZS5wZWVyVHlwZSA9PT0gUGVlclR5cGUuU1VCU0NSSUJFUikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckNhbmRpZGF0ZXMubmV4dChpY2VUcmlja2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGljZVRyaWNrbGUucGVlclR5cGUgPT09IFBlZXJUeXBlLlBVQkxJU0hFUl9VTlNQRUNJRklFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyQ2FuZGlkYXRlcy5uZXh0KGljZVRyaWNrbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgSUNFVHJpY2tsZSwgVW5rbm93biBwZWVyIHR5cGVgLCBpY2VUcmlja2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBpZiAoIWNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50KSB7XG4gICAgICAgIC8vIHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBpbmNsdWRlIHVzZXJuYW1lRnJhZ21lbnQgaW4gdGhlIGNhbmRpZGF0ZVxuICAgICAgICBjb25zdCBzcGxpdHRlZENhbmRpZGF0ZSA9IGNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoJyAnKTtcbiAgICAgICAgY29uc3QgdWZyYWdJbmRleCA9IHNwbGl0dGVkQ2FuZGlkYXRlLmZpbmRJbmRleCgocykgPT4gcyA9PT0gJ3VmcmFnJykgKyAxO1xuICAgICAgICBjb25zdCB1c2VybmFtZUZyYWdtZW50ID0gc3BsaXR0ZWRDYW5kaWRhdGVbdWZyYWdJbmRleF07XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IC4uLmNhbmRpZGF0ZSwgdXNlcm5hbWVGcmFnbWVudCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUudG9KU09OKCkpO1xuICAgIH1cbn1cblxubGV0IHNka0luZm87XG5sZXQgb3NJbmZvO1xubGV0IGRldmljZUluZm87XG5sZXQgd2ViUnRjSW5mbztcbmNvbnN0IHNldFNka0luZm8gPSAoaW5mbykgPT4ge1xuICAgIHNka0luZm8gPSBpbmZvO1xufTtcbmNvbnN0IGdldFNka0luZm8gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHNka0luZm87XG59O1xuY29uc3Qgc2V0T1NJbmZvID0gKGluZm8pID0+IHtcbiAgICBvc0luZm8gPSBpbmZvO1xufTtcbmNvbnN0IGdldE9TSW5mbyA9ICgpID0+IHtcbiAgICByZXR1cm4gb3NJbmZvO1xufTtcbmNvbnN0IHNldERldmljZUluZm8gPSAoaW5mbykgPT4ge1xuICAgIGRldmljZUluZm8gPSBpbmZvO1xufTtcbmNvbnN0IGdldERldmljZUluZm8gPSAoKSA9PiB7XG4gICAgcmV0dXJuIGRldmljZUluZm87XG59O1xuY29uc3QgZ2V0V2ViUlRDSW5mbyA9ICgpID0+IHtcbiAgICByZXR1cm4gd2ViUnRjSW5mbztcbn07XG5jb25zdCBzZXRXZWJSVENJbmZvID0gKGluZm8pID0+IHtcbiAgICB3ZWJSdGNJbmZvID0gaW5mbztcbn07XG5jb25zdCBnZXRDbGllbnREZXRhaWxzID0gKCkgPT4ge1xuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgLy8gU2luY2UgUk4gZG9lc24ndCBzdXBwb3J0IHdlYiwgc2hhcmluZyBicm93c2VyIGluZm8gaXMgbm90IHJlcXVpcmVkXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZGs6IGdldFNka0luZm8oKSxcbiAgICAgICAgICAgIG9zOiBnZXRPU0luZm8oKSxcbiAgICAgICAgICAgIGRldmljZTogZ2V0RGV2aWNlSW5mbygpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuZXcgVUFQYXJzZXIobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgeyBicm93c2VyLCBvcywgZGV2aWNlLCBjcHUgfSA9IHVzZXJBZ2VudC5nZXRSZXN1bHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZGs6IGdldFNka0luZm8oKSxcbiAgICAgICAgYnJvd3Nlcjoge1xuICAgICAgICAgICAgbmFtZTogYnJvd3Nlci5uYW1lIHx8IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICB2ZXJzaW9uOiBicm93c2VyLnZlcnNpb24gfHwgJycsXG4gICAgICAgIH0sXG4gICAgICAgIG9zOiB7XG4gICAgICAgICAgICBuYW1lOiBvcy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgdmVyc2lvbjogb3MudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgICAgIGFyY2hpdGVjdHVyZTogY3B1LmFyY2hpdGVjdHVyZSB8fCAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgZGV2aWNlOiB7XG4gICAgICAgICAgICBuYW1lOiBbZGV2aWNlLnZlbmRvciwgZGV2aWNlLm1vZGVsLCBkZXZpY2UudHlwZV1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHZlcnNpb246ICcnLFxuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCBERUZBVUxUX0JJVFJBVEUgPSAxMjUwMDAwO1xuY29uc3QgZGVmYXVsdFRhcmdldFJlc29sdXRpb24gPSB7XG4gICAgYml0cmF0ZTogREVGQVVMVF9CSVRSQVRFLFxuICAgIHdpZHRoOiAxMjgwLFxuICAgIGhlaWdodDogNzIwLFxufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbW9zdCBvcHRpbWFsIHZpZGVvIGxheWVycyBmb3Igc2ltdWxjYXN0aW5nXG4gKiBmb3IgdGhlIGdpdmVuIHRyYWNrLlxuICpcbiAqIEBwYXJhbSB2aWRlb1RyYWNrIHRoZSB2aWRlbyB0cmFjayB0byBmaW5kIG9wdGltYWwgbGF5ZXJzIGZvci5cbiAqIEBwYXJhbSB0YXJnZXRSZXNvbHV0aW9uIHRoZSBleHBlY3RlZCB0YXJnZXQgcmVzb2x1dGlvbi5cbiAqL1xuY29uc3QgZmluZE9wdGltYWxWaWRlb0xheWVycyA9ICh2aWRlb1RyYWNrLCB0YXJnZXRSZXNvbHV0aW9uID0gZGVmYXVsdFRhcmdldFJlc29sdXRpb24pID0+IHtcbiAgICBjb25zdCBvcHRpbWFsVmlkZW9MYXllcnMgPSBbXTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCB7IHdpZHRoOiB3ID0gMCwgaGVpZ2h0OiBoID0gMCB9ID0gc2V0dGluZ3M7XG4gICAgY29uc3QgaXNSTklvcyA9IGlzUmVhY3ROYXRpdmUoKSAmJiBnZXRPU0luZm8oKT8ubmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW9zJztcbiAgICBjb25zdCBtYXhCaXRyYXRlID0gZ2V0Q29tcHV0ZWRNYXhCaXRyYXRlKHRhcmdldFJlc29sdXRpb24sIHcsIGgpO1xuICAgIGxldCBkb3duc2NhbGVGYWN0b3IgPSAxO1xuICAgIFsnZicsICdoJywgJ3EnXS5mb3JFYWNoKChyaWQpID0+IHtcbiAgICAgICAgLy8gUmV2ZXJzaW5nIHRoZSBvcmRlciBbZiwgaCwgcV0gdG8gW3EsIGgsIGZdIGFzIENocm9tZSB1c2VzIGVuY29kaW5nIGluZGV4XG4gICAgICAgIC8vIHdoZW4gZGVjaWRpbmcgd2hpY2ggbGF5ZXIgdG8gZGlzYWJsZSB3aGVuIENQVSBvciBiYW5kd2lkdGggaXMgY29uc3RyYWluZWQuXG4gICAgICAgIC8vIEVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWwgcmVzb2x1dGlvbiBvcmRlci5cbiAgICAgICAgb3B0aW1hbFZpZGVvTGF5ZXJzLnVuc2hpZnQoe1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgcmlkLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodyAvIGRvd25zY2FsZUZhY3RvciksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoaCAvIGRvd25zY2FsZUZhY3RvciksXG4gICAgICAgICAgICBtYXhCaXRyYXRlOiBNYXRoLnJvdW5kKG1heEJpdHJhdGUgLyBkb3duc2NhbGVGYWN0b3IpLFxuICAgICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBkb3duc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAvLyBTaW11bGNhc3Qgb24gaU9TIFJlYWN0LU5hdGl2ZSByZXF1aXJlcyBhbGwgZW5jb2RpbmdzIHRvIHNoYXJlIHRoZSBzYW1lIGZyYW1lcmF0ZVxuICAgICAgICAgICAgbWF4RnJhbWVyYXRlOiB7XG4gICAgICAgICAgICAgICAgZjogMzAsXG4gICAgICAgICAgICAgICAgaDogaXNSTklvcyA/IDMwIDogMjUsXG4gICAgICAgICAgICAgICAgcTogaXNSTklvcyA/IDMwIDogMjAsXG4gICAgICAgICAgICB9W3JpZF0sXG4gICAgICAgIH0pO1xuICAgICAgICBkb3duc2NhbGVGYWN0b3IgKj0gMjtcbiAgICB9KTtcbiAgICAvLyBmb3Igc2ltcGxpY2l0eSwgd2Ugc3RhcnQgd2l0aCBhbGwgbGF5ZXJzIGVuYWJsZWQsIHRoZW4gdGhpcyBmdW5jdGlvblxuICAgIC8vIHdpbGwgY2xlYXIvcmVhc3NpZ24gdGhlIGxheWVycyB0aGF0IGFyZSBub3QgbmVlZGVkXG4gICAgcmV0dXJuIHdpdGhTaW11bGNhc3RDb25zdHJhaW50cyhzZXR0aW5ncywgb3B0aW1hbFZpZGVvTGF5ZXJzKTtcbn07XG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIGJpdHJhdGUgZm9yIGEgZ2l2ZW4gcmVzb2x1dGlvbi5cbiAqIElmIHRoZSBjdXJyZW50IHJlc29sdXRpb24gaXMgbG93ZXIgdGhhbiB0aGUgdGFyZ2V0IHJlc29sdXRpb24sXG4gKiB3ZSB3YW50IHRvIHByb3BvcnRpb25hbGx5IHJlZHVjZSB0aGUgdGFyZ2V0IGJpdHJhdGUuXG4gKiBJZiB0aGUgY3VycmVudCByZXNvbHV0aW9uIGlzIGhpZ2hlciB0aGFuIHRoZSB0YXJnZXQgcmVzb2x1dGlvbixcbiAqIHdlIHdhbnQgdG8gdXNlIHRoZSB0YXJnZXQgYml0cmF0ZS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0UmVzb2x1dGlvbiB0aGUgdGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcGFyYW0gY3VycmVudFdpZHRoIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSB0cmFjay5cbiAqIEBwYXJhbSBjdXJyZW50SGVpZ2h0IHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgdHJhY2suXG4gKi9cbmNvbnN0IGdldENvbXB1dGVkTWF4Qml0cmF0ZSA9ICh0YXJnZXRSZXNvbHV0aW9uLCBjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHQpID0+IHtcbiAgICAvLyBpZiB0aGUgY3VycmVudCByZXNvbHV0aW9uIGlzIGxvd2VyIHRoYW4gdGhlIHRhcmdldCByZXNvbHV0aW9uLFxuICAgIC8vIHdlIHdhbnQgdG8gcHJvcG9ydGlvbmFsbHkgcmVkdWNlIHRoZSB0YXJnZXQgYml0cmF0ZVxuICAgIGNvbnN0IHsgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldEhlaWdodCB9ID0gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICBpZiAoY3VycmVudFdpZHRoIDwgdGFyZ2V0V2lkdGggfHwgY3VycmVudEhlaWdodCA8IHRhcmdldEhlaWdodCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGl4ZWxzID0gY3VycmVudFdpZHRoICogY3VycmVudEhlaWdodDtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGl4ZWxzID0gdGFyZ2V0V2lkdGggKiB0YXJnZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHJlZHVjdGlvbkZhY3RvciA9IGN1cnJlbnRQaXhlbHMgLyB0YXJnZXRQaXhlbHM7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRhcmdldFJlc29sdXRpb24uYml0cmF0ZSAqIHJlZHVjdGlvbkZhY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRSZXNvbHV0aW9uLmJpdHJhdGU7XG59O1xuLyoqXG4gKiBCcm93c2VycyBoYXZlIGRpZmZlcmVudCBzaW11bGNhc3QgY29uc3RyYWludHMgZm9yIGRpZmZlcmVudCB2aWRlbyByZXNvbHV0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBwcm92aWRlZCBsaXN0IG9mIHZpZGVvIGxheWVycyBhY2NvcmRpbmcgdG8gdGhlXG4gKiBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHNpbXVsY2FzdCBjb25zdHJhaW50cyBpbiB0aGUgQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMuXG4gKlxuICogaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2V4dGVybmFsL3dlYnJ0Yy8rL3JlZnMvaGVhZHMvbWFpbi9tZWRpYS9lbmdpbmUvc2ltdWxjYXN0LmNjIzkwXG4gKi9cbmNvbnN0IHdpdGhTaW11bGNhc3RDb25zdHJhaW50cyA9IChzZXR0aW5ncywgb3B0aW1hbFZpZGVvTGF5ZXJzKSA9PiB7XG4gICAgbGV0IGxheWVycztcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoc2V0dGluZ3Mud2lkdGggfHwgMCwgc2V0dGluZ3MuaGVpZ2h0IHx8IDApO1xuICAgIGlmIChzaXplIDw9IDMyMCkge1xuICAgICAgICAvLyBwcm92aWRlIG9ubHkgb25lIGxheWVyIDMyMHgyNDAgKHEpLCB0aGUgb25lIHdpdGggdGhlIGhpZ2hlc3QgcXVhbGl0eVxuICAgICAgICBsYXllcnMgPSBvcHRpbWFsVmlkZW9MYXllcnMuZmlsdGVyKChsYXllcikgPT4gbGF5ZXIucmlkID09PSAnZicpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDw9IDY0MCkge1xuICAgICAgICAvLyBwcm92aWRlIHR3byBsYXllcnMsIDE2MHgxMjAgKHEpIGFuZCA2NDB4NDgwIChoKVxuICAgICAgICBsYXllcnMgPSBvcHRpbWFsVmlkZW9MYXllcnMuZmlsdGVyKChsYXllcikgPT4gbGF5ZXIucmlkICE9PSAnaCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvdmlkZSB0aHJlZSBsYXllcnMgZm9yIHNpemVzID4gNjQweDQ4MFxuICAgICAgICBsYXllcnMgPSBvcHRpbWFsVmlkZW9MYXllcnM7XG4gICAgfVxuICAgIGNvbnN0IHJpZE1hcHBpbmcgPSBbJ3EnLCAnaCcsICdmJ107XG4gICAgcmV0dXJuIGxheWVycy5tYXAoKGxheWVyLCBpbmRleCkgPT4gKHtcbiAgICAgICAgLi4ubGF5ZXIsXG4gICAgICAgIHJpZDogcmlkTWFwcGluZ1tpbmRleF0sIC8vIHJlYXNzaWduIHJpZFxuICAgIH0pKTtcbn07XG5jb25zdCBmaW5kT3B0aW1hbFNjcmVlblNoYXJpbmdMYXllcnMgPSAodmlkZW9UcmFjaywgcHJlZmVyZW5jZXMpID0+IHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICByaWQ6ICdxJywgLy8gc2luZ2xlIHRyYWNrLCBzdGFydCBmcm9tICdxJ1xuICAgICAgICAgICAgd2lkdGg6IHNldHRpbmdzLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAxLFxuICAgICAgICAgICAgbWF4Qml0cmF0ZTogcHJlZmVyZW5jZXM/Lm1heEJpdHJhdGUgPz8gMzAwMDAwMCxcbiAgICAgICAgICAgIG1heEZyYW1lcmF0ZTogcHJlZmVyZW5jZXM/Lm1heEZyYW1lcmF0ZSA/PyAzMCxcbiAgICAgICAgfSxcbiAgICBdO1xufTtcblxuY29uc3QgdHJhY2tUeXBlVG9QYXJ0aWNpcGFudFN0cmVhbUtleSA9ICh0cmFja1R5cGUpID0+IHtcbiAgICBzd2l0Y2ggKHRyYWNrVHlwZSkge1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgICAgICByZXR1cm4gJ3NjcmVlblNoYXJlU3RyZWFtJztcbiAgICAgICAgY2FzZSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgICAgICAgcmV0dXJuICdzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtJztcbiAgICAgICAgY2FzZSBUcmFja1R5cGUuVklERU86XG4gICAgICAgICAgICByZXR1cm4gJ3ZpZGVvU3RyZWFtJztcbiAgICAgICAgY2FzZSBUcmFja1R5cGUuQVVESU86XG4gICAgICAgICAgICByZXR1cm4gJ2F1ZGlvU3RyZWFtJztcbiAgICAgICAgY2FzZSBUcmFja1R5cGUuVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYWNrIHR5cGUgaXMgdW5zcGVjaWZpZWQnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVUcmFja1R5cGVDaGVjayA9IHRyYWNrVHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0cmFjayB0eXBlOiAke2V4aGF1c3RpdmVUcmFja1R5cGVDaGVja31gKTtcbiAgICB9XG59O1xuY29uc3QgbXV0ZVR5cGVUb1RyYWNrVHlwZSA9IChtdXRlVHlwZSkgPT4ge1xuICAgIHN3aXRjaCAobXV0ZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5BVURJTztcbiAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5WSURFTztcbiAgICAgICAgY2FzZSAnc2NyZWVuc2hhcmUnOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkU7XG4gICAgICAgIGNhc2UgJ3NjcmVlbnNoYXJlX2F1ZGlvJzpcbiAgICAgICAgICAgIHJldHVybiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZU11dGVUeXBlQ2hlY2sgPSBtdXRlVHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBtdXRlIHR5cGU6ICR7ZXhoYXVzdGl2ZU11dGVUeXBlQ2hlY2t9YCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHVwZGF0ZSBpcyBhIGZ1bmN0aW9uIHBhdGNoLlxuICpcbiAqIEBwYXJhbSB1cGRhdGUgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5jb25zdCBpc0Z1bmN0aW9uUGF0Y2ggPSAodXBkYXRlKSA9PiB0eXBlb2YgdXBkYXRlID09PSAnZnVuY3Rpb24nO1xuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIG9ic2VydmFibGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXNcbiAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlJCB0aGUgb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gKi9cbmNvbnN0IGdldEN1cnJlbnRWYWx1ZSA9IChvYnNlcnZhYmxlJCkgPT4ge1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgZXJyID0gdW5kZWZpbmVkO1xuICAgIGNvbWJpbmVMYXRlc3QoW29ic2VydmFibGUkXSlcbiAgICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IChbdl0pID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlKSA9PiB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICB9LFxuICAgIH0pXG4gICAgICAgIC51bnN1YnNjcmliZSgpO1xuICAgIGlmIChlcnIpXG4gICAgICAgIHRocm93IGVycjtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICogdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAqL1xuY29uc3Qgc2V0Q3VycmVudFZhbHVlID0gKHN1YmplY3QsIHVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBpc0Z1bmN0aW9uUGF0Y2godXBkYXRlKVxuICAgICAgICA/IHVwZGF0ZShnZXRDdXJyZW50VmFsdWUoc3ViamVjdCkpXG4gICAgICAgIDogdXBkYXRlO1xuICAgIHN1YmplY3QubmV4dChuZXh0KTtcbiAgICByZXR1cm4gbmV4dDtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBzdWJzY3JpcHRpb24gYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnN1YnNjcmliZS5cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZSB0aGUgb2JzZXJ2YWJsZSB0byBzdWJzY3JpYmUgdG8uXG4gKiBAcGFyYW0gaGFuZGxlciB0aGUgaGFuZGxlciB0byBjYWxsIHdoZW4gdGhlIG9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZS5cbiAqL1xuY29uc3QgY3JlYXRlU3Vic2NyaXB0aW9uID0gKG9ic2VydmFibGUsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnN1YnNjcmliZShoYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xufTtcblxudmFyIHJ4VXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNyZWF0ZVN1YnNjcmlwdGlvbjogY3JlYXRlU3Vic2NyaXB0aW9uLFxuICAgIGdldEN1cnJlbnRWYWx1ZTogZ2V0Q3VycmVudFZhbHVlLFxuICAgIHNldEN1cnJlbnRWYWx1ZTogc2V0Q3VycmVudFZhbHVlXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbWJpbmVkIHtAbGluayBDb21wYXJhdG9yPFQ+fSB3aGljaCBzb3J0cyBpdGVtcyBieSB0aGUgZ2l2ZW4gY29tcGFyYXRvcnMuXG4gKiBUaGUgY29tcGFyYXRvcnMgYXJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGdpdmVuIChsZWZ0IC0+IHJpZ2h0KS5cbiAqXG4gKiBAcGFyYW0gY29tcGFyYXRvcnMgdGhlIGNvbXBhcmF0b3JzIHRvIHVzZSBmb3Igc29ydGluZy5cbiAqIEByZXR1cm5zIGEgY29tYmluZWQge0BsaW5rIENvbXBhcmF0b3I8VD59LlxuICovXG5jb25zdCBjb21iaW5lQ29tcGFyYXRvcnMgPSAoLi4uY29tcGFyYXRvcnMpID0+IHtcbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjb21wYXJhdG9yIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJhdG9yKGEsIGIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgaXRlbXMgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYnlWYWx1ZSA9IChhLCBiKSA9PiBhIDwgYiA/IC0gMSA6IGEgPiBiID8gMSA6IDA7XG4gKiBjb25zdCBieVZhbHVlRGVzYyA9IGRlc2NlbmRpbmcoYnlWYWx1ZSk7XG4gKlxuICogQHBhcmFtIGNvbXBhcmF0b3IgdGhlIGNvbXBhcmF0b3IgdG8gd3JhcC5cbiAqL1xuY29uc3QgZGVzY2VuZGluZyA9IChjb21wYXJhdG9yKSA9PiB7XG4gICAgcmV0dXJuIChhLCBiKSA9PiBjb21wYXJhdG9yKGIsIGEpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb21wYXJhdG9yIHdoaWNoIGNvbmRpdGlvbmFsbHkgYXBwbGllcyB0aGUgZ2l2ZW4gY29tcGFyYXRvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2hvdWxkU29ydEJ5VmFsdWUgPSAoYSwgYikgPT4gYSAlIDIgPT09IDA7IC8vIHJldHVybiBmYWxzZSB0byB0dXJuIGl0IG9mZlxuICogY29uc3QgYnlWYWx1ZSA9IChhLCBiKSA9PiBhIDwgYiA/IC0gMSA6IGEgPiBiID8gMSA6IDA7XG4gKiBjb25zdCBjb21wYXJhdG9yID0gY29uZGl0aW9uYWwoc2hvdWxkU29ydEJ5VmFsdWUpKGJ5VmFsdWUpO1xuICpcbiAqIEBwYXJhbSBwcmVkaWNhdGUgdGhlIHByZWRpY2F0ZSB0byB1c2UgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdG8gYXBwbHkgdGhlIGNvbXBhcmF0b3IuXG4gKi9cbmNvbnN0IGNvbmRpdGlvbmFsID0gKHByZWRpY2F0ZSkgPT4ge1xuICAgIHJldHVybiAoY29tcGFyYXRvcikgPT4ge1xuICAgICAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGEsIGIpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYik7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG4vKipcbiAqIEEgbm8tb3AgY29tcGFyYXRvciB3aGljaCBhbHdheXMgcmV0dXJucyAwLlxuICovXG5jb25zdCBub29wQ29tcGFyYXRvciA9ICgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gMDtcbn07XG5cbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIHRoZSBkb21pbmFudCBzcGVha2VyIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBkb21pbmFudFNwZWFrZXIgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLmlzRG9taW5hbnRTcGVha2VyICYmICFiLmlzRG9taW5hbnRTcGVha2VyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFhLmlzRG9taW5hbnRTcGVha2VyICYmIGIuaXNEb21pbmFudFNwZWFrZXIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSB0aGUgZmFjdCB0aGF0IHRoZXkgYXJlIHNwZWFraW5nIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBzcGVha2luZyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuaXNTcGVha2luZyAmJiAhYi5pc1NwZWFraW5nKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFhLmlzU3BlYWtpbmcgJiYgYi5pc1NwZWFraW5nKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBzb3J0cyBwYXJ0aWNpcGFudHMgYnkgc2NyZWVuIHNoYXJpbmcgc3RhdHVzLlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IHNjcmVlblNoYXJpbmcgPSAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNTY3JlZW5TaGFyZShhKSAmJiAhaGFzU2NyZWVuU2hhcmUoYikpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc1NjcmVlblNoYXJlKGEpICYmIGhhc1NjcmVlblNoYXJlKGIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBzb3J0cyBwYXJ0aWNpcGFudHMgYnkgdmlkZW8gc3RhdHVzLlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IHB1Ymxpc2hpbmdWaWRlbyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGhhc1ZpZGVvKGEpICYmICFoYXNWaWRlbyhiKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmICghaGFzVmlkZW8oYSkgJiYgaGFzVmlkZW8oYikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSBhdWRpbyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgcHVibGlzaGluZ0F1ZGlvID0gKGEsIGIpID0+IHtcbiAgICBpZiAoaGFzQXVkaW8oYSkgJiYgIWhhc0F1ZGlvKGIpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFoYXNBdWRpbyhhKSAmJiBoYXNBdWRpbyhiKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggcHJpb3JpdGl6ZXMgcGFydGljaXBhbnRzIHdobyBhcmUgcGlubmVkLlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IHBpbm5lZCA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEucGluICYmIGIucGluKSB7XG4gICAgICAgIGlmICghYS5waW4uaXNMb2NhbFBpbiAmJiBiLnBpbi5pc0xvY2FsUGluKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5waW4uaXNMb2NhbFBpbiAmJiAhYi5waW4uaXNMb2NhbFBpbilcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS5waW4ucGlubmVkQXQgPiBiLnBpbi5waW5uZWRBdClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEucGluLnBpbm5lZEF0IDwgYi5waW4ucGlubmVkQXQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGEucGluICYmICFiLnBpbilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmICghYS5waW4gJiYgYi5waW4pXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIGNyZWF0b3Igd2hpY2ggd2lsbCBzZXQgdXAgYSBjb21wYXJhdG9yIHdoaWNoIHByaW9yaXRpemVzXG4gKiBwYXJ0aWNpcGFudHMgd2hvIGhhdmUgYSBzcGVjaWZpYyByZWFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gdHlwZSB0aGUgcmVhY3Rpb24gdHlwZS5cbiAqL1xuY29uc3QgcmVhY3Rpb25UeXBlID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEucmVhY3Rpb24/LnR5cGUgPT09IHR5cGUgJiYgYi5yZWFjdGlvbj8udHlwZSAhPT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEucmVhY3Rpb24/LnR5cGUgIT09IHR5cGUgJiYgYi5yZWFjdGlvbj8udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIGNyZWF0b3Igd2hpY2ggd2lsbCBzZXQgdXAgYSBjb21wYXJhdG9yIHdoaWNoIHByaW9yaXRpemVzXG4gKiBwYXJ0aWNpcGFudHMgd2hvIGhhdmUgYSBzcGVjaWZpYyByb2xlLlxuICpcbiAqIEBwYXJhbSByb2xlcyB0aGUgcm9sZXMgdG8gcHJpb3JpdGl6ZS5cbiAqL1xuY29uc3Qgcm9sZSA9ICguLi5yb2xlcykgPT4gKGEsIGIpID0+IHtcbiAgICBpZiAoaGFzQW55Um9sZShhLCByb2xlcykgJiYgIWhhc0FueVJvbGUoYiwgcm9sZXMpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFoYXNBbnlSb2xlKGEsIHJvbGVzKSAmJiBoYXNBbnlSb2xlKGIsIHJvbGVzKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgbmFtZSA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEubmFtZSA8IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChhLm5hbWUgPiBiLm5hbWUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGhhc0FueVJvbGUgPSAocCwgcm9sZXMpID0+IChwLnJvbGVzIHx8IFtdKS5zb21lKChyKSA9PiByb2xlcy5pbmNsdWRlcyhyKSk7XG5jb25zdCBoYXNTY3JlZW5TaGFyZSA9IChwKSA9PiBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcbmNvbnN0IGhhc1ZpZGVvID0gKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5WSURFTyk7XG5jb25zdCBoYXNBdWRpbyA9IChwKSA9PiBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuQVVESU8pO1xuXG4vLyBhIGNvbXBhcmF0b3IgZGVjb3JhdG9yIHdoaWNoIGFwcGxpZXMgdGhlIGRlY29yYXRlZCBjb21wYXJhdG9yIG9ubHkgaWYgdGhlXG4vLyBwYXJ0aWNpcGFudCBpcyBpbnZpc2libGUuXG4vLyBUaGlzIGVuc3VyZXMgc3RhYmxlIHNvcnRpbmcgd2hlbiBhbGwgcGFydGljaXBhbnRzIGFyZSB2aXNpYmxlLlxuY29uc3QgaWZJbnZpc2libGVCeSA9IGNvbmRpdGlvbmFsKChhLCBiKSA9PiBhLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFIHx8XG4gICAgYi52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8udmlkZW9UcmFjayA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRSk7XG4vKipcbiAqIEEgY29tcGFyYXRvciB0aGF0IGFwcGxpZXMgdGhlIGRlY29yYXRlZCBjb21wYXJhdG9yIHdoZW4gYSBwYXJ0aWNpcGFudCBpc1xuICogZWl0aGVyIGludmlzaWJsZSBvciBpdHMgdmlzaWJpbGl0eSBzdGF0ZSBpc24ndCBrbm93bi5cbiAqIEZvciB2aXNpYmxlIHBhcnRpY2lwYW50cywgaXQgZW5zdXJlcyBzdGFibGUgc29ydGluZy5cbiAqL1xuY29uc3QgaWZJbnZpc2libGVPclVua25vd25CeSA9IGNvbmRpdGlvbmFsKChhLCBiKSA9PiBhLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFIHx8XG4gICAgYS52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8udmlkZW9UcmFjayA9PT0gVmlzaWJpbGl0eVN0YXRlLlVOS05PV04gfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFIHx8XG4gICAgYi52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8udmlkZW9UcmFjayA9PT0gVmlzaWJpbGl0eVN0YXRlLlVOS05PV04pO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBzb3J0aW5nIHByZXNldC5cbiAqL1xuY29uc3QgZGVmYXVsdFNvcnRQcmVzZXQgPSBjb21iaW5lQ29tcGFyYXRvcnMocGlubmVkLCBzY3JlZW5TaGFyaW5nLCBpZkludmlzaWJsZUJ5KGNvbWJpbmVDb21wYXJhdG9ycyhkb21pbmFudFNwZWFrZXIsIHNwZWFraW5nLCByZWFjdGlvblR5cGUoJ3JhaXNlZC1oYW5kJyksIHB1Ymxpc2hpbmdWaWRlbywgcHVibGlzaGluZ0F1ZGlvKSkpO1xuLyoqXG4gKiBUaGUgc29ydGluZyBwcmVzZXQgZm9yIHNwZWFrZXIgbGF5b3V0LlxuICovXG5jb25zdCBzcGVha2VyTGF5b3V0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhwaW5uZWQsIHNjcmVlblNoYXJpbmcsIGRvbWluYW50U3BlYWtlciwgaWZJbnZpc2libGVCeShjb21iaW5lQ29tcGFyYXRvcnMoc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSk7XG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3IgbGF5b3V0cyB0aGF0IGRvbid0IHJlbmRlciBhbGwgcGFydGljaXBhbnRzIGJ1dFxuICogaW5zdGVhZCwgcmVuZGVyIHRoZW0gaW4gcGFnZXMuXG4gKi9cbmNvbnN0IHBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQgPSBjb21iaW5lQ29tcGFyYXRvcnMocGlubmVkLCBpZkludmlzaWJsZU9yVW5rbm93bkJ5KGNvbWJpbmVDb21wYXJhdG9ycyhkb21pbmFudFNwZWFrZXIsIHNwZWFraW5nLCByZWFjdGlvblR5cGUoJ3JhaXNlZC1oYW5kJyksIHB1Ymxpc2hpbmdWaWRlbywgcHVibGlzaGluZ0F1ZGlvKSkpO1xuLyoqXG4gKiBUaGUgc29ydGluZyBwcmVzZXQgZm9yIGxpdmVzdHJlYW1zIGFuZCBhdWRpbyByb29tcy5cbiAqL1xuY29uc3QgbGl2ZXN0cmVhbU9yQXVkaW9Sb29tU29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhpZkludmlzaWJsZUJ5KGNvbWJpbmVDb21wYXJhdG9ycyhkb21pbmFudFNwZWFrZXIsIHNwZWFraW5nLCByZWFjdGlvblR5cGUoJ3JhaXNlZC1oYW5kJyksIHB1Ymxpc2hpbmdWaWRlbywgcHVibGlzaGluZ0F1ZGlvKSksIHJvbGUoJ2FkbWluJywgJ2hvc3QnLCAnc3BlYWtlcicpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICovXG52YXIgQ2FsbGluZ1N0YXRlO1xuKGZ1bmN0aW9uIChDYWxsaW5nU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiBhbiB1bmtub3duIHN0YXRlLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiBhbiBpZGxlIHN0YXRlLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIklETEVcIl0gPSBcImlkbGVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiByaW5naW5nLlxuICAgICAqIChVc2VyIGhhc24ndCBhY2NlcHRlZCBub3IgcmVqZWN0ZWQgdGhlIGNhbGwgeWV0LilcbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJSSU5HSU5HXCJdID0gXCJyaW5naW5nXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygam9pbmluZy5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJKT0lOSU5HXCJdID0gXCJqb2luaW5nXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJKT0lORURcIl0gPSBcImpvaW5lZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGhhcyBiZWVuIGxlZnQuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIHRoZSBwcm9jZXNzIG9mIHJlY29ubmVjdGluZy5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJSRUNPTk5FQ1RJTkdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIHRoZSBwcm9jZXNzIG9mIG1pZ3JhdGluZyBmcm9tIG9uZSBub2RlIHRvIGFub3RoZXIuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiTUlHUkFUSU5HXCJdID0gXCJtaWdyYXRpbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBoYXMgZmFpbGVkIHRvIHJlY29ubmVjdC5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJSRUNPTk5FQ1RJTkdfRkFJTEVEXCJdID0gXCJyZWNvbm5lY3RpbmctZmFpbGVkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gb2ZmbGluZSBtb2RlLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIk9GRkxJTkVcIl0gPSBcIm9mZmxpbmVcIjtcbn0pKENhbGxpbmdTdGF0ZSB8fCAoQ2FsbGluZ1N0YXRlID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBlZ3Jlc3Mgb2JqZWN0IC0gd2hlbiBubyBlZ3Jlc3MgZGF0YSBpcyBhdmFpbGFibGUuXG4gKi9cbmNvbnN0IGRlZmF1bHRFZ3Jlc3MgPSB7XG4gICAgYnJvYWRjYXN0aW5nOiBmYWxzZSxcbiAgICBobHM6IHsgcGxheWxpc3RfdXJsOiAnJyB9LFxuICAgIHJ0bXBzOiBbXSxcbn07XG4vKipcbiAqIEhvbGRzIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICogQHJlYWN0IFlvdSBkb24ndCBoYXZlIHRvIHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCBhcyB3ZSBhcmUgZXhwb3NpbmcgdGhlIHN0YXRlIHRocm91Z2ggSG9va3MuXG4gKi9cbmNsYXNzIENhbGxTdGF0ZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ2FsbFN0YXRlIGNsYXNzLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmFja3N0YWdlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodHJ1ZSk7XG4gICAgICAgIHRoaXMuYmxvY2tlZFVzZXJJZHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QobmV3IERhdGUoKSk7XG4gICAgICAgIHRoaXMuZW5kZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc3RhcnRzQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnVwZGF0ZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG5ldyBEYXRlKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZWRCeVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY3VzdG9tU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Qoe30pO1xuICAgICAgICB0aGlzLmVncmVzc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuaW5ncmVzc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICB0aGlzLnNlc3Npb25TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnNldHRpbmdzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy50cmFuc2NyaWJpbmdTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIHRoaXMuZW5kZWRCeVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMudGh1bWJuYWlsc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubWVtYmVyc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5vd25DYXBhYmlsaXRpZXNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgICAgIHRoaXMuY2FsbGluZ1N0YXRlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoQ2FsbGluZ1N0YXRlLlVOS05PV04pO1xuICAgICAgICB0aGlzLnN0YXJ0ZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRDb3VudFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDApO1xuICAgICAgICB0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgwKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgICAgIHRoaXMuY2FsbFN0YXRzUmVwb3J0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb21wYXJhdG9ycyB0aGF0IGFyZSB1c2VkIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydFBhcnRpY2lwYW50c0J5ID0gZGVmYXVsdFNvcnRQcmVzZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIGNyaXRlcmlhIHRoYXQgYXJlIHVzZWQgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKiBUbyBkaXNhYmxlIHNvcnRpbmcsIHlvdSBjYW4gcGFzcyBgbm9vcENvbXBhcmF0b3IoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIHRoZSBjb21wYXJhdG9yIHRvIHVzZSB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNvcnRQYXJ0aWNpcGFudHNCeSA9IChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvcnRQYXJ0aWNpcGFudHNCeSA9IGNvbXBhcmF0b3I7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHJlLXNvcnRpbmcgb2YgcGFydGljaXBhbnRzXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnBhcnRpY2lwYW50c1N1YmplY3QsIChwcykgPT4gcHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAgICAgICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICAgICAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSA9IHNldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDb3VudCA9IChjb3VudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRDb3VudFN1YmplY3QsIGNvdW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRpbWUgdGhlIGNhbGwgc2Vzc2lvbiBhY3R1YWxseSBzdGFydGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0ZWRBdCB0aGUgdGltZSB0aGUgY2FsbCBzZXNzaW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWRBdCA9IChzdGFydGVkQXQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0ZWRBdFN1YmplY3QsIHN0YXJ0ZWRBdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYW5vbnltb3VzIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0QW5vbnltb3VzUGFydGljaXBhbnRDb3VudCA9IChjb3VudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudFN1YmplY3QsIGNvdW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFydGljaXBhbnRzIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRzID0gKHBhcnRpY2lwYW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzU3ViamVjdCwgcGFydGljaXBhbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGNhbGxpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gc3RhdGUgdGhlIG5ldyBjYWxsaW5nIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDYWxsaW5nU3RhdGUgPSAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxpbmdTdGF0ZVN1YmplY3QsIHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGNhbGwgc3RhdHMgcmVwb3J0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q2FsbFN0YXRzUmVwb3J0ID0gKHJlcG9ydCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbFN0YXRzUmVwb3J0U3ViamVjdCwgcmVwb3J0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG1lbWJlcnMgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBtZW1iZXJzIHRoZSBtZW1iZXJzIHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0TWVtYmVycyA9IChtZW1iZXJzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lbWJlcnNTdWJqZWN0LCBtZW1iZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG93biBjYXBhYmlsaXRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gY2FwYWJpbGl0aWVzIHRoZSBjYXBhYmlsaXRpZXMgdG8gc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRPd25DYXBhYmlsaXRpZXMgPSAoY2FwYWJpbGl0aWVzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5vd25DYXBhYmlsaXRpZXNTdWJqZWN0LCBjYXBhYmlsaXRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCB0cnkgdG8gZmluZCB0aGUgcGFydGljaXBhbnQgd2l0aCB0aGUgZ2l2ZW4gc2Vzc2lvbklkIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCBvZiB0aGUgcGFydGljaXBhbnQgdG8gZmluZC5cbiAgICAgICAgICogQHJldHVybnMgdGhlIHBhcnRpY2lwYW50IHdpdGggdGhlIGdpdmVuIHNlc3Npb25JZCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZCA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5maW5kKChwKSA9PiBwLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgbG9va3VwIHRhYmxlIG9mIHBhcnRpY2lwYW50cyBpbmRleGVkIGJ5IHRoZWlyIHNlc3Npb24gSUQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFBhcnRpY2lwYW50TG9va3VwQnlTZXNzaW9uSWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMucmVkdWNlKChsb29rdXBUYWJsZSwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZVtwYXJ0aWNpcGFudC5zZXNzaW9uSWRdID0gcGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhIHBhcnRpY2lwYW50IGluIHRoZSBjdXJyZW50IGNhbGwgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gYHNlc3Npb25JZGAuXG4gICAgICAgICAqIElmIHRoZSBwYXJ0aWNpcGFudCBjYW4ndCBiZSBmb3VuZCwgdGhpcyBvcGVyYXRpb24gaXMgbm8tb3AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIElEIG9mIHRoZSBwYXJ0aWNpcGFudCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSBwYXRjaCB0aGUgcGF0Y2ggdG8gYXBwbHkgdG8gdGhlIHBhcnRpY2lwYW50LlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBwYXJ0aWNpcGFudCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcGFydGljaXBhbnQgY291bGRuJ3QgYmUgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpY2lwYW50ID0gKHNlc3Npb25JZCwgcGF0Y2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYFBhcnRpY2lwYW50IHdpdGggc2Vzc2lvbklkICR7c2Vzc2lvbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aGVQYXRjaCA9IHR5cGVvZiBwYXRjaCA9PT0gJ2Z1bmN0aW9uJyA/IHBhdGNoKHBhcnRpY2lwYW50KSA6IHBhdGNoO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBhcnRpY2lwYW50ID0ge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIE9MOiB0aGlzIGlzIG5vdCBhIGRlZXAgbWVyZ2UsIHdlIG1pZ2h0IHdhbnQgdG8gcmV2aXNpdCB0aGlzXG4gICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgLi4udGhlUGF0Y2gsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQgPyB1cGRhdGVkUGFydGljaXBhbnQgOiBwKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGEgcGFydGljaXBhbnQgaW4gdGhlIGN1cnJlbnQgY2FsbCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBgc2Vzc2lvbklkYC5cbiAgICAgICAgICogSWYgYSBwYXJ0aWNpcGFudCB3aXRoIG1hdGNoaW5nIGBzZXNzaW9uSWRgIGNhbid0IGJlIGZvdW5kLCB0aGUgcHJvdmlkZWRcbiAgICAgICAgICogYHBhcnRpY2lwYW50YCBpcyBhZGRlZCB0byB0aGUgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gSUQgb2YgdGhlIHBhcnRpY2lwYW50IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHBhcnRpY2lwYW50IHRoZSBwYXJ0aWNpcGFudCB0byB1cGRhdGUgb3IgYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVPckFkZFBhcnRpY2lwYW50ID0gKHNlc3Npb25JZCwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbCB3aG9zZSBzZXNzaW9uIElEIGlzIGluIHRoZSBnaXZlbiBgc2Vzc2lvbklkc2AuXG4gICAgICAgICAqIElmIG5vIHBhdGNoZXMgYXJlIHByb3ZpZGVkLCB0aGlzIG9wZXJhdGlvbiBpcyBuby1vcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXRjaCB0aGUgcGF0Y2ggdG8gYXBwbHkgdG8gdGhlIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICogQHJldHVybnMgYWxsIHBhcnRpY2lwYW50cywgd2l0aCBhbGwgcGF0Y2ggYXBwbGllZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljaXBhbnRzID0gKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF0Y2gpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoZVBhdGNoID0gcGF0Y2hbcC5zZXNzaW9uSWRdO1xuICAgICAgICAgICAgICAgIGlmICh0aGVQYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoZVBhdGNoLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNhbGwgc3RhdGUgd2l0aCB0aGUgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIHZpZGVvIGV2ZW50IHRoYXQgb3VyIGJhY2tlbmQgc2VudCB1cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGUgPSB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHBhcnRpY2lwYW50IHBpbm5lZCBzdGF0ZSB3aXRoIHNlcnZlciBzaWRlIHBpbm5pbmcgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBpbnMgdGhlIGxhdGVzdCBwaW5zIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2VydmVyU2lkZVBpbnMgPSAocGlucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGluc0xvb2t1cCA9IHBpbnMucmVkdWNlKChsb29rdXAsIHBpbikgPT4ge1xuICAgICAgICAgICAgICAgIGxvb2t1cFtwaW4uc2Vzc2lvbklkXSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMubWFwKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclNpZGVQaW5uZWRBdCA9IHBpbnNMb29rdXBbcGFydGljaXBhbnQuc2Vzc2lvbklkXTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQgaXMgbmV3bHkgcGlubmVkXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlclNpZGVQaW5uZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsUGluOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5uZWRBdDogc2VydmVyU2lkZVBpbm5lZEF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50IGlzIG5vIGxvbmdlciBwaW5uZWQgc2VydmVyIHNpZGVcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBwaW5cbiAgICAgICAgICAgICAgICBpZiAocGFydGljaXBhbnQucGluICYmICFwYXJ0aWNpcGFudC5waW4uaXNMb2NhbFBpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlcyB0byBiZSBhcHBsaWVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY2FsbCBzdGF0ZSB3aXRoIHRoZSBkYXRhIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZSA9IChjYWxsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJhY2tzdGFnZVN1YmplY3QsIGNhbGwuYmFja3N0YWdlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuYmxvY2tlZFVzZXJJZHNTdWJqZWN0LCBjYWxsLmJsb2NrZWRfdXNlcl9pZHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jcmVhdGVkQXRTdWJqZWN0LCBuZXcgRGF0ZShjYWxsLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMudXBkYXRlZEF0U3ViamVjdCwgbmV3IERhdGUoY2FsbC51cGRhdGVkX2F0KSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0c0F0U3ViamVjdCwgY2FsbC5zdGFydHNfYXQgPyBuZXcgRGF0ZShjYWxsLnN0YXJ0c19hdCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lbmRlZEF0U3ViamVjdCwgY2FsbC5lbmRlZF9hdCA/IG5ldyBEYXRlKGNhbGwuZW5kZWRfYXQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEJ5U3ViamVjdCwgY2FsbC5jcmVhdGVkX2J5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY3VzdG9tU3ViamVjdCwgY2FsbC5jdXN0b20pO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCBjYWxsLmVncmVzcyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmluZ3Jlc3NTdWJqZWN0LCBjYWxsLmluZ3Jlc3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCBjYWxsLnJlY29yZGluZyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlc3Npb25TdWJqZWN0LCBjYWxsLnNlc3Npb24pO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5nc1N1YmplY3QsIGNhbGwuc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy50cmFuc2NyaWJpbmdTdWJqZWN0LCBjYWxsLnRyYW5zY3JpYmluZyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnRodW1ibmFpbHNTdWJqZWN0LCBjYWxsLnRodW1ibmFpbHMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21NZW1iZXJSZW1vdmVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lbWJlcnNTdWJqZWN0LCAobWVtYmVycykgPT4gbWVtYmVycy5maWx0ZXIoKG0pID0+IGV2ZW50Lm1lbWJlcnMuaW5kZXhPZihtLnVzZXJfaWQpID09PSAtMSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21NZW1iZXJBZGRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgKG1lbWJlcnMpID0+IFtcbiAgICAgICAgICAgICAgICAuLi5tZW1iZXJzLFxuICAgICAgICAgICAgICAgIC4uLmV2ZW50Lm1lbWJlcnMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RvcHBlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcyA9IGRlZmF1bHRFZ3Jlc3MpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWdyZXNzLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcyA9IGRlZmF1bHRFZ3Jlc3MpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWdyZXNzLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0YXJ0ZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcyA9IGRlZmF1bHRFZ3Jlc3MpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWdyZXNzLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBobHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZWdyZXNzLmhscyxcbiAgICAgICAgICAgICAgICAgICAgcGxheWxpc3RfdXJsOiBldmVudC5obHNfcGxheWxpc3RfdXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudExlZnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2Vzc2lvblN1YmplY3QsIChzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYFJlY2VpdmVkIGNhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9sZWZ0IGV2ZW50IGJ1dCBubyBzZXNzaW9uIGlzIGF2YWlsYWJsZS5gLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRpY2lwYW50cywgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUgfSA9IHNlc3Npb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VyLCB1c2VyX3Nlc3Npb25faWQgfSA9IGV2ZW50LnBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50czogcGFydGljaXBhbnRzLmZpbHRlcigocCkgPT4gcC51c2VyX3Nlc3Npb25faWQgIT09IHVzZXJfc2Vzc2lvbl9pZCksXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VyLnJvbGVdOiBNYXRoLm1heCgwLCAocGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGVbdXNlci5yb2xlXSB8fCAwKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlc3Npb25TdWJqZWN0LCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBSZWNlaXZlZCBjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfam9pbmVkIGV2ZW50IGJ1dCBubyBzZXNzaW9uIGlzIGF2YWlsYWJsZS5gLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhcnRpY2lwYW50cywgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUgfSA9IHNlc3Npb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VyLCB1c2VyX3Nlc3Npb25faWQgfSA9IGV2ZW50LnBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIC8vIEl0IGNvdWxkIGhhcHBlbiB0aGF0IHRoZSBiYWNrZW5kIGRlbGl2ZXJzIHRoZSBzYW1lIHBhcnRpY2lwYW50IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2l0aCB0aGUgY2FsbC5zZXNzaW9uX3N0YXJ0ZWQgZXZlbnQgYW5kIG9uY2UgYWdhaW4gd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfam9pbmVkIGV2ZW50LiBJbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgZXhpc3RpbmcgcGFydGljaXBhbnQgYW5kIHByZXZlbnQgZHVwbGljYXRpbmcgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHNob3VsZEluc2VydFBhcnRpY2lwYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnRzID0gcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC51c2VyX3Nlc3Npb25faWQgPT09IHVzZXJfc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkSW5zZXJ0UGFydGljaXBhbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSW5zZXJ0UGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldyBhcnJheSwgd2UgY2FuIHNhZmVseSBwdXNoIHRoZSBuZXcgcGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFBhcnRpY2lwYW50cy5wdXNoKGV2ZW50LnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHVwZGF0aW5nIGFuIGV4aXN0aW5nIHBhcnRpY2lwYW50LCB3ZSBkb24ndCB3YW50IHRvIGluY3JlbWVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudF9ieV9yb2xlIGNvdW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IGluY3JlbWVudCA9IHNob3VsZEluc2VydFBhcnRpY2lwYW50ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRzOiB1cGRhdGVkUGFydGljaXBhbnRzLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdXNlci5yb2xlXTogKHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlW3VzZXIucm9sZV0gfHwgMCkgKyBpbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZU1lbWJlcnMgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIChtZW1iZXJzKSA9PiBtZW1iZXJzLm1hcCgobWVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyVXBkYXRlID0gZXZlbnQubWVtYmVycy5maW5kKChtKSA9PiBtLnVzZXJfaWQgPT09IG1lbWJlci51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyVXBkYXRlID8gbWVtYmVyVXBkYXRlIDogbWVtYmVyO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpY2lwYW50UmVhY3Rpb24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgY3VzdG9tLCB0eXBlLCBlbW9qaV9jb2RlIH0gPSBldmVudC5yZWFjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSByZWFjdGlvbiBpcyBub3QgZm9yIHRoaXMgcGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudXNlcklkICE9PSB1c2VyLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFydGljaXBhbnQgd2l0aCB0aGUgbmV3IHJlYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtb2ppX2NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuYmxvY2tVc2VyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdCwgKGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmZpbHRlcigoaWQpID0+IGlkICE9PSBldmVudC51c2VyLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJsb2NrVXNlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QsIChjdXJyZW50KSA9PiBbXG4gICAgICAgICAgICAgICAgLi4uKGN1cnJlbnQgfHwgW10pLFxuICAgICAgICAgICAgICAgIGV2ZW50LnVzZXIuaWQsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVPd25DYXBhYmlsaXRpZXMgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC51c2VyLmlkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQ/LnVzZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMub3duQ2FwYWJpbGl0aWVzU3ViamVjdCwgZXZlbnQub3duX2NhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnQ2FsbFN0YXRlJ10pO1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50cyQgPSB0aGlzLnBhcnRpY2lwYW50c1N1YmplY3QuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICAgICAgLy8gbWFpbnRhaW4gc3RhYmxlLXNvcnQgYnkgbXV0YXRpbmcgdGhlIHBhcnRpY2lwYW50cyBzdG9yZWRcbiAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIHN1YmplY3RcbiAgICAgICAgbWFwJDEoKHBzKSA9PiBwcy5zb3J0KHRoaXMuc29ydFBhcnRpY2lwYW50c0J5KSksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAuaXNMb2NhbFBhcnRpY2lwYW50KSksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cyQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiAhcC5pc0xvY2FsUGFydGljaXBhbnQpKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMucGlubmVkUGFydGljaXBhbnRzJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maWx0ZXIoKHApID0+ICEhcC5waW4pKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuZG9taW5hbnRTcGVha2VyJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maW5kKChwKSA9PiBwLmlzRG9taW5hbnRTcGVha2VyKSksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLmhhc09uZ29pbmdTY3JlZW5TaGFyZSQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuc29tZSgocCkgPT4gcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSkpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuc3RhcnRlZEF0JCA9IHRoaXMuc3RhcnRlZEF0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudENvdW50JCA9IHRoaXMucGFydGljaXBhbnRDb3VudFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQgPVxuICAgICAgICAgICAgdGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhdHNSZXBvcnQkID0gdGhpcy5jYWxsU3RhdHNSZXBvcnRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLm1lbWJlcnMkID0gdGhpcy5tZW1iZXJzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5vd25DYXBhYmlsaXRpZXMkID0gdGhpcy5vd25DYXBhYmlsaXRpZXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNhbGxpbmdTdGF0ZSQgPSB0aGlzLmNhbGxpbmdTdGF0ZVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuYmFja3N0YWdlJCA9IHRoaXMuYmFja3N0YWdlU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5ibG9ja2VkVXNlcklkcyQgPSB0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQkID0gdGhpcy5jcmVhdGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmVuZGVkQXQkID0gdGhpcy5lbmRlZEF0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5zdGFydHNBdCQgPSB0aGlzLnN0YXJ0c0F0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVkQXQkID0gdGhpcy51cGRhdGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZWRCeSQgPSB0aGlzLmNyZWF0ZWRCeVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuY3VzdG9tJCA9IHRoaXMuY3VzdG9tU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5lZ3Jlc3MkID0gdGhpcy5lZ3Jlc3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmluZ3Jlc3MkID0gdGhpcy5pbmdyZXNzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmckID0gdGhpcy5yZWNvcmRpbmdTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24kID0gdGhpcy5zZXNzaW9uU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyQgPSB0aGlzLnNldHRpbmdzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy50cmFuc2NyaWJpbmckID0gdGhpcy50cmFuc2NyaWJpbmdTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmVuZGVkQnkkID0gdGhpcy5lbmRlZEJ5U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy50aHVtYm5haWxzJCA9IHRoaXMudGh1bWJuYWlsc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHtcbiAgICAgICAgICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgbm90IHVwZGF0aW5nIHRoZSBjYWxsIHN0YXRlOlxuICAgICAgICAgICAgJ2NhbGwuY2xvc2VkX2NhcHRpb24nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC5wZXJtaXNzaW9uX3JlcXVlc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC5yZWNvcmRpbmdfZmFpbGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwucmVjb3JkaW5nX3JlYWR5JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9zdGFydGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9zdG9wcGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9yZWFkeSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjYWxsLnRyYW5zY3JpcHRpb25fZmFpbGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwudXNlcl9tdXRlZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjb25uZWN0aW9uLmVycm9yJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nvbm5lY3Rpb24ub2snOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaGVhbHRoLmNoZWNrJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3VzdG9tOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBldmVudHMgdGhhdCB1cGRhdGUgY2FsbCBzdGF0ZTpcbiAgICAgICAgICAgICdjYWxsLmFjY2VwdGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwuYmxvY2tlZF91c2VyJzogdGhpcy5ibG9ja1VzZXIsXG4gICAgICAgICAgICAnY2FsbC5jcmVhdGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwuZW5kZWQnOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRCeVN1YmplY3QsIGUudXNlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2NhbGwuaGxzX2Jyb2FkY2FzdGluZ19mYWlsZWQnOiB0aGlzLnVwZGF0ZUZyb21ITFNCcm9hZGNhc3RpbmdGYWlsZWQsXG4gICAgICAgICAgICAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX3N0YXJ0ZWQnOiB0aGlzLnVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdGFydGVkLFxuICAgICAgICAgICAgJ2NhbGwuaGxzX2Jyb2FkY2FzdGluZ19zdG9wcGVkJzogdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RvcHBlZCxcbiAgICAgICAgICAgICdjYWxsLmxpdmVfc3RhcnRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgICAgICdjYWxsLm1lbWJlcl9hZGRlZCc6IHRoaXMudXBkYXRlRnJvbU1lbWJlckFkZGVkLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX3JlbW92ZWQnOiB0aGlzLnVwZGF0ZUZyb21NZW1iZXJSZW1vdmVkLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX3VwZGF0ZWRfcGVybWlzc2lvbic6IHRoaXMudXBkYXRlTWVtYmVycyxcbiAgICAgICAgICAgICdjYWxsLm1lbWJlcl91cGRhdGVkJzogdGhpcy51cGRhdGVNZW1iZXJzLFxuICAgICAgICAgICAgJ2NhbGwubm90aWZpY2F0aW9uJzogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1lbWJlcnMoZS5tZW1iZXJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY2FsbC5wZXJtaXNzaW9uc191cGRhdGVkJzogdGhpcy51cGRhdGVPd25DYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAnY2FsbC5yZWFjdGlvbl9uZXcnOiB0aGlzLnVwZGF0ZVBhcnRpY2lwYW50UmVhY3Rpb24sXG4gICAgICAgICAgICAnY2FsbC5yZWNvcmRpbmdfc3RhcnRlZCc6ICgpID0+IHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nU3ViamVjdCwgdHJ1ZSksXG4gICAgICAgICAgICAnY2FsbC5yZWNvcmRpbmdfc3RvcHBlZCc6ICgpID0+IHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nU3ViamVjdCwgZmFsc2UpLFxuICAgICAgICAgICAgJ2NhbGwucmVqZWN0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5yaW5nJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9lbmRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgICAgICdjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfam9pbmVkJzogdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkLFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9sZWZ0JzogdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50TGVmdCxcbiAgICAgICAgICAgICdjYWxsLnNlc3Npb25fc3RhcnRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgICAgICdjYWxsLnVuYmxvY2tlZF91c2VyJzogdGhpcy51bmJsb2NrVXNlcixcbiAgICAgICAgICAgICdjYWxsLnVwZGF0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXItc2lkZSBjb3VudGVkIG51bWJlciBvZiBwYXJ0aWNpcGFudHMgY29ubmVjdGVkIHRvIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICogVGhpcyBudW1iZXIgaW5jbHVkZXMgdGhlIGFub255bW91cyBwYXJ0aWNpcGFudHMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBnZXQgcGFydGljaXBhbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRDb3VudCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSB0aGUgY2FsbCBzZXNzaW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICogVXNlZnVsIGZvciBkaXNwbGF5aW5nIHRoZSBjYWxsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzdGFydGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0ZWRBdCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyLXNpZGUgY291bnRlZCBudW1iZXIgb2YgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgdG8gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKiBUaGlzIG51bWJlciBpbmNsdWRlcyB0aGUgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGdldCBhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJ0aWNpcGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnBhcnRpY2lwYW50cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgcGFydGljaXBhbnQgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxQYXJ0aWNpcGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMubG9jYWxQYXJ0aWNpcGFudCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdCBvZiByZW1vdGUgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IHJlbW90ZVBhcnRpY2lwYW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucmVtb3RlUGFydGljaXBhbnRzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkb21pbmFudCBzcGVha2VyIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGRvbWluYW50U3BlYWtlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZG9taW5hbnRTcGVha2VyJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHBpbm5lZCBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcGlubmVkUGFydGljaXBhbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5waW5uZWRQYXJ0aWNpcGFudHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVsbCBpZiB0aGVyZSBpcyBhbiBvbmdvaW5nIHNjcmVlbiBzaGFyZSBpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGhhc09uZ29pbmdTY3JlZW5TaGFyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuaGFzT25nb2luZ1NjcmVlblNoYXJlJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsaW5nIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBjYWxsaW5nU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxpbmdTdGF0ZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBzdGF0cyByZXBvcnQuXG4gICAgICovXG4gICAgZ2V0IGNhbGxTdGF0c1JlcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbFN0YXRzUmVwb3J0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZW1iZXJzIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IG1lbWJlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm1lbWJlcnMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgY3VycmVudCB1c2VyIGZvciB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBvd25DYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm93bkNhcGFiaWxpdGllcyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmFja3N0YWdlIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBiYWNrc3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmJhY2tzdGFnZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIGxpc3Qgb2YgYmxvY2tlZCB1c2VyIElEcy5cbiAgICAgKi9cbiAgICBnZXQgYmxvY2tlZFVzZXJJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIGdldCBjcmVhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRBdCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gZW5kZWQuXG4gICAgICovXG4gICAgZ2V0IGVuZGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQXQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIHNjaGVkdWxlZCB0byBzdGFydC5cbiAgICAgKi9cbiAgICBnZXQgc3RhcnRzQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXJ0c0F0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqL1xuICAgIGdldCB1cGRhdGVkQXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnVwZGF0ZWRBdCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBjcmVhdGVkQnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRCeSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIGN1c3RvbSBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgY3VzdG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5jdXN0b20kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSBlZ3Jlc3MgZGF0YSBvZiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGVncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgaW5ncmVzcyBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgaW5ncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuaW5ncmVzcyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHJlY29yZGluZyBzdGF0ZSBvZiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IHJlY29yZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgc2Vzc2lvbiBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgc2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2Vzc2lvbiQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHNldHRpbmdzIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNldHRpbmdzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdHJhbnNjcmliaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNjcmliaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy50cmFuc2NyaWJpbmckKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB1c2VyIHdobyBlbmRlZCB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGVuZGVkQnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQnkkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aHVtYm5haWxzIG9mIHRoaXMgY2FsbCwgaWYgZW5hYmxlZCBpbiB0aGUgY2FsbCBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBnZXQgdGh1bWJuYWlscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMudGh1bWJuYWlscyQpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtVmlkZW9Xcml0ZWFibGVTdGF0ZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RvcmUga2VlcGluZyBkYXRhIG9mIGEgc3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB1c2VyIG92ZXIgV1MgdG8gdGhlIGNvb3JkaW5hdG9yIHNlcnZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxsc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgICAgICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAgICAgICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSA9IHNldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB1c2VyIHRoZSB1c2VyIHRvIHNldCBhcyBjb25uZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENvbm5lY3RlZFVzZXIgPSAodXNlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3QsIHVzZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDYWxscyA9IChjYWxscykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbHNTdWJqZWN0LCBjYWxscyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEge0BsaW5rIENhbGx9IG9iamVjdCB0byB0aGUgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIGFkZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVnaXN0ZXJDYWxsID0gKGNhbGwpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxscy5maW5kKChjKSA9PiBjLmNpZCA9PT0gY2FsbC5jaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDYWxscygoY2FsbHMpID0+IFsuLi5jYWxscywgY2FsbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHtAbGluayBDYWxsfSBvYmplY3QgZnJvbSB0aGUgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIHJlbW92ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2FsbCA9IChjYWxsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDYWxscygoY2FsbHMpID0+IGNhbGxzLmZpbHRlcigoYykgPT4gYyAhPT0gY2FsbCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgYSB7QGxpbmsgQ2FsbH0gb2JqZWN0IGluIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgY2FsbCB0byBmaW5kLlxuICAgICAgICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBjYWxsIHRvIGZpbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbmRDYWxsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxscy5maW5kKChjKSA9PiBjLnR5cGUgPT09IHR5cGUgJiYgYy5pZCA9PT0gaWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RlZFVzZXJTdWJqZWN0LnN1YnNjcmliZShhc3luYyAodXNlcikgPT4ge1xuICAgICAgICAgICAgLy8gbGVhdmUgYWxsIGNhbGxzIHdoZW4gdGhlIHVzZXIgZGlzY29ubmVjdHMuXG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydjbGllbnQtc3RhdGUnXSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMuY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIoJ2luZm8nLCBgVXNlciBkaXNjb25uZWN0ZWQsIGxlYXZpbmcgY2FsbDogJHtjYWxsLmNpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlYXZlKHsgcmVhc29uOiAnY2xpZW50LmRpc2Nvbm5lY3RVc2VyKCkgY2FsbGVkJyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCBgRXJyb3IgbGVhdmluZyBjYWxsOiAke2NhbGwuY2lkfWAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHVzZXIuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3RlZFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNvbm5lY3RlZFVzZXJTdWJqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXQgY2FsbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxzU3ViamVjdCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJlYWN0aXZlIHN0b3JlIHRoYXQgZXhwb3NlcyBzdGF0ZSB2YXJpYWJsZXMgaW4gYSByZWFjdGl2ZSBtYW5uZXIuXG4gKiBZb3UgY2FuIHN1YnNjcmliZSB0byBjaGFuZ2VzIG9mIHRoZSBkaWZmZXJlbnQgc3RhdGUgdmFyaWFibGVzLlxuICogVGhpcyBjZW50cmFsIHN0b3JlIGNvbnRhaW5zIGFsbCB0aGUgc3RhdGUgdmFyaWFibGVzIHJlbGF0ZWQgdG8gW2BTdHJlYW1WaWRlb0NsaWVudGBdKC4vU3RyZWFtVmlkZUNsaWVudC5tZCkgYW5kIFtgQ2FsbGBdKC4vQ2FsbC5tZCkuXG4gKi9cbmNsYXNzIFN0cmVhbVZpZGVvUmVhZE9ubHlTdGF0ZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0aGUgZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgc3RhdGUgdmFyaWFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYnNlcnZhYmxlIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgY3VycmVudCB2YWx1ZSBvZi5cbiAgICAgICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG9ic2VydmFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLy8gY29udmVydCBhbmQgZXhwb3NlIHN1YmplY3RzIGFzIG9ic2VydmFibGVzXG4gICAgICAgIHRoaXMuY29ubmVjdGVkVXNlciQgPSBzdG9yZS5jb25uZWN0ZWRVc2VyU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jYWxscyQgPSBzdG9yZS5jYWxsc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHVzZXIgY29ubmVjdGVkIG92ZXIgV1MgdG8gdGhlIGJhY2tlbmQuXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3RlZFVzZXIoKSB7XG4gICAgICAgIHJldHVybiBnZXRDdXJyZW50VmFsdWUodGhpcy5jb25uZWN0ZWRVc2VyJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICovXG4gICAgZ2V0IGNhbGxzKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbHMkKTtcbiAgICB9XG59XG5cbmNvbnN0IGdldFJ0cE1hcCA9IChsaW5lKSA9PiB7XG4gICAgLy8gRXhhbXBsZTogYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgIGNvbnN0IHJ0cFJlZ2V4ID0gL15hPXJ0cG1hcDooXFxkKikgKFtcXHdcXC0uXSopKD86XFxzKlxcLyhcXGQqKSg/OlxccypcXC8oXFxTKikpPyk/LztcbiAgICAvLyBUaGUgZmlyc3QgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIHBheWxvYWQgdHlwZSBudW1iZXIsIHRoZSBzZWNvbmQgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIGVuY29kaW5nIG5hbWUsIHRoZSB0aGlyZCBjYXB0dXJlZCBncm91cCBpcyB0aGUgY2xvY2sgcmF0ZSwgYW5kIHRoZSBmb3VydGggY2FwdHVyZWQgZ3JvdXAgaXMgYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycy5cbiAgICBjb25zdCBydHBNYXRjaCA9IHJ0cFJlZ2V4LmV4ZWMobGluZSk7XG4gICAgaWYgKHJ0cE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW5hbDogcnRwTWF0Y2hbMF0sXG4gICAgICAgICAgICBwYXlsb2FkOiBydHBNYXRjaFsxXSxcbiAgICAgICAgICAgIGNvZGVjOiBydHBNYXRjaFsyXSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgZ2V0Rm10cCA9IChsaW5lKSA9PiB7XG4gICAgLy8gRXhhbXBsZTogYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICBjb25zdCBmbXRwUmVnZXggPSAvXmE9Zm10cDooXFxkKikgKC4qKS87XG4gICAgY29uc3QgZm10cE1hdGNoID0gZm10cFJlZ2V4LmV4ZWMobGluZSk7XG4gICAgLy8gVGhlIGZpcnN0IGNhcHR1cmVkIGdyb3VwIGlzIHRoZSBwYXlsb2FkIHR5cGUgbnVtYmVyLCB0aGUgc2Vjb25kIGNhcHR1cmVkIGdyb3VwIGlzIGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuXG4gICAgaWYgKGZtdHBNYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ2luYWw6IGZtdHBNYXRjaFswXSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGZtdHBNYXRjaFsxXSxcbiAgICAgICAgICAgIGNvbmZpZzogZm10cE1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIGdldHMgdGhlIG1lZGlhIHNlY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgbWVkaWEgdHlwZS5cbiAqIFRoZSBtZWRpYSBzZWN0aW9uIGNvbnRhaW5zIHRoZSBtZWRpYSB0eXBlLCBwb3J0LCBjb2RlYywgYW5kIHBheWxvYWQgdHlwZS5cbiAqIEV4YW1wbGU6IG09dmlkZW8gOSBVRFAvVExTL1JUUC9TQVZQRiAxMDAgMTAxIDk2IDk3IDM1IDM2IDEwMiAxMjUgMTI3XG4gKi9cbmNvbnN0IGdldE1lZGlhID0gKGxpbmUsIG1lZGlhVHlwZSkgPT4ge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKG09JHttZWRpYVR5cGV9IFxcXFxkKyBbXFxcXHcvXSspIChbXFxcXGRcXFxcc10rKWApO1xuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhsaW5lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBtYXRjaFswXSxcbiAgICAgICAgICAgIG1lZGlhV2l0aFBvcnRzOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIGNvZGVjT3JkZXI6IG1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBnZXRNZWRpYVNlY3Rpb24gPSAoc2RwLCBtZWRpYVR5cGUpID0+IHtcbiAgICBsZXQgbWVkaWE7XG4gICAgY29uc3QgcnRwTWFwID0gW107XG4gICAgY29uc3QgZm10cCA9IFtdO1xuICAgIGxldCBpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1ZhbGlkTGluZSA9IC9eKFthLXpdKT0oLiopLy50ZXN0KGxpbmUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKlxuICAgICAgICAgIE5PVEU6IGFjY29yZGluZyB0byBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjODg2Ni5wZGZcbiAgICAgICAgICBFYWNoIG1lZGlhIGRlc2NyaXB0aW9uIHN0YXJ0cyB3aXRoIGFuIFwibT1cIiBsaW5lIGFuZCBjb250aW51ZXMgdG8gdGhlIG5leHQgbWVkaWEgZGVzY3JpcHRpb24gb3IgdGhlIGVuZCBvZiB0aGUgd2hvbGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiwgd2hpY2hldmVyIGNvbWVzIGZpcnN0XG4gICAgICAgICovXG4gICAgICAgIGNvbnN0IHR5cGUgPSBsaW5lWzBdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICAgICAgICBjb25zdCBfbWVkaWEgPSBnZXRNZWRpYShsaW5lLCBtZWRpYVR5cGUpO1xuICAgICAgICAgICAgaXNUaGVSZXF1aXJlZE1lZGlhU2VjdGlvbiA9ICEhX21lZGlhO1xuICAgICAgICAgICAgaWYgKF9tZWRpYSkge1xuICAgICAgICAgICAgICAgIG1lZGlhID0gX21lZGlhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGhlUmVxdWlyZWRNZWRpYVNlY3Rpb24gJiYgdHlwZSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICBjb25zdCBydHBNYXBMaW5lID0gZ2V0UnRwTWFwKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgZm10cExpbmUgPSBnZXRGbXRwKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJ0cE1hcExpbmUpIHtcbiAgICAgICAgICAgICAgICBydHBNYXAucHVzaChydHBNYXBMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZtdHBMaW5lKSB7XG4gICAgICAgICAgICAgICAgZm10cC5wdXNoKGZtdHBMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVkaWEsXG4gICAgICAgICAgICBydHBNYXAsXG4gICAgICAgICAgICBmbXRwLFxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEdldHMgdGhlIGZtdHAgbGluZSBjb3JyZXNwb25kaW5nIHRvIG9wdXNcbiAqL1xuY29uc3QgZ2V0T3B1c0ZtdHAgPSAoc2RwKSA9PiB7XG4gICAgY29uc3Qgc2VjdGlvbiA9IGdldE1lZGlhU2VjdGlvbihzZHAsICdhdWRpbycpO1xuICAgIGNvbnN0IHJ0cE1hcCA9IHNlY3Rpb24/LnJ0cE1hcC5maW5kKChyKSA9PiByLmNvZGVjLnRvTG93ZXJDYXNlKCkgPT09ICdvcHVzJyk7XG4gICAgY29uc3QgY29kZWNJZCA9IHJ0cE1hcD8ucGF5bG9hZDtcbiAgICBpZiAoY29kZWNJZCkge1xuICAgICAgICByZXR1cm4gc2VjdGlvbj8uZm10cC5maW5kKChmKSA9PiBmLnBheWxvYWQgPT09IGNvZGVjSWQpO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgYW4gU0RQIHdpdGggRFRYIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IHRvZ2dsZUR0eCA9IChzZHAsIGVuYWJsZSkgPT4ge1xuICAgIGNvbnN0IG9wdXNGbXRwID0gZ2V0T3B1c0ZtdHAoc2RwKTtcbiAgICBpZiAob3B1c0ZtdHApIHtcbiAgICAgICAgY29uc3QgbWF0Y2hEdHggPSAvdXNlZHR4PShcXGQpLy5leGVjKG9wdXNGbXRwLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkRHR4Q29uZmlnID0gYHVzZWR0eD0ke2VuYWJsZSA/ICcxJyA6ICcwJ31gO1xuICAgICAgICBpZiAobWF0Y2hEdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZtdHAgPSBvcHVzRm10cC5vcmlnaW5hbC5yZXBsYWNlKC91c2VkdHg9KFxcZCkvLCByZXF1aXJlZER0eENvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gc2RwLnJlcGxhY2Uob3B1c0ZtdHAub3JpZ2luYWwsIG5ld0ZtdHApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3Rm10cCA9IGAke29wdXNGbXRwLm9yaWdpbmFsfTske3JlcXVpcmVkRHR4Q29uZmlnfWA7XG4gICAgICAgICAgICByZXR1cm4gc2RwLnJlcGxhY2Uob3B1c0ZtdHAub3JpZ2luYWwsIG5ld0ZtdHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG59O1xuLyoqXG4gKiBFbmFibGVzIGhpZ2gtcXVhbGl0eSBhdWRpbyB0aHJvdWdoIFNEUCBtdW5naW5nIGZvciB0aGUgZ2l2ZW4gdHJhY2tNaWQuXG4gKlxuICogQHBhcmFtIHNkcCB0aGUgU0RQIHRvIG11bmdlLlxuICogQHBhcmFtIHRyYWNrTWlkIHRoZSB0cmFja01pZC5cbiAqIEBwYXJhbSBtYXhCaXRyYXRlIHRoZSBtYXggYml0cmF0ZSB0byBzZXQuXG4gKi9cbmNvbnN0IGVuYWJsZUhpZ2hRdWFsaXR5QXVkaW8gPSAoc2RwLCB0cmFja01pZCwgbWF4Qml0cmF0ZSA9IDUxMDAwMCkgPT4ge1xuICAgIG1heEJpdHJhdGUgPSBNYXRoLm1heChNYXRoLm1pbihtYXhCaXRyYXRlLCA1MTAwMDApLCA5NjAwMCk7XG4gICAgY29uc3QgcGFyc2VkU2RwID0gU0RQLnBhcnNlKHNkcCk7XG4gICAgY29uc3QgYXVkaW9NZWRpYSA9IHBhcnNlZFNkcC5tZWRpYS5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhdWRpbycgJiYgU3RyaW5nKG0ubWlkKSA9PT0gdHJhY2tNaWQpO1xuICAgIGlmICghYXVkaW9NZWRpYSlcbiAgICAgICAgcmV0dXJuIHNkcDtcbiAgICBjb25zdCBvcHVzUnRwID0gYXVkaW9NZWRpYS5ydHAuZmluZCgocikgPT4gci5jb2RlYyA9PT0gJ29wdXMnKTtcbiAgICBpZiAoIW9wdXNSdHApXG4gICAgICAgIHJldHVybiBzZHA7XG4gICAgY29uc3Qgb3B1c0ZtdHAgPSBhdWRpb01lZGlhLmZtdHAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBvcHVzUnRwLnBheWxvYWQpO1xuICAgIGlmICghb3B1c0ZtdHApXG4gICAgICAgIHJldHVybiBzZHA7XG4gICAgLy8gZW5hYmxlIHN0ZXJlbywgaWYgbm90IGFscmVhZHkgZW5hYmxlZFxuICAgIGlmIChvcHVzRm10cC5jb25maWcubWF0Y2goL3N0ZXJlbz0oXFxkKS8pKSB7XG4gICAgICAgIG9wdXNGbXRwLmNvbmZpZyA9IG9wdXNGbXRwLmNvbmZpZy5yZXBsYWNlKC9zdGVyZW89KFxcZCkvLCAnc3RlcmVvPTEnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdXNGbXRwLmNvbmZpZyA9IGAke29wdXNGbXRwLmNvbmZpZ307c3RlcmVvPTFgO1xuICAgIH1cbiAgICAvLyBzZXQgbWF4YXZlcmFnZWJpdHJhdGUsIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgIGlmIChvcHVzRm10cC5jb25maWcubWF0Y2goL21heGF2ZXJhZ2ViaXRyYXRlPShcXGQqKS8pKSB7XG4gICAgICAgIG9wdXNGbXRwLmNvbmZpZyA9IG9wdXNGbXRwLmNvbmZpZy5yZXBsYWNlKC9tYXhhdmVyYWdlYml0cmF0ZT0oXFxkKikvLCBgbWF4YXZlcmFnZWJpdHJhdGU9JHttYXhCaXRyYXRlfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gYCR7b3B1c0ZtdHAuY29uZmlnfTttYXhhdmVyYWdlYml0cmF0ZT0ke21heEJpdHJhdGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIFNEUC53cml0ZShwYXJzZWRTZHApO1xufTtcblxuY29uc3QgbG9nZ2VyJDMgPSBnZXRMb2dnZXIoWydQdWJsaXNoZXInXSk7XG4vKipcbiAqIFRoZSBgUHVibGlzaGVyYCBpcyByZXNwb25zaWJsZSBmb3IgcHVibGlzaGluZy91bnB1Ymxpc2hpbmcgbWVkaWEgc3RyZWFtcyB0by9mcm9tIHRoZSBTRlVcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQdWJsaXNoZXIge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25Db25maWd1cmF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYy5nZXRDb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYFB1Ymxpc2hlcmAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gc3RhdGUgdGhlIGNhbGwgc3RhdGUgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gaXNEdHhFbmFibGVkIHdoZXRoZXIgRFRYIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIGlzUmVkRW5hYmxlZCB3aGV0aGVyIFJFRCBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSBpY2VSZXN0YXJ0RGVsYXkgdGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXN0YXJ0aW5nIElDRSBvbmNlIGNvbm5lY3Rpb24gZ29lcyB0byBgZGlzY29ubmVjdGVkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGNvbm5lY3Rpb25Db25maWcsIHNmdUNsaWVudCwgZGlzcGF0Y2hlciwgc3RhdGUsIGlzRHR4RW5hYmxlZCwgaXNSZWRFbmFibGVkLCBpY2VSZXN0YXJ0RGVsYXkgPSAyNTAwLCB9KSB7XG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeSA9IHtcbiAgICAgICAgICAgIFtUcmFja1R5cGUuQVVESU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlZJREVPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVU5TUEVDSUZJRURdOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHVibGlzaE9wdGlvbnNQZXJUcmFja1R5cGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBtYWludGFpbmluZyB0aGUgb3JkZXIgaG93IHRyYW5zY2VpdmVycyB3ZXJlIGFkZGVkIHRvIHRoZSBwZWVyIGNvbm5lY3Rpb24uXG4gICAgICAgICAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugc29tZSBicm93c2VycyAoRmlyZWZveCkgZG9uJ3QgcmVsaWFibHkgcmVwb3J0XG4gICAgICAgICAqIHRyYWNrSWQgYW5kIGBtaWRgIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYW5zY2VpdmVySW5pdE9yZGVyID0gW107XG4gICAgICAgIHRoaXMudHJhY2tLaW5kTWFwcGluZyA9IHtcbiAgICAgICAgICAgIFtUcmFja1R5cGUuQVVESU9dOiAnYXVkaW8nLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5WSURFT106ICd2aWRlbycsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV06ICd2aWRlbycsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT106ICdhdWRpbycsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlVOU1BFQ0lGSUVEXTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNrTGF5ZXJzQ2FjaGUgPSB7XG4gICAgICAgICAgICBbVHJhY2tUeXBlLkFVRElPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5WSURFT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlVOU1BFQ0lGSUVEXTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uID0gKGNvbm5lY3Rpb25Db25maWcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgdGhpcy5vbkljZUNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCduZWdvdGlhdGlvbm5lZWRlZCcsIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCk7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGVlcnJvcicsIHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcik7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgdGhpcy5vbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJywgdGhpcy5vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiBwYztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgcHVibGlzaGVyIFBlZXJDb25uZWN0aW9uIGFuZCBjbGVhbnMgdXAgdGhlIHJlc291cmNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSAoeyBzdG9wVHJhY2tzID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9wVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wUHVibGlzaGluZygpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeSkuZm9yRWFjaCgodHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W3RyYWNrVHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy50cmFja0xheWVyc0NhY2hlKS5mb3JFYWNoKCh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNrTGF5ZXJzQ2FjaGVbdHJhY2tUeXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmljZVJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVPbkljZVJlc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMucGMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbmVnb3RpYXRpb25uZWVkZWQnLCB0aGlzLm9uTmVnb3RpYXRpb25OZWVkZWQpO1xuICAgICAgICAgICAgdGhpcy5wYy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHRyYWNrIG9mIHRoZSBnaXZlbiBtZWRpYSBzdHJlYW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgc3RyZWFtLlxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgc3RyZWFtIHdpbGwgYmUgc3RvcHBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1lZGlhU3RyZWFtIHRoZSBtZWRpYSBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrIHRoZSB0cmFjayB0byBwdWJsaXNoLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIHB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIHRoZSBvcHRpb25hbCBwdWJsaXNoIG9wdGlvbnMgdG8gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdWJsaXNoU3RyZWFtID0gYXN5bmMgKG1lZGlhU3RyZWFtLCB0cmFjaywgdHJhY2tUeXBlLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwdWJsaXNoIGEgdHJhY2sgdGhhdCBoYXMgZW5kZWQgYWxyZWFkeS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmFuc2NlaXZlciA9IHRoaXMucGNcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgICAgICAuZmluZCgodCkgPT4gdCA9PT0gdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W3RyYWNrVHlwZV0gJiZcbiAgICAgICAgICAgICAgICB0LnNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgICAgIHQuc2VuZGVyLnRyYWNrPy5raW5kID09PSB0aGlzLnRyYWNrS2luZE1hcHBpbmdbdHJhY2tUeXBlXSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIGV2ZW50IGhhbmRsZXIgd2hpY2ggbGlzdGVucyBmb3IgdGhlICdlbmRlZCcgZXZlbnQgb24gdGhlIHRyYWNrLlxuICAgICAgICAgICAgICogT25jZSB0aGUgdHJhY2sgaGFzIGVuZGVkLCBpdCB3aWxsIG5vdGlmeSB0aGUgU0ZVIGFuZCB1cGRhdGUgdGhlIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVUcmFja0VuZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdpbmZvJywgYFRyYWNrICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19IGhhcyBlbmRlZCwgbm90aWZ5aW5nIHRoZSBTRlVgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZChtZWRpYVN0cmVhbSwgdHJhY2tUeXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbi11cCwgdGhpcyBldmVudCBsaXN0ZW5lciBuZWVkcyB0byBydW4gb25seSBvbmNlLlxuICAgICAgICAgICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCF0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHNldHRpbmdzPy52aWRlby50YXJnZXRfcmVzb2x1dGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0VuY29kaW5ncyA9IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPXG4gICAgICAgICAgICAgICAgICAgID8gZmluZE9wdGltYWxWaWRlb0xheWVycyh0cmFjaywgdGFyZ2V0UmVzb2x1dGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzKHRyYWNrLCBvcHRzLnNjcmVlblNoYXJlU2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgcHJlZmVycmVkQ29kZWMgPSBvcHRzLnByZWZlcnJlZENvZGVjO1xuICAgICAgICAgICAgICAgIGlmICghcHJlZmVycmVkQ29kZWMgJiYgdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3NOYW1lID0gZ2V0T1NJbmZvKCk/Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvc05hbWUgPT09ICdpcGFkb3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gaXBhZHMgaXQgd2FzIG5vdGljZWQgdGhhdCBpZiB2cDggY29kZWMgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIGJ5dGVzIHNlbnQgaXMgMCBpbiB0aGUgb3V0Ym91bmQtcnRwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgYXJlIGZvcmNpbmcgaDI2NCBjb2RlYyBmb3IgaXBhZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRDb2RlYyA9ICdIMjY0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9zTmFtZSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkQ29kZWMgPSAnVlA4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1ByZWZlcmVuY2VzID0gdGhpcy5nZXRDb2RlY1ByZWZlcmVuY2VzKHRyYWNrVHlwZSwgcHJlZmVycmVkQ29kZWMpO1xuICAgICAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgJ2VuZGVkJyBldmVudCBvbiB0aGUgdHJhY2sgYXMgaXQgbWlnaHQgYmUgZW5kZWQgYWJydXB0bHlcbiAgICAgICAgICAgICAgICAvLyBieSBhbiBleHRlcm5hbCBmYWN0b3IgYXMgcGVybWlzc2lvbiByZXZva2VzLCBkZXZpY2UgZGlzY29ubmVjdGVkLCBldGMuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBpbiBtaW5kIHRoYXQgYHRyYWNrLnN0b3AoKWAgZG9lc24ndCB0cmlnZ2VyIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyID0gdGhpcy5wYy5hZGRUcmFuc2NlaXZlcih0cmFjaywge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXM6IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPIHx8IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbbWVkaWFTdHJlYW1dXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc2VuZEVuY29kaW5nczogdmlkZW9FbmNvZGluZ3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYEFkZGVkICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19IHRyYW5zY2VpdmVyYCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlckluaXRPcmRlci5wdXNoKHRyYWNrVHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W3RyYWNrVHlwZV0gPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hPcHRpb25zUGVyVHJhY2tUeXBlLnNldCh0cmFja1R5cGUsIG9wdHMpO1xuICAgICAgICAgICAgICAgIGlmICgnc2V0Q29kZWNQcmVmZXJlbmNlcycgaW4gdHJhbnNjZWl2ZXIgJiYgY29kZWNQcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnaW5mbycsIGBTZXR0aW5nICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19IGNvZGVjIHByZWZlcmVuY2VzYCwgY29kZWNQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNldENvZGVjUHJlZmVyZW5jZXMoY29kZWNQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUcmFjayA9IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaztcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdG9wIHRoZSB0cmFjayBpZiB3ZSBhcmUgcmUtcHVibGlzaGluZyB0aGUgc2FtZSB0cmFja1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1RyYWNrICYmIHByZXZpb3VzVHJhY2sgIT09IHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdHJhY2suZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZChtZWRpYVN0cmVhbSwgdHJhY2tUeXBlLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBwdWJsaXNoaW5nIHRoZSBnaXZlbiB0cmFjayB0eXBlIHRvIHRoZSBTRlUsIGlmIGl0IGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQuXG4gICAgICAgICAqIFVuZGVybHlpbmcgdHJhY2sgd2lsbCBiZSBzdG9wcGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIHB1Ymxpc2hlci5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdHJhY2sgdHlwZSB0byB1bnB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSBzdG9wVHJhY2sgc3BlY2lmaWVzIHdoZXRoZXIgdHJhY2sgc2hvdWxkIGJlIHN0b3BwZWQgb3IganVzdCBkaXNhYmxlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bnB1Ymxpc2hTdHJlYW0gPSBhc3luYyAodHJhY2tUeXBlLCBzdG9wVHJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0ID09PSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSAmJiB0LnNlbmRlci50cmFjayk7XG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiZcbiAgICAgICAgICAgICAgICAoc3RvcFRyYWNrXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLnJlYWR5U3RhdGUgPT09ICdsaXZlJ1xuICAgICAgICAgICAgICAgICAgICA6IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5lbmFibGVkKSkge1xuICAgICAgICAgICAgICAgIHN0b3BUcmFja1xuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5zdG9wKClcbiAgICAgICAgICAgICAgICAgICAgOiAodHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmVuYWJsZWQgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBub3RpZnkgU0ZVIGlmIHVucHVibGlzaGluZyBpbiByZXNwb25zZSB0byByZW1vdGUgc29mdCBtdXRlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubG9jYWxQYXJ0aWNpcGFudD8ucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ub3RpZnlUcmFja011dGVTdGF0ZUNoYW5nZWQodW5kZWZpbmVkLCB0cmFja1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkIHRvIHRoZSBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gY2hlY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUHVibGlzaGluZyA9ICh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlID0gdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W3RyYWNrVHlwZV07XG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUgJiYgdHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUuc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VuZGVyID0gdHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUuc2VuZGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiAoISFzZW5kZXIudHJhY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyLnRyYWNrLnJlYWR5U3RhdGUgPT09ICdsaXZlJyAmJlxuICAgICAgICAgICAgICAgICAgICBzZW5kZXIudHJhY2suZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRyYWNrIHR5cGUgaXMgY3VycmVudGx5IGxpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdHJhY2sgdHlwZSB0byBjaGVjay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNMaXZlID0gKHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlckZvclRyYWNrVHlwZSAmJiB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhc2VuZGVyLnRyYWNrICYmIHNlbmRlci50cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkID0gYXN5bmMgKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIGlzTXV0ZWQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LnVwZGF0ZU11dGVTdGF0ZSh0cmFja1R5cGUsIGlzTXV0ZWQpO1xuICAgICAgICAgICAgY29uc3QgYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbSA9IHRyYWNrVHlwZVRvUGFydGljaXBhbnRTdHJlYW1LZXkodHJhY2tUeXBlKTtcbiAgICAgICAgICAgIGlmIChpc011dGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudCh0aGlzLnNmdUNsaWVudC5zZXNzaW9uSWQsIChwKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZWRUcmFja3M6IHAucHVibGlzaGVkVHJhY2tzLmZpbHRlcigodCkgPT4gdCAhPT0gdHJhY2tUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgW2F1ZGlvT3JWaWRlb09yU2NyZWVuU2hhcmVTdHJlYW1dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudCh0aGlzLnNmdUNsaWVudC5zZXNzaW9uSWQsIChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZWRUcmFja3M6IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHAucHVibGlzaGVkVHJhY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbLi4ucC5wdWJsaXNoZWRUcmFja3MsIHRyYWNrVHlwZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbV06IG1lZGlhU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgcHVibGlzaGluZyBhbGwgdHJhY2tzIGFuZCBzdG9wIGFsbCB0cmFja3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BQdWJsaXNoaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ1N0b3BwaW5nIHB1Ymxpc2hpbmcgYWxsIHRyYWNrcycpO1xuICAgICAgICAgICAgdGhpcy5wYy5nZXRTZW5kZXJzKCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgIHMudHJhY2s/LnN0b3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYy5yZW1vdmVUcmFjayhzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWRlb1B1Ymxpc2hRdWFsaXR5ID0gYXN5bmMgKGVuYWJsZWRMYXllcnMpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlciQzKCdpbmZvJywgJ1VwZGF0ZSBwdWJsaXNoIHF1YWxpdHksIHJlcXVlc3RlZCBsYXllcnMgYnkgU0ZVOicsIGVuYWJsZWRMYXllcnMpO1xuICAgICAgICAgICAgY29uc3QgdmlkZW9TZW5kZXIgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbVHJhY2tUeXBlLlZJREVPXT8uc2VuZGVyO1xuICAgICAgICAgICAgaWYgKCF2aWRlb1NlbmRlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgJ1VwZGF0ZSBwdWJsaXNoIHF1YWxpdHksIG5vIHZpZGVvIHNlbmRlciBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB2aWRlb1NlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnd2FybicsICdVcGRhdGUgcHVibGlzaCBxdWFsaXR5LCBObyBzdWl0YWJsZSB2aWRlbyBlbmNvZGluZyBxdWFsaXR5IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBlbmFibGVkUmlkcyA9IGVuYWJsZWRMYXllcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChseSkgPT4gbHkuYWN0aXZlKVxuICAgICAgICAgICAgICAgIC5tYXAoKGx5KSA9PiBseS5uYW1lKTtcbiAgICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmxpcCAnYWN0aXZlJyBmbGFnIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRFbmFibGUgPSBlbmFibGVkUmlkcy5pbmNsdWRlcyhlbmMucmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRW5hYmxlICE9PSBlbmMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYy5hY3RpdmUgPSBzaG91bGRFbmFibGU7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXllciA9IGVuYWJsZWRMYXllcnMuZmluZCgodmxzKSA9PiB2bHMubmFtZSA9PT0gZW5jLnJpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID49IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5zY2FsZVJlc29sdXRpb25Eb3duQnkgIT09IGVuYy5zY2FsZVJlc29sdXRpb25Eb3duQnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnW2R5bmFzY2FsZV06IHNldHRpbmcgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IGZyb20gc2VydmVyJywgJ2xheWVyJywgbGF5ZXIubmFtZSwgJ3NjYWxlLXJlc29sdXRpb24tZG93bi1ieScsIGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5tYXhCaXRyYXRlID4gMCAmJiBsYXllci5tYXhCaXRyYXRlICE9PSBlbmMubWF4Qml0cmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdbZHluYXNjYWxlXSBzZXR0aW5nIG1heC1iaXRyYXRlIGZyb20gdGhlIHNlcnZlcicsICdsYXllcicsIGxheWVyLm5hbWUsICdtYXgtYml0cmF0ZScsIGxheWVyLm1heEJpdHJhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYy5tYXhCaXRyYXRlID0gbGF5ZXIubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5tYXhGcmFtZXJhdGUgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIubWF4RnJhbWVyYXRlICE9PSBlbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ1tkeW5hc2NhbGVdOiBzZXR0aW5nIG1heEZyYW1lcmF0ZSBmcm9tIHNlcnZlcicsICdsYXllcicsIGxheWVyLm5hbWUsICdtYXgtZnJhbWVyYXRlJywgbGF5ZXIubWF4RnJhbWVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmMubWF4RnJhbWVyYXRlID0gbGF5ZXIubWF4RnJhbWVyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVMYXllcnMgPSBwYXJhbXMuZW5jb2RpbmdzLmZpbHRlcigoZSkgPT4gZS5hY3RpdmUpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB2aWRlb1NlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCBgVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgZW5hYmxlZCByaWRzOiBgLCBhY3RpdmVMYXllcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCBgVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgbm8gY2hhbmdlOiBgLCBhY3RpdmVMYXllcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBgUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMoKWAgbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRTdGF0cyA9IChzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvZGVjUHJlZmVyZW5jZXMgPSAodHJhY2tUeXBlLCBwcmVmZXJyZWRDb2RlYykgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByZWZlcnJlZENvZGVjcygndmlkZW8nLCBwcmVmZXJyZWRDb2RlYyB8fCAndnA4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0QXVkaW9Db2RlYyA9IHRoaXMuaXNSZWRFbmFibGVkID8gJ3JlZCcgOiAnb3B1cyc7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZWNUb1JlbW92ZSA9ICF0aGlzLmlzUmVkRW5hYmxlZCA/ICdyZWQnIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcmVmZXJyZWRDb2RlY3MoJ2F1ZGlvJywgcHJlZmVycmVkQ29kZWMgPz8gZGVmYXVsdEF1ZGlvQ29kZWMsIGNvZGVjVG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuZGlkYXRlIH0gPSBlO1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnbnVsbCBpY2UgY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuaWNlVHJpY2tsZSh7XG4gICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlOiBnZXRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSxcbiAgICAgICAgICAgICAgICBwZWVyVHlwZTogUGVlclR5cGUuUFVCTElTSEVSX1VOU1BFQ0lGSUVELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNmdUNsaWVudCA9IChzZnVDbGllbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBtaWdyYXRpb24gb2YgdGhpcyBwdWJsaXNoZXIgaW5zdGFuY2UgdG8gYSBuZXcgU0ZVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbml0aWF0ZXMgYSBuZXcgYGljZVJlc3RhcnRgIG9mZmVyL2Fuc3dlciBleGNoYW5nZSB3aXRoIHRoZSBuZXcgU0ZVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBuZXcgU0ZVIGNsaWVudCB0byBtaWdyYXRlIHRvLlxuICAgICAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgbmV3IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pZ3JhdGVUbyA9IGFzeW5jIChzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICAgICAgdGhpcy5wYy5zZXRDb25maWd1cmF0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24gPSBjb25uZWN0aW9uQ29uZmlnO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVzdGFydEljZSA9IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJztcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXN0YXJ0SWNlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVnb3RpYXRlIG9ubHkgaWYgdGhlcmUgYXJlIHRyYWNrcyB0byBwdWJsaXNoXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdGFydHMgdGhlIElDRSBjb25uZWN0aW9uIGFuZCByZW5lZ290aWF0ZXMgd2l0aCB0aGUgU0ZVLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXN0YXJ0SWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ1Jlc3RhcnRpbmcgSUNFIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbGluZ1N0YXRlID0gdGhpcy5wYy5zaWduYWxpbmdTdGF0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSWNlUmVzdGFydGluZyB8fCBzaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ0lDRSByZXN0YXJ0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZSh7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubmVnb3RpYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWF0ZXMgYSBuZXcgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHdpdGggdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgU0ZVLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uYWwgb2ZmZXIgb3B0aW9ucyB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5lZ290aWF0ZSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IG9wdGlvbnM/LmljZVJlc3RhcnQgPz8gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBsZXQgc2RwID0gdGhpcy5tdW5nZUNvZGVjcyhvZmZlci5zZHApO1xuICAgICAgICAgICAgaWYgKHNkcCAmJiB0aGlzLmlzUHVibGlzaGluZyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5W1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU9dO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlkID0gdHJhbnNjZWl2ZXIubWlkID8/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhY3RNaWQoc2RwLCB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2ssIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pO1xuICAgICAgICAgICAgICAgICAgICBzZHAgPSBlbmFibGVIaWdoUXVhbGl0eUF1ZGlvKHNkcCwgbWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIG11bmdlZCBTRFAgYmFjayB0byB0aGUgb2ZmZXJcbiAgICAgICAgICAgIG9mZmVyLnNkcCA9IHNkcDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrSW5mb3MgPSB0aGlzLmdldEN1cnJlbnRUcmFja0luZm9zKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBpZiAodHJhY2tJbmZvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGluaXRpYXRlIG5lZ290aWF0aW9uIHdpdGhvdXQgYW5ub3VuY2luZyBhbnkgdHJhY2tzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5zZnVDbGllbnQuc2V0UHVibGlzaGVyKHtcbiAgICAgICAgICAgICAgICBzZHA6IG9mZmVyLnNkcCB8fCAnJyxcbiAgICAgICAgICAgICAgICB0cmFja3M6IHRyYWNrSW5mb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhbnN3ZXInLFxuICAgICAgICAgICAgICAgICAgICBzZHA6IHJlc3BvbnNlLnNkcCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2Vycm9yJywgYHNldFJlbW90ZURlc2NyaXB0aW9uIGVycm9yYCwge1xuICAgICAgICAgICAgICAgICAgICBzZHA6IHJlc3BvbnNlLnNkcCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQuaWNlVHJpY2tsZUJ1ZmZlci5wdWJsaXNoZXJDYW5kaWRhdGVzLnN1YnNjcmliZShhc3luYyAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNlQ2FuZGlkYXRlID0gSlNPTi5wYXJzZShjYW5kaWRhdGUuaWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCBgSUNFIGNhbmRpZGF0ZSBlcnJvcmAsIFtlLCBjYW5kaWRhdGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdW5nZUNvZGVjcyA9IChzZHApID0+IHtcbiAgICAgICAgICAgIGlmIChzZHApIHtcbiAgICAgICAgICAgICAgICBzZHAgPSB0b2dnbGVEdHgoc2RwLCB0aGlzLmlzRHR4RW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2RwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dHJhY3RNaWQgPSAoc2RwLCB0cmFjaywgdHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNkcCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgJ05vIFNEUCBmb3VuZC4gUmV0dXJuaW5nIGVtcHR5IG1pZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsIGBObyAnbWlkJyBmb3VuZCBmb3IgdHJhY2suIFRyeWluZyB0byBmaW5kIGl0IGZyb20gdGhlIE9mZmVyIFNEUGApO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2RwID0gU0RQLnBhcnNlKHNkcCk7XG4gICAgICAgICAgICBjb25zdCBtZWRpYSA9IHBhcnNlZFNkcC5tZWRpYS5maW5kKChtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChtLnR5cGUgPT09IHRyYWNrLmtpbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYG1zaWRgIGlzIG5vdCBwcmVzZW50LCB3ZSBhc3N1bWUgdGhhdCB0aGUgdHJhY2sgaXMgdGhlIGZpcnN0IG9uZVxuICAgICAgICAgICAgICAgICAgICAobS5tc2lkPy5pbmNsdWRlcyh0cmFjay5pZCkgPz8gdHJ1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lZGlhPy5taWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYE5vIG1pZCBmb3VuZCBpbiBTRFAgZm9yIHRyYWNrIHR5cGUgJHt0cmFjay5raW5kfSBhbmQgaWQgJHt0cmFjay5pZH0uIEF0dGVtcHRpbmcgdG8gZmluZCBhIGhldXJpc3RpYyBtaWRgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXVyaXN0aWNNaWQgPSB0aGlzLnRyYW5zY2VpdmVySW5pdE9yZGVyLmluZGV4T2YodHJhY2tUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaGV1cmlzdGljTWlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGhldXJpc3RpY01pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdObyBoZXVyaXN0aWMgbWlkIGZvdW5kLiBSZXR1cm5pbmcgZW1wdHkgbWlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhtZWRpYS5taWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRUcmFja0luZm9zID0gKHNkcCkgPT4ge1xuICAgICAgICAgICAgc2RwID0gc2RwIHx8IHRoaXMucGMubG9jYWxEZXNjcmlwdGlvbj8uc2RwO1xuICAgICAgICAgICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlc29sdXRpb24gPSBzZXR0aW5ncz8udmlkZW8udGFyZ2V0X3Jlc29sdXRpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHQpID0+IHQuZGlyZWN0aW9uID09PSAnc2VuZG9ubHknICYmIHQuc2VuZGVyLnRyYWNrKVxuICAgICAgICAgICAgICAgIC5tYXAoKHRyYW5zY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tUeXBlID0gTnVtYmVyKE9iamVjdC5rZXlzKHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeSkuZmluZCgoa2V5KSA9PiB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlba2V5XSA9PT0gdHJhbnNjZWl2ZXIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaztcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW1hbExheWVycztcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hPcHRzID0gdGhpcy5wdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZS5nZXQodHJhY2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1hbExheWVycyA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFT1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmluZE9wdGltYWxWaWRlb0xheWVycyh0cmFjaywgdGFyZ2V0UmVzb2x1dGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGZpbmRPcHRpbWFsU2NyZWVuU2hhcmluZ0xheWVycyh0cmFjaywgcHVibGlzaE9wdHM/LnNjcmVlblNoYXJlU2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tMYXllcnNDYWNoZVt0cmFja1R5cGVdID0gb3B0aW1hbExheWVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlcG9ydCB0aGUgbGFzdCBrbm93biBvcHRpbWFsIGxheWVycyBmb3IgZW5kZWQgdHJhY2tzXG4gICAgICAgICAgICAgICAgICAgIG9wdGltYWxMYXllcnMgPSB0aGlzLnRyYWNrTGF5ZXJzQ2FjaGVbdHJhY2tUeXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYFRyYWNrICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19IGlzIGVuZGVkLiBBbm5vdW5jaW5nIGxhc3Qga25vd24gb3B0aW1hbCBsYXllcnNgLCBvcHRpbWFsTGF5ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXJzID0gb3B0aW1hbExheWVycy5tYXAoKG9wdGltYWxMYXllcikgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgcmlkOiBvcHRpbWFsTGF5ZXIucmlkIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBiaXRyYXRlOiBvcHRpbWFsTGF5ZXIubWF4Qml0cmF0ZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBmcHM6IG9wdGltYWxMYXllci5tYXhGcmFtZXJhdGUgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eTogdGhpcy5yaWRUb1ZpZGVvUXVhbGl0eShvcHRpbWFsTGF5ZXIucmlkIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9EaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpbWFsTGF5ZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGltYWxMYXllci5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXVkaW9UcmFjayA9IFtcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLFxuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXModHJhY2tUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja1NldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1N0ZXJlbyA9IGlzQXVkaW9UcmFjayAmJiB0cmFja1NldHRpbmdzLmNoYW5uZWxDb3VudCA9PT0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0cmFja0lkOiB0cmFjay5pZCxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbWlkOiB0cmFuc2NlaXZlci5taWQgPz8gdGhpcy5leHRyYWN0TWlkKHNkcCwgdHJhY2ssIHRyYWNrVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICAgICAgICAgICAgICAgIGR0eDogaXNBdWRpb1RyYWNrICYmIHRoaXMuaXNEdHhFbmFibGVkLFxuICAgICAgICAgICAgICAgICAgICByZWQ6IGlzQXVkaW9UcmFjayAmJiB0aGlzLmlzUmVkRW5hYmxlZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JY2VDYW5kaWRhdGVFcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlIGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgYCR7ZS5lcnJvckNvZGV9OiAke2UuZXJyb3JUZXh0fWA7XG4gICAgICAgICAgICBjb25zdCBpY2VTdGF0ZSA9IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBpY2VTdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlU3RhdGUgPT09ICdjaGVja2luZycgPyAnZGVidWcnIDogJ3dhcm4nO1xuICAgICAgICAgICAgbG9nZ2VyJDMobG9nTGV2ZWwsIGBJQ0UgQ2FuZGlkYXRlIGVycm9yYCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgSUNFIENvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0b2AsIHN0YXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc05ldHdvcmtDb25uZWN0aW9uID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5PRkZMSU5FO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgYEF0dGVtcHRpbmcgdG8gcmVzdGFydCBJQ0VgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZXJyb3InLCBgSUNFIHJlc3RhcnQgZXJyb3JgLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBoYXNOZXR3b3JrQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gaW4gYGRpc2Nvbm5lY3RlZGAgc3RhdGUsIHRoZSBicm93c2VyIG1heSByZWNvdmVyIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAgICAgLy8gaGVuY2UsIHdlIGRlbGF5IHRoZSBJQ0UgcmVzdGFydFxuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgYFNjaGVkdWxpbmcgSUNFIHJlc3RhcnQgaW4gJHt0aGlzLmljZVJlc3RhcnREZWxheX0gbXMuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pY2VSZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgYGRpc2Nvbm5lY3RlZGAgb3IgYGZhaWxlZGBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbm5lY3Rpb24gbWF5IGhhdmUgcmVjb3ZlcmVkIChvciBmYWlsZWQpIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGVycm9yYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsIGBTY2hlZHVsZWQgSUNFIHJlc3RhcnQ6IGNvbm5lY3Rpb24gcmVjb3ZlcmVkLCBjYW5jZWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMuaWNlUmVzdGFydERlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYElDRSBHYXRoZXJpbmcgU3RhdGVgLCB0aGlzLnBjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNpZ25hbGluZ1N0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYFNpZ25hbGluZyBzdGF0ZSBjaGFuZ2VkYCwgdGhpcy5wYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmlkVG9WaWRlb1F1YWxpdHkgPSAocmlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmlkID09PSAncSdcbiAgICAgICAgICAgICAgICA/IFZpZGVvUXVhbGl0eS5MT1dfVU5TUEVDSUZJRURcbiAgICAgICAgICAgICAgICA6IHJpZCA9PT0gJ2gnXG4gICAgICAgICAgICAgICAgICAgID8gVmlkZW9RdWFsaXR5Lk1JRFxuICAgICAgICAgICAgICAgICAgICA6IFZpZGVvUXVhbGl0eS5ISUdIOyAvLyBkZWZhdWx0IHRvIEhJR0hcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuaXNEdHhFbmFibGVkID0gaXNEdHhFbmFibGVkO1xuICAgICAgICB0aGlzLmlzUmVkRW5hYmxlZCA9IGlzUmVkRW5hYmxlZDtcbiAgICAgICAgdGhpcy5pY2VSZXN0YXJ0RGVsYXkgPSBpY2VSZXN0YXJ0RGVsYXk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVPbkljZVJlc3RhcnQgPSBkaXNwYXRjaGVyLm9uKCdpY2VSZXN0YXJ0JywgYXN5bmMgKGljZVJlc3RhcnQpID0+IHtcbiAgICAgICAgICAgIGlmIChpY2VSZXN0YXJ0LnBlZXJUeXBlICE9PSBQZWVyVHlwZS5QVUJMSVNIRVJfVU5TUEVDSUZJRUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0SWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyJDIgPSBnZXRMb2dnZXIoWydTdWJzY3JpYmVyJ10pO1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBgUlRDUGVlckNvbm5lY3Rpb25gIHRoYXQgaGFuZGxlcyB0aGUgaW5jb21pbmdcbiAqIG1lZGlhIHN0cmVhbXMgZnJvbSB0aGUgU0ZVLlxuICovXG5jbGFzcyBTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBjb25uZWN0aW9uQ29uZmlndXJhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBTdWJzY3JpYmVyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIG9mIHRoZSBjYWxsLlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAqIEBwYXJhbSBpY2VSZXN0YXJ0RGVsYXkgdGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXN0YXJ0aW5nIElDRSB3aGVuIGNvbm5lY3Rpb24gZ29lcyB0byBgZGlzY29ubmVjdGVkYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHNmdUNsaWVudCwgZGlzcGF0Y2hlciwgc3RhdGUsIGNvbm5lY3Rpb25Db25maWcsIGljZVJlc3RhcnREZWxheSA9IDI1MDAsIH0pIHtcbiAgICAgICAgdGhpcy5pc0ljZVJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgYFJUQ1BlZXJDb25uZWN0aW9uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAoY29ubmVjdGlvbkNvbmZpZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCB0aGlzLm9uSWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5oYW5kbGVPblRyYWNrKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZWVycm9yJywgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHBjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBgUlRDUGVlckNvbm5lY3Rpb25gIGFuZCB1bnN1YnNjcmliZXMgZnJvbSB0aGUgZGlzcGF0Y2hlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pY2VSZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJPblN1YnNjcmliZXJPZmZlcigpO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyT25JY2VSZXN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLnBjLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpYCBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFN0YXRzID0gKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRTdGF0cyhzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNmdUNsaWVudCA9IChzZnVDbGllbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWlncmF0ZXMgdGhlIHN1YnNjcmliZXIgdG8gYSBuZXcgU0ZVIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgbmV3IFNGVSBjbGllbnQgdG8gbWlncmF0ZSB0by5cbiAgICAgICAgICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWcgdGhlIG5ldyBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taWdyYXRlVG8gPSAoc2Z1Q2xpZW50LCBjb25uZWN0aW9uQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFNmdUNsaWVudChzZnVDbGllbnQpO1xuICAgICAgICAgICAgLy8gd2hlbiBtaWdyYXRpbmcsIHdlIHdhbnQgdG8ga2VlcCB0aGUgcHJldmlvdXMgc3Vic2NyaWJlciBvcGVuXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGUgbmV3IG9uZSBpcyBjb25uZWN0ZWRcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUEMgPSB0aGlzLnBjO1xuICAgICAgICAgICAgLy8gd2Uga2VlcCBhIHJlY29yZCBvZiBwcmV2aW91c2x5IGF2YWlsYWJsZSB2aWRlbyB0cmFja3NcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIG1vbml0b3Igd2hlbiB0aGV5IGJlY29tZSBhdmFpbGFibGUgb24gdGhlIG5ld1xuICAgICAgICAgICAgLy8gc3Vic2NyaWJlciBhbmQgY2xvc2UgdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICAgIGNvbnN0IHRyYWNrSWRzVG9NaWdyYXRlID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgcHJldmlvdXNQQy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgICB0cmFja0lkc1RvTWlncmF0ZS5hZGQoci50cmFjay5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzZXQgdXAgYSBuZXcgc3Vic2NyaWJlciBwZWVyIGNvbm5lY3Rpb24sIGNvbmZpZ3VyZWQgdG8gY29ubmVjdFxuICAgICAgICAgICAgLy8gdG8gdGhlIG5ldyBTRlUgbm9kZVxuICAgICAgICAgICAgY29uc3QgcGMgPSB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgbGV0IG1pZ3JhdGlvblRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXBNaWdyYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQQy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChtaWdyYXRpb25UaW1lb3V0SWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gbWlncmF0aW5nLCB3ZSB3YW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHZpZGVvIHRyYWNrc1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgbWlncmF0aW5nIHRvIHRoZSBuZXcgc3Vic2NyaWJlci5cbiAgICAgICAgICAgIC8vIE9uY2UgYWxsIG9mIHRoZW0gYXJlIGF2YWlsYWJsZSwgd2UgY2FuIGNsb3NlIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlVHJhY2tNaWdyYXRpb24gPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBbTWlncmF0aW9uXTogTWlncmF0ZWQgdHJhY2s6ICR7ZS50cmFjay5pZH0sICR7ZS50cmFjay5raW5kfWApO1xuICAgICAgICAgICAgICAgIHRyYWNrSWRzVG9NaWdyYXRlLmRlbGV0ZShlLnRyYWNrLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tJZHNUb01pZ3JhdGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgW01pZ3JhdGlvbl06IE1pZ3JhdGlvbiBjb21wbGV0ZWApO1xuICAgICAgICAgICAgICAgICAgICBwYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIGhhbmRsZVRyYWNrTWlncmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cE1pZ3JhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIG1pZ3JhdGluZywgd2Ugd2FudCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjb25uZWN0aW9uIHN0YXRlXG4gICAgICAgICAgICAvLyBvZiB0aGUgbmV3IHN1YnNjcmliZXIuXG4gICAgICAgICAgICAvLyBPbmNlIGl0IGlzIGNvbm5lY3RlZCwgd2UgZ2l2ZSBpdCBhIDItc2Vjb25kIGdyYWNlIHBlcmlvZCB0byByZWNlaXZlXG4gICAgICAgICAgICAvLyBhbGwgdGhlIHZpZGVvIHRyYWNrcyB0aGF0IGFyZSBtaWdyYXRpbmcgZnJvbSB0aGUgcHJldmlvdXMgc3Vic2NyaWJlci5cbiAgICAgICAgICAgIC8vIEFmdGVyIHRoaXMgdGhyZXNob2xkLCB3ZSBhYnJ1cHRseSBjbG9zZSB0aGUgcHJldmlvdXMgc3Vic2NyaWJlci5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGMuY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBtaWdyYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgaGFuZGxlVHJhY2tNaWdyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cE1pZ3JhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgcGMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCBoYW5kbGVUcmFja01pZ3JhdGlvbik7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgUGVlckNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICAgICAgICAgIHRoaXMucGMgPSBwYztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RhcnRzIHRoZSBJQ0UgY29ubmVjdGlvbiBhbmQgcmVuZWdvdGlhdGVzIHdpdGggdGhlIFNGVS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdGFydEljZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsICdSZXN0YXJ0aW5nIElDRSBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtcmVtb3RlLW9mZmVyJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsICdJQ0UgcmVzdGFydCBpcyBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJc0ljZVJlc3RhcnRpbmcgPSB0aGlzLmlzSWNlUmVzdGFydGluZztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ljZVJlc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LmljZVJlc3RhcnQoe1xuICAgICAgICAgICAgICAgICAgICBwZWVyVHlwZTogUGVlclR5cGUuU1VCU0NSSUJFUixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUsIGFzIG91ciBpbnRlbnQgZm9yIHJlc3RhcnRpbmcgSUNFIGZhaWxlZFxuICAgICAgICAgICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gcHJldmlvdXNJc0ljZVJlc3RhcnRpbmc7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVPblRyYWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtwcmltYXJ5U3RyZWFtXSA9IGUuc3RyZWFtcztcbiAgICAgICAgICAgIC8vIGV4YW1wbGU6IGBlM2Y2YWFmOC1iMDNkLTQ5MTEtYmUzNi04M2Y0N2QzN2E3NmE6VFJBQ0tfVFlQRV9WSURFT2BcbiAgICAgICAgICAgIGNvbnN0IFt0cmFja0lkLCB0cmFja1R5cGVdID0gcHJpbWFyeVN0cmVhbS5pZC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnRUb1VwZGF0ZSA9IHRoaXMuc3RhdGUucGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAudHJhY2tMb29rdXBQcmVmaXggPT09IHRyYWNrSWQpO1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYFtvblRyYWNrXTogR290IHJlbW90ZSAke3RyYWNrVHlwZX0gdHJhY2sgZm9yIHVzZXJJZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlPy51c2VySWR9YCwgZS50cmFjay5pZCwgZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50VG9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignZXJyb3InLCBgW29uVHJhY2tdOiBSZWNlaXZlZCB0cmFjayBmb3IgdW5rbm93biBwYXJ0aWNpcGFudDogJHt0cmFja0lkfWAsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUudHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBbb25UcmFja106IFRyYWNrIG11dGVkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfSAke3RyYWNrVHlwZX06JHt0cmFja0lkfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBbb25UcmFja106IFRyYWNrIHVubXV0ZWQ6ICR7cGFydGljaXBhbnRUb1VwZGF0ZS51c2VySWR9ICR7dHJhY2tUeXBlfToke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUudHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2luZm8nLCBgW29uVHJhY2tdOiBUcmFjayBlbmRlZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlLnVzZXJJZH0gJHt0cmFja1R5cGV9OiR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtS2luZFByb3AgPSB7XG4gICAgICAgICAgICAgICAgVFJBQ0tfVFlQRV9BVURJTzogJ2F1ZGlvU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBUUkFDS19UWVBFX1ZJREVPOiAndmlkZW9TdHJlYW0nLFxuICAgICAgICAgICAgICAgIFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFOiAnc2NyZWVuU2hhcmVTdHJlYW0nLFxuICAgICAgICAgICAgICAgIFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPOiAnc2NyZWVuU2hhcmVBdWRpb1N0cmVhbScsXG4gICAgICAgICAgICB9W3RyYWNrVHlwZV07XG4gICAgICAgICAgICBpZiAoIXN0cmVhbUtpbmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2Vycm9yJywgYFVua25vd24gdHJhY2sgdHlwZTogJHt0cmFja1R5cGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTdHJlYW0gPSBwYXJ0aWNpcGFudFRvVXBkYXRlW3N0cmVhbUtpbmRQcm9wXTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1N0cmVhbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdpbmZvJywgYFtvblRyYWNrXTogQ2xlYW5pbmcgdXAgcHJldmlvdXMgcmVtb3RlICR7ZS50cmFjay5raW5kfSB0cmFja3MgZm9yIHVzZXJJZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlLnVzZXJJZH1gKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0cmVhbS5yZW1vdmVUcmFjayh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQocGFydGljaXBhbnRUb1VwZGF0ZS5zZXNzaW9uSWQsIHtcbiAgICAgICAgICAgICAgICBbc3RyZWFtS2luZFByb3BdOiBwcmltYXJ5U3RyZWFtLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JY2VDYW5kaWRhdGUgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYW5kaWRhdGUgfSA9IGU7XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsICdudWxsIGljZSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlKHtcbiAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGU6IGdldEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpLFxuICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5TVUJTQ1JJQkVSLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmVnb3RpYXRlID0gYXN5bmMgKHN1YnNjcmliZXJPZmZlcikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2luZm8nLCBgUmVjZWl2ZWQgc3Vic2NyaWJlck9mZmVyYCwgc3Vic2NyaWJlck9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICAgICAgICAgICAgc2RwOiBzdWJzY3JpYmVyT2ZmZXIuc2RwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlQnVmZmVyLnN1YnNjcmliZXJDYW5kaWRhdGVzLnN1YnNjcmliZShhc3luYyAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNlQ2FuZGlkYXRlID0gSlNPTi5wYXJzZShjYW5kaWRhdGUuaWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ3dhcm4nLCBgSUNFIGNhbmRpZGF0ZSBlcnJvcmAsIFtlLCBjYW5kaWRhdGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LnNlbmRBbnN3ZXIoe1xuICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5TVUJTQ1JJQkVSLFxuICAgICAgICAgICAgICAgIHNkcDogYW5zd2VyLnNkcCB8fCAnJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pc0ljZVJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgSUNFIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZGAsIHN0YXRlKTtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgd2hlbiBJQ0UgaXMgcmVzdGFydGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJY2VSZXN0YXJ0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGhhc05ldHdvcmtDb25uZWN0aW9uID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5PRkZMSU5FO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCd3YXJuJywgYEF0dGVtcHRpbmcgdG8gcmVzdGFydCBJQ0VgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignZXJyb3InLCBgSUNFIHJlc3RhcnQgZmFpbGVkYCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgaGFzTmV0d29ya0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGluIGBkaXNjb25uZWN0ZWRgIHN0YXRlLCB0aGUgYnJvd3NlciBtYXkgcmVjb3ZlciBhdXRvbWF0aWNhbGx5LFxuICAgICAgICAgICAgICAgIC8vIGhlbmNlLCB3ZSBkZWxheSB0aGUgSUNFIHJlc3RhcnRcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignd2FybicsIGBTY2hlZHVsaW5nIElDRSByZXN0YXJ0IGluICR7dGhpcy5pY2VSZXN0YXJ0RGVsYXl9IG1zLmApO1xuICAgICAgICAgICAgICAgIHRoaXMuaWNlUmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHN0YXRlIGlzIHN0aWxsIGBkaXNjb25uZWN0ZWRgIG9yIGBmYWlsZWRgXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb25uZWN0aW9uIG1heSBoYXZlIHJlY292ZXJlZCAob3IgZmFpbGVkKSBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnRJY2UoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBmYWlsZWRgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYFNjaGVkdWxlZCBJQ0UgcmVzdGFydDogY29ubmVjdGlvbiByZWNvdmVyZWQsIGNhbmNlbGVkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBJQ0UgZ2F0aGVyaW5nIHN0YXRlIGNoYW5nZWRgLCB0aGlzLnBjLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGUgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQgJiZcbiAgICAgICAgICAgICAgICBgJHtlLmVycm9yQ29kZX06ICR7ZS5lcnJvclRleHR9YDtcbiAgICAgICAgICAgIGNvbnN0IGljZVN0YXRlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsb2dMZXZlbCA9IGljZVN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VTdGF0ZSA9PT0gJ2NoZWNraW5nJyA/ICdkZWJ1ZycgOiAnd2Fybic7XG4gICAgICAgICAgICBsb2dnZXIkMihsb2dMZXZlbCwgYElDRSBDYW5kaWRhdGUgZXJyb3JgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNmdUNsaWVudCA9IHNmdUNsaWVudDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmljZVJlc3RhcnREZWxheSA9IGljZVJlc3RhcnREZWxheTtcbiAgICAgICAgdGhpcy5wYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlck9uU3Vic2NyaWJlck9mZmVyID0gZGlzcGF0Y2hlci5vbignc3Vic2NyaWJlck9mZmVyJywgYXN5bmMgKHN1YnNjcmliZXJPZmZlcikgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoc3Vic2NyaWJlck9mZmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5yZWdpc3Rlck9uSWNlUmVzdGFydCA9IGRpc3BhdGNoZXIub24oJ2ljZVJlc3RhcnQnLCBhc3luYyAoaWNlUmVzdGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKGljZVJlc3RhcnQucGVlclR5cGUgIT09IFBlZXJUeXBlLlNVQlNDUklCRVIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0SWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlV2ViU29ja2V0U2lnbmFsQ2hhbm5lbCA9IChvcHRzKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc2Z1LWNsaWVudCddKTtcbiAgICBjb25zdCB7IGVuZHBvaW50LCBvbk1lc3NhZ2UgfSA9IG9wdHM7XG4gICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KGVuZHBvaW50KTtcbiAgICB3cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJzsgLy8gZG8gd2UgbmVlZCB0aGlzP1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdTaWduYWxpbmcgV1MgY2hhbm5lbCBlcnJvcicsIGUpO1xuICAgIH0pO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKGUpID0+IHtcbiAgICAgICAgbG9nZ2VyKCdpbmZvJywgJ1NpZ25hbGluZyBXUyBjaGFubmVsIGlzIGNsb3NlZCcsIGUpO1xuICAgIH0pO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2luZm8nLCAnU2lnbmFsaW5nIFdTIGNoYW5uZWwgaXMgb3BlbicsIGUpO1xuICAgIH0pO1xuICAgIHdzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGUuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgPyBTZnVFdmVudC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGUuZGF0YSkpXG4gICAgICAgICAgICAgICAgOiBTZnVFdmVudC5mcm9tSnNvblN0cmluZyhlLmRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBvbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gZGVjb2RlIGEgbWVzc2FnZS4gQ2hlY2sgd2hldGhlciB0aGUgUHJvdG8gbW9kZWxzIG1hdGNoLicsIHsgZXZlbnQ6IGUsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gd3M7XG59O1xuXG5jb25zdCBzbGVlcCA9IChtKSA9PiBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBtKSk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJlxuICAgICAgICAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSk7XG59XG4vKipcbiAqIEEgbWFwIG9mIGtub3duIGVycm9yIGNvZGVzLlxuICovXG5jb25zdCBLbm93bkNvZGVzID0ge1xuICAgIFRPS0VOX0VYUElSRUQ6IDQwLFxuICAgIFdTX0NMT1NFRF9TVUNDRVNTOiAxMDAwLFxuICAgIFdTX0NMT1NFRF9BQlJVUFRMWTogMTAwNixcbiAgICBXU19QT0xJQ1lfVklPTEFUSU9OOiAxMDA4LFxufTtcbi8qKlxuICogcmV0cnlJbnRlcnZhbCAtIEEgcmV0cnkgaW50ZXJ2YWwgd2hpY2ggaW5jcmVhc2VzIGFjYyB0byBudW1iZXIgb2YgZmFpbHVyZXNcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IER1cmF0aW9uIHRvIHdhaXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwobnVtYmVyT2ZGYWlsdXJlcykge1xuICAgIC8vIHRyeSB0byByZWNvbm5lY3QgaW4gMC4yNS01IHNlY29uZHMgKHJhbmRvbSB0byBzcHJlYWQgb3V0IHRoZSBsb2FkIGZyb20gZmFpbHVyZXMpXG4gICAgY29uc3QgbWF4ID0gTWF0aC5taW4oNTAwICsgbnVtYmVyT2ZGYWlsdXJlcyAqIDIwMDAsIDUwMDApO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKE1hdGgubWF4KDI1MCwgKG51bWJlck9mRmFpbHVyZXMgLSAxKSAqIDIwMDApLCA1MDAwKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xufVxuZnVuY3Rpb24gcmFuZG9tSWQoKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlVVVJRHY0KCk7XG59XG5mdW5jdGlvbiBoZXgoYnl0ZXMpIHtcbiAgICBsZXQgcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcyArPSBieXRlc1tpXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEdjQoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRSYW5kb21CeXRlcygxNik7XG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7IC8vIHZlcnNpb25cbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4YmYpIHwgMHg4MDsgLy8gdmFyaWFudFxuICAgIHJldHVybiAoaGV4KGJ5dGVzLnN1YmFycmF5KDAsIDQpKSArXG4gICAgICAgICctJyArXG4gICAgICAgIGhleChieXRlcy5zdWJhcnJheSg0LCA2KSkgK1xuICAgICAgICAnLScgK1xuICAgICAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoNiwgOCkpICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgaGV4KGJ5dGVzLnN1YmFycmF5KDgsIDEwKSkgK1xuICAgICAgICAnLScgK1xuICAgICAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoMTAsIDE2KSkpO1xufVxuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzV2l0aE1hdGhSYW5kb20oYnl0ZXMpIHtcbiAgICBjb25zdCBtYXggPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVzLmJ5dGVMZW5ndGgpIC8gYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gTWF0aC5yYW5kb20oKSAqIG1heDtcbiAgICB9XG59XG5jb25zdCBnZXRSYW5kb21WYWx1ZXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmRvbVZhbHVlc1dpdGhNYXRoUmFuZG9tO1xuICAgIH1cbn0pKCk7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0RXJyb3JUb0pzb24oZXJyKSB7XG4gICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgIGlmICghZXJyKVxuICAgICAgICByZXR1cm4ganNvbk9iajtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAganNvbk9ialtrZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlcnIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6ICdmYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBlcnJvcicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBqc29uT2JqO1xufVxuLyoqXG4gKiBpc09ubGluZSBzYWZlbHkgcmV0dXJuIHRoZSBuYXZpZ2F0b3Iub25saW5lIHZhbHVlIGZvciBicm93c2VyIGVudlxuICogaWYgbmF2aWdhdG9yIGlzIG5vdCBpbiBnbG9iYWwgb2JqZWN0LCBpdCBhbHdheXMgcmV0dXJuIHRydWVcbiAqL1xuZnVuY3Rpb24gaXNPbmxpbmUobG9nZ2VyKSB7XG4gICAgY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBuYXZpZ2F0b3JcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yXG4gICAgICAgICAgICA/IHdpbmRvdy5uYXZpZ2F0b3JcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICghbmF2KSB7XG4gICAgICAgIGxvZ2dlcignd2FybicsICdpc09ubGluZSBmYWlsZWQgdG8gYWNjZXNzIHdpbmRvdy5uYXZpZ2F0b3IgYW5kIGFzc3VtZSBicm93c2VyIGlzIG9ubGluZScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUk4gbmF2aWdhdG9yIGhhcyB1bmRlZmluZWQgZm9yIG9uTGluZVxuICAgIGlmICh0eXBlb2YgbmF2Lm9uTGluZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbmF2Lm9uTGluZTtcbn1cbi8qKlxuICogbGlzdGVuRm9yQ29ubmVjdGlvbkNoYW5nZXMgLSBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZpcmVkIG9uIGJyb3dzZXIgZ29pbmcgb25saW5lIG9yIG9mZmxpbmVcbiAqL1xuZnVuY3Rpb24gYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKGNiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgY2IpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgY2IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbm5lY3Rpb25FdmVudExpc3RlbmVycyhjYikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGNiKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGNiKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGNsaWVudCB1c2VkIGZvciBleGNoYW5naW5nIGluZm9ybWF0aW9uIHdpdGggdGhlIFNGVS5cbiAqL1xuY2xhc3MgU3RyZWFtU2Z1Q2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNGVSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlzcGF0Y2hlciB0aGUgZXZlbnQgZGlzcGF0Y2hlciB0byB1c2UuXG4gICAgICogQHBhcmFtIHNmdVNlcnZlciB0aGUgU0ZVIHNlcnZlciB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSB0b2tlbiB0aGUgSldUIHRva2VuIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgYHNlc3Npb25JZGAgb2YgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgcGFydGljaXBhbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBkaXNwYXRjaGVyLCBzZnVTZXJ2ZXIsIHRva2VuLCBzZXNzaW9uSWQsIH0pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGZvciBJQ0UgQ2FuZGlkYXRlcyB0aGF0IGFyZSByZWNlaXZlZCBiZWZvcmVcbiAgICAgICAgICogdGhlIFBlZXJDb25uZWN0aW9ucyBhcmUgcmVhZHkgdG8gaGFuZGxlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmljZVRyaWNrbGVCdWZmZXIgPSBuZXcgSWNlVHJpY2tsZUJ1ZmZlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSBtaWdyYXRpbmcgYXdheVxuICAgICAgICAgKiBmcm9tIHRoaXMgU0ZVLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc01pZ3JhdGluZ0F3YXkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlIGNsaWVudCBjb25uZWN0aW9uIGlzIGJyb2tlbiBmb3IgdGhlIGN1cnJlbnRcbiAgICAgICAgICogY2xpZW50IGFuZCB0aGF0IGEgZmFzdC1yZWNvbm5lY3Qgd2l0aCBhIG5ldyBjbGllbnQgc2hvdWxkIGJlIGF0dGVtcHRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNGYXN0UmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsSW5NcyA9IDEwICogMTAwMDtcbiAgICAgICAgdGhpcy51bmhlYWx0aHlUaW1lb3V0SW5NcyA9IHRoaXMucGluZ0ludGVydmFsSW5NcyArIDUgKiAxMDAwO1xuICAgICAgICB0aGlzLmNsb3NlID0gKGNvZGUsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYENsb3NpbmcgU0ZVIFdTIGNvbm5lY3Rpb246ICR7Y29kZX0gLSAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbFdzLnJlYWR5U3RhdGUgIT09IHRoaXMuc2lnbmFsV3MuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWxXcy5jbG9zZShjb2RlLCBganMtY2xpZW50OiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVJY2VUcmlja2xlKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucyA9IGFzeW5jIChzdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLnVwZGF0ZVN1YnNjcmlwdGlvbnMoe1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgdHJhY2tzOiBzdWJzY3JpcHRpb25zLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRQdWJsaXNoZXIgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy5zZXRQdWJsaXNoZXIoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEFuc3dlciA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLnNlbmRBbnN3ZXIoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaWNlVHJpY2tsZSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLmljZVRyaWNrbGUoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaWNlUmVzdGFydCA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLmljZVJlc3RhcnQoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTXV0ZVN0YXRlID0gYXN5bmMgKHRyYWNrVHlwZSwgbXV0ZWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU11dGVTdGF0ZXMoe1xuICAgICAgICAgICAgICAgIG11dGVTdGF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0ZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZU11dGVTdGF0ZXMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy51cGRhdGVNdXRlU3RhdGVzKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRTdGF0cyA9IGFzeW5jIChzdGF0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy5zZW5kU3RhdHMoe1xuICAgICAgICAgICAgICAgIC4uLnN0YXRzLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmpvaW4gPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgam9pblJlcXVlc3QgPSBKb2luUmVxdWVzdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50b2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChTZnVSZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnam9pblJlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICBqb2luUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmQgPSBhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmFsUmVhZHkudGhlbigoc2lnbmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5yZWFkeVN0YXRlICE9PSBzaWduYWwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBTZW5kaW5nIG1lc3NhZ2UgdG86ICR7dGhpcy5lZGdlTmFtZX1gLCBTZnVSZXF1ZXN0LnRvSnNvbihtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgc2lnbmFsLnNlbmQoU2Z1UmVxdWVzdC50b0JpbmFyeShtZXNzYWdlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCAnU2VuZGluZyBoZWFsdGhDaGVja1JlcXVlc3QgdG8gU0ZVJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFNmdVJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2hlYWx0aENoZWNrUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhDaGVja1JlcXVlc3Q6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChtZXNzYWdlKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnRXJyb3Igc2VuZGluZyBoZWFsdGhDaGVja1JlcXVlc3QgdG8gU0ZVJywgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbEluTXMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0TWVzc2FnZVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0TWVzc2FnZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0TWVzc2FnZVRpbWVzdGFtcC5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0TWVzc2FnZSA+IHRoaXMudW5oZWFsdGh5VGltZW91dEluTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoU3RyZWFtU2Z1Q2xpZW50LkVSUk9SX0NPTk5FQ1RJT05fVU5IRUFMVEhZLCBgU0ZVIGNvbm5lY3Rpb24gdW5oZWFsdGh5LiBEaWRuJ3QgcmVjZWl2ZSBhbnkgbWVzc2FnZSBmb3IgJHt0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zfW1zYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQgfHwgZ2VuZXJhdGVVVUlEdjQoKTtcbiAgICAgICAgdGhpcy5zZnVTZXJ2ZXIgPSBzZnVTZXJ2ZXI7XG4gICAgICAgIHRoaXMuZWRnZU5hbWUgPSBzZnVTZXJ2ZXIuZWRnZV9uYW1lO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc2Z1LWNsaWVudCddKTtcbiAgICAgICAgY29uc3QgbG9nSW50ZXJjZXB0b3IgPSB7XG4gICAgICAgICAgICBpbnRlcmNlcHRVbmFyeTogKG5leHQsIG1ldGhvZCwgaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgQ2FsbGluZyBTRlUgUlBDIG1ldGhvZCAke21ldGhvZC5uYW1lfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQobWV0aG9kLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJwYyA9IGNyZWF0ZVNpZ25hbENsaWVudCh7XG4gICAgICAgICAgICBiYXNlVXJsOiBzZnVTZXJ2ZXIudXJsLFxuICAgICAgICAgICAgaW50ZXJjZXB0b3JzOiBbXG4gICAgICAgICAgICAgICAgd2l0aEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsb2dJbnRlcmNlcHRvcixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgSUNFVHJpY2tsZSBraW5kIG9mIGV2ZW50cy5cbiAgICAgICAgLy8gVGhlc2UgZXZlbnRzIG1pZ2h0IGJlIHRyaWdnZXJlZCBieSB0aGUgU0ZVIGJlZm9yZSB0aGUgaW5pdGlhbCBSVENcbiAgICAgICAgLy8gY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC4gSW4gdGhhdCBjYXNlLCB0aG9zZSBldmVudHMgKElDRSBjYW5kaWRhdGVzKVxuICAgICAgICAvLyBuZWVkIHRvIGJlIGJ1ZmZlcmVkIGFuZCBsYXRlciBhZGRlZCB0byB0aGUgYXBwcm9wcmlhdGUgUGVlckNvbm5lY3Rpb25cbiAgICAgICAgLy8gb25jZSB0aGUgcmVtb3RlRGVzY3JpcHRpb24gaXMga25vd24gYW5kIHNldC5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUljZVRyaWNrbGUgPSBkaXNwYXRjaGVyLm9uKCdpY2VUcmlja2xlJywgKGljZVRyaWNrbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaWNlVHJpY2tsZUJ1ZmZlci5wdXNoKGljZVRyaWNrbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaWduYWxXcyA9IGNyZWF0ZVdlYlNvY2tldFNpZ25hbENoYW5uZWwoe1xuICAgICAgICAgICAgZW5kcG9pbnQ6IHNmdVNlcnZlci53c19lbmRwb2ludCxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrKCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5kaXNwYXRjaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpZ25hbFJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9uT3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbFdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMua2VlcEFsaXZlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNpZ25hbFdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNpZ25hbFdzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBub3JtYWwgY2xvc3VyZSBjb2RlLiBVc2VkIGZvciBjb250cm9sbGVkIHNodXRkb3ducy5cbiAqL1xuU3RyZWFtU2Z1Q2xpZW50Lk5PUk1BTF9DTE9TVVJFID0gMTAwMDtcbi8qKlxuICogVGhlIGVycm9yIGNvZGUgdXNlZCB3aGVuIHRoZSBTRlUgY29ubmVjdGlvbiBpcyB1bmhlYWx0aHkuXG4gKiBVc3VhbGx5LCB0aGlzIG1lYW5zIHRoYXQgbm8gbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCBmcm9tIHRoZSBTRlUgZm9yXG4gKiBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGBjb25uZWN0aW9uQ2hlY2tUaW1lb3V0YCkuXG4gKi9cblN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX1VOSEVBTFRIWSA9IDQwMDE7XG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHVzZWQgd2hlbiB0aGUgU0ZVIGNvbm5lY3Rpb24gaXMgYnJva2VuLlxuICogVXN1YWxseSwgdGhpcyBtZWFucyB0aGF0IHRoZSBXUyBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCB1bmV4cGVjdGVkbHkuXG4gKiBUaGlzIGVycm9yIGNvZGUgaXMgdXNlZCB0byBhbm5vdW5jZSBhIGZhc3QtcmVjb25uZWN0LlxuICovXG5TdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4gPSA0MDAyOyAvLyB1c2VkIGluIGZhc3QtcmVjb25uZWN0c1xuY29uc3QgTUFYX1JFVFJJRVMgPSA1O1xuLyoqXG4gKiBDcmVhdGVzIGEgY2xvc3VyZSB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gUlBDIGNhbGwgYW5kIHJldHJpZXMgaW52b2tpbmdcbiAqIHRoZSBSUEMgdW50aWwgaXQgc3VjY2VlZHMgb3IgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgaXMgcmVhY2hlZC5cbiAqXG4gKiBCZXR3ZWVuIGVhY2ggcmV0cnksIHRoZXJlIHdvdWxkIGJlIGEgcmFuZG9tIGRlbGF5IGluIG9yZGVyIHRvIGF2b2lkXG4gKiByZXF1ZXN0IGJ1cnN0cyB0b3dhcmRzIHRoZSBTRlUuXG4gKlxuICogQHBhcmFtIHJwYyB0aGUgY2xvc3VyZSBhcm91bmQgdGhlIFJQQyBjYWxsIHRvIGV4ZWN1dGUuXG4gKiBAcGFyYW0gbG9nZ2VyIGEgbG9nZ2VyIGluc3RhbmNlIHRvIHVzZS5cbiAqIEBwYXJhbSA8ST4gdGhlIHR5cGUgb2YgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIDxPPiB0aGUgdHlwZSBvZiB0aGUgcmVzcG9uc2Ugb2JqZWN0LlxuICovXG5jb25zdCByZXRyeWFibGUgPSBhc3luYyAocnBjLCBsb2dnZXIpID0+IHtcbiAgICBsZXQgcmV0cnlBdHRlbXB0ID0gMDtcbiAgICBsZXQgcnBjQ2FsbFJlc3VsdDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGRvbid0IGRlbGF5IHRoZSBmaXJzdCBpbnZvY2F0aW9uXG4gICAgICAgIGlmIChyZXRyeUF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHJldHJ5QXR0ZW1wdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJwY0NhbGxSZXN1bHQgPSBhd2FpdCBycGMoKTtcbiAgICAgICAgbG9nZ2VyKCd0cmFjZScsIGBTRlUgUlBDIHJlc3BvbnNlIHJlY2VpdmVkIGZvciAke3JwY0NhbGxSZXN1bHQubWV0aG9kLm5hbWV9YCwgcnBjQ2FsbFJlc3VsdCk7XG4gICAgICAgIC8vIGlmIHRoZSBSUEMgY2FsbCBmYWlsZWQsIGxvZyB0aGUgZXJyb3IgYW5kIHJldHJ5XG4gICAgICAgIGlmIChycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgYFNGVSBSUEMgRXJyb3IgKCR7cnBjQ2FsbFJlc3VsdC5tZXRob2QubmFtZX0pOmAsIHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5QXR0ZW1wdCsrO1xuICAgIH0gd2hpbGUgKHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3I/LnNob3VsZFJldHJ5ICYmXG4gICAgICAgIHJldHJ5QXR0ZW1wdCA8IE1BWF9SRVRSSUVTKTtcbiAgICBpZiAocnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcikge1xuICAgICAgICB0aHJvdyBycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcnBjQ2FsbFJlc3VsdDtcbn07XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlciB0aGF0IHdhdGNoZWQgdGhlIGRlbGl2ZXJ5IG9mIGBjYWxsLmFjY2VwdGVkYC5cbiAqIE9uY2UgdGhlIGV2ZW50IGlzIHJlY2VpdmVkLCB0aGUgY2FsbCBpcyBqb2luZWQuXG4gKi9cbmNvbnN0IHdhdGNoQ2FsbEFjY2VwdGVkID0gKGNhbGwpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsQWNjZXB0ZWQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBkaXNjYXJkIHRoZSBldmVudCBpZiBpdCdzIGZyb20gdGhlIGN1cnJlbnQgdXNlclxuICAgICAgICBpZiAoZXZlbnQudXNlci5pZCA9PT0gY2FsbC5jdXJyZW50VXNlcklkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBjYWxsO1xuICAgICAgICBpZiAoZXZlbnQuY2FsbC5jcmVhdGVkX2J5LmlkID09PSBjYWxsLmN1cnJlbnRVc2VySWQgJiZcbiAgICAgICAgICAgIHN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkcpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwuam9pbigpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVzIGRlbGl2ZXJ5IG9mIGBjYWxsLnJlamVjdGVkYCBXZWJzb2NrZXQgZXZlbnQuXG4gKiBPbmNlIHRoZSBldmVudCBpcyByZWNlaXZlZCwgdGhlIGNhbGwgaXMgbGVmdC5cbiAqL1xuY29uc3Qgd2F0Y2hDYWxsUmVqZWN0ZWQgPSAoY2FsbCkgPT4ge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBvbkNhbGxSZWplY3RlZChldmVudCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGRpc2NhcmQgdGhlIGV2ZW50IGlmIGl0J3MgZnJvbSB0aGUgY3VycmVudCB1c2VyXG4gICAgICAgIGlmIChldmVudC51c2VyLmlkID09PSBjYWxsLmN1cnJlbnRVc2VySWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgY2FsbDogZXZlbnRDYWxsIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uOiBjYWxsU2Vzc2lvbiB9ID0gZXZlbnRDYWxsO1xuICAgICAgICBpZiAoIWNhbGxTZXNzaW9uKSB7XG4gICAgICAgICAgICBjYWxsLmxvZ2dlcignd2FybicsICdObyBjYWxsIHNlc3Npb24gcHJvdmlkZWQuIElnbm9yaW5nIGNhbGwucmVqZWN0ZWQgZXZlbnQuJywgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlamVjdGVkQnkgPSBjYWxsU2Vzc2lvbi5yZWplY3RlZF9ieTtcbiAgICAgICAgY29uc3QgeyBtZW1iZXJzLCBjYWxsaW5nU3RhdGUgfSA9IGNhbGwuc3RhdGU7XG4gICAgICAgIGlmIChjYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HKSB7XG4gICAgICAgICAgICBjYWxsLmxvZ2dlcignaW5mbycsICdDYWxsIGlzIG5vdCBpbiByaW5naW5nIG1vZGUgKGl0IGlzIGVpdGhlciBhY2NlcHRlZCBvciByZWplY3RlZCBhbHJlYWR5KS4gSWdub3JpbmcgY2FsbC5yZWplY3RlZCBldmVudC4nLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGwuaXNDcmVhdGVkQnlNZSkge1xuICAgICAgICAgICAgY29uc3QgZXZlcnlvbmVFbHNlUmVqZWN0ZWQgPSBtZW1iZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigobSkgPT4gbS51c2VyX2lkICE9PSBjYWxsLmN1cnJlbnRVc2VySWQpXG4gICAgICAgICAgICAgICAgLmV2ZXJ5KChtKSA9PiByZWplY3RlZEJ5W20udXNlcl9pZF0pO1xuICAgICAgICAgICAgaWYgKGV2ZXJ5b25lRWxzZVJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5sb2dnZXIoJ2luZm8nLCAnZXZlcnlvbmUgcmVqZWN0ZWQsIGxlYXZpbmcgdGhlIGNhbGwnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKHsgcmVhc29uOiAncmluZzogZXZlcnlvbmUgcmVqZWN0ZWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlamVjdGVkQnlbZXZlbnRDYWxsLmNyZWF0ZWRfYnkuaWRdKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5sb2dnZXIoJ2luZm8nLCAnY2FsbCBjcmVhdG9yIHJlamVjdGVkLCBsZWF2aW5nIGNhbGwnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKHsgcmVhc29uOiAncmluZzogY3JlYXRvciByZWplY3RlZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogRXZlbnQgaGFuZGxlciB0aGF0IHdhdGNoZXMgdGhlIGRlbGl2ZXJ5IG9mIGBjYWxsLmVuZGVkYCBXZWJzb2NrZXQgZXZlbnQuXG4gKi9cbmNvbnN0IHdhdGNoQ2FsbEVuZGVkID0gKGNhbGwpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsRW5kZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGluZ1N0YXRlIH0gPSBjYWxsLnN0YXRlO1xuICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUklOR0lORyB8fFxuICAgICAgICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEIHx8XG4gICAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lOSU5HKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKHsgcmVhc29uOiAnY2FsbC5lbmRlZCBldmVudCByZWNlaXZlZCcgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlcyBmb3IgYGNhbGxHcmFudHNVcGRhdGVkYCBldmVudHMuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjYWxsIHN0YXRlIHRvIHVwZGF0ZS5cbiAqL1xuY29uc3Qgd2F0Y2hDYWxsR3JhbnRzVXBkYXRlZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvbkNhbGxHcmFudHNVcGRhdGVkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudEdyYW50cyB9ID0gZXZlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50R3JhbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhblB1Ymxpc2hBdWRpbywgY2FuUHVibGlzaFZpZGVvLCBjYW5TY3JlZW5zaGFyZSB9ID0gY3VycmVudEdyYW50cztcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPXTogY2FuUHVibGlzaEF1ZGlvLFxuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dOiBjYW5QdWJsaXNoVmlkZW8sXG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkVdOiBjYW5TY3JlZW5zaGFyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2FwYWJpbGl0aWVzID0gc3RhdGUub3duQ2FwYWJpbGl0aWVzLmZpbHRlcigoY2FwYWJpbGl0eSkgPT4gdXBkYXRlW2NhcGFiaWxpdHldICE9PSBmYWxzZSk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh1cGRhdGUpLmZvckVhY2goKFtjYXBhYmlsaXR5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgIW5leHRDYXBhYmlsaXRpZXMuaW5jbHVkZXMoY2FwYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENhcGFiaWxpdGllcy5wdXNoKGNhcGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKG5leHRDYXBhYmlsaXRpZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IGxvZ2dlciQxID0gZ2V0TG9nZ2VyKFsnZXZlbnRzJ10pO1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYGNoYW5nZVB1Ymxpc2hRdWFsaXR5YCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hDaGFuZ2VQdWJsaXNoUXVhbGl0eSA9IChkaXNwYXRjaGVyLCBjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWRlb1NlbmRlcnMgfSA9IGU7XG4gICAgICAgIHZpZGVvU2VuZGVycy5mb3JFYWNoKCh2aWRlb1NlbmRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBsYXllcnMgfSA9IHZpZGVvU2VuZGVyO1xuICAgICAgICAgICAgY2FsbC51cGRhdGVQdWJsaXNoUXVhbGl0eShsYXllcnMuZmlsdGVyKChsKSA9PiBsLmFjdGl2ZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCB3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChkaXNwYXRjaGVyLCBzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcyB9ID0gZTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMucmVkdWNlKChwYXRjaGVzLCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBjb25uZWN0aW9uUXVhbGl0eSB9ID0gdXBkYXRlO1xuICAgICAgICAgICAgcGF0Y2hlc1tzZXNzaW9uSWRdID0ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25RdWFsaXR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgICAgICB9LCB7fSkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogVXBkYXRlcyB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY2FsbCBieSBwZWVraW5nIGF0IHRoZVxuICogaGVhbHRoIGNoZWNrIGV2ZW50cyB0aGF0IG91ciBTRlUgc2VuZHMuXG4gKi9cbmNvbnN0IHdhdGNoUGFydGljaXBhbnRDb3VudENoYW5nZWQgPSAoZGlzcGF0Y2hlciwgc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignaGVhbHRoQ2hlY2tSZXNwb25zZScsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFydGljaXBhbnRDb3VudCB9ID0gZTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50Q291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldFBhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudC50b3RhbCk7XG4gICAgICAgICAgICBzdGF0ZS5zZXRBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KHBhcnRpY2lwYW50Q291bnQuYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHdhdGNoTGl2ZUVuZGVkID0gKGRpc3BhdGNoZXIsIGNhbGwpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5lcnJvciAmJiBlLmVycm9yLmNvZGUgIT09IEVycm9yQ29kZS5MSVZFX0VOREVEKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNhbGwucGVybWlzc2lvbnNDb250ZXh0Lmhhc1Blcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5KT0lOX0JBQ0tTVEFHRSkpIHtcbiAgICAgICAgICAgIGNhbGwubGVhdmUoeyByZWFzb246ICdsaXZlIGVuZGVkJyB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEoJ2Vycm9yJywgJ0ZhaWxlZCB0byBsZWF2ZSBjYWxsIGFmdGVyIGxpdmUgZW5kZWQnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgYW5kIGxvZ3MgdGhlIGVycm9ycyByZXBvcnRlZCBieSB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gKi9cbmNvbnN0IHdhdGNoU2Z1RXJyb3JSZXBvcnRzID0gKGRpc3BhdGNoZXIpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBpZiAoIWUuZXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGU7XG4gICAgICAgIGxvZ2dlciQxKCdlcnJvcicsICdTRlUgcmVwb3J0ZWQgZXJyb3InLCB7XG4gICAgICAgICAgICBjb2RlOiBFcnJvckNvZGVbZXJyb3IuY29kZV0sXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc2hvdWxkUmV0cnk6IGVycm9yLnNob3VsZFJldHJ5LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgZm9yIGBwaW5zVXBkYXRlZGAgZXZlbnRzIGFuZCB1cGRhdGVzIHRoZSBwaW5uZWQgc3RhdGUgb2YgcGFydGljaXBhbnRzXG4gKiBpbiB0aGUgY2FsbC5cbiAqL1xuY29uc3Qgd2F0Y2hQaW5zVXBkYXRlZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvblBpbnNVcGRhdGVkKGUpIHtcbiAgICAgICAgY29uc3QgeyBwaW5zIH0gPSBlO1xuICAgICAgICBzdGF0ZS5zZXRTZXJ2ZXJTaWRlUGlucyhwaW5zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRoYXQgaGFuZGxlcyBzb2Z0IG11dGVzLlxuICpcbiAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsLlxuICovXG5jb25zdCBoYW5kbGVSZW1vdGVTb2Z0TXV0ZSA9IChjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGNhbGwub24oJ3RyYWNrVW5wdWJsaXNoZWQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYXVzZSwgdHlwZSwgc2Vzc2lvbklkIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgeyBsb2NhbFBhcnRpY2lwYW50IH0gPSBjYWxsLnN0YXRlO1xuICAgICAgICBpZiAoY2F1c2UgPT09IFRyYWNrVW5wdWJsaXNoUmVhc29uLk1PREVSQVRJT04gJiZcbiAgICAgICAgICAgIHNlc3Npb25JZCA9PT0gbG9jYWxQYXJ0aWNpcGFudD8uc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBjYWxsLmxvZ2dlcjtcbiAgICAgICAgICAgIGxvZ2dlcignaW5mbycsIGBMb2NhbCBwYXJ0aWNpcGFudCdzICR7VHJhY2tUeXBlW3R5cGVdfSB0cmFjayBpcyBtdXRlZCByZW1vdGVseWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIoJ3dhcm4nLCAnVW5zdXBwb3J0ZWQgdHJhY2sgdHlwZSB0byBzb2Z0IG11dGUnLCBUcmFja1R5cGVbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbC5wdWJsaXNoZXI/LmlzUHVibGlzaGluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLnN0b3BQdWJsaXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCAnRmFpbGVkIHRvIHN0b3AgcHVibGlzaGluZycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHBhcnRpY2lwYW50Sm9pbmVkYCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvblBhcnRpY2lwYW50Sm9pbmVkKGUpIHtcbiAgICAgICAgY29uc3QgeyBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICAgICAgaWYgKCFwYXJ0aWNpcGFudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gYHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnRgIGFjdHMgYXMgYSBzYWZlZ3VhcmQgYWdhaW5zdFxuICAgICAgICAvLyBwb3RlbnRpYWwgZHVwbGljYXRlIGV2ZW50cyBmcm9tIHRoZSBTRlUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFsdGhvdWdoIHRoZSBTRlUgc2hvdWxkIG5vdCBzZW5kIGR1cGxpY2F0ZSBldmVudHMsIHdlIGhhdmUgc2VlblxuICAgICAgICAvLyBzb21lIHJhY2UgY29uZGl0aW9ucyBpbiB0aGUgcGFzdCBkdXJpbmcgdGhlIGBqb2luLWZsb3dgIHdoZXJlXG4gICAgICAgIC8vIHRoZSBTRlUgd291bGQgc2VuZCBwYXJ0aWNpcGFudCBpbmZvIGFzIHBhcnQgb2YgdGhlIGBqb2luYFxuICAgICAgICAvLyByZXNwb25zZSBhbmQgdGhlbiBmb2xsb3cgdXAgd2l0aCBhIGBwYXJ0aWNpcGFudEpvaW5lZGAgZXZlbnQgZm9yXG4gICAgICAgIC8vIGFscmVhZHkgYW5ub3VuY2VkIHBhcnRpY2lwYW50cy5cbiAgICAgICAgc3RhdGUudXBkYXRlT3JBZGRQYXJ0aWNpcGFudChwYXJ0aWNpcGFudC5zZXNzaW9uSWQsIE9iamVjdC5hc3NpZ24ocGFydGljaXBhbnQsIHtcbiAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVUcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgcGFydGljaXBhbnRMZWZ0YCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudExlZnQgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25QYXJ0aWNpcGFudExlZnQoZSkge1xuICAgICAgICBjb25zdCB7IHBhcnRpY2lwYW50IH0gPSBlO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbHRlcigocCkgPT4gcC5zZXNzaW9uSWQgIT09IHBhcnRpY2lwYW50LnNlc3Npb25JZCkpO1xuICAgIH07XG59O1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHRyYWNrUHVibGlzaGVkYCBldmVudC5cbiAqIFRoZSBTRlUgd2lsbCBzZW5kIHRoaXMgZXZlbnQgd2hlbiBhIHBhcnRpY2lwYW50IHB1Ymxpc2hlcyBhIHRyYWNrLlxuICovXG5jb25zdCB3YXRjaFRyYWNrUHVibGlzaGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uVHJhY2tQdWJsaXNoZWQoZSkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNlc3Npb25JZCwgcGFydGljaXBhbnQgfSA9IGU7XG4gICAgICAgIC8vIEFuIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgY2FsbHMuXG4gICAgICAgIC8vIEFmdGVyIGEgY2VydGFpbiB0aHJlc2hvbGQsIHRoZSBTRlUgd291bGQgc3RvcCBlbWl0dGluZyBgcGFydGljaXBhbnRKb2luZWRgXG4gICAgICAgIC8vIGV2ZW50cywgYW5kIGluc3RlYWQsIGl0IHdvdWxkIG9ubHkgcHJvdmlkZSB0aGUgcGFydGljaXBhbnQncyBpbmZvcm1hdGlvblxuICAgICAgICAvLyBvbmNlIHRoZXkgc3RhcnQgcHVibGlzaGluZyBhIHRyYWNrLlxuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQoc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwKSA9PiAoe1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogWy4uLnAucHVibGlzaGVkVHJhY2tzLCB0eXBlXS5maWx0ZXIodW5pcXVlKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHRyYWNrVW5wdWJsaXNoZWRgIGV2ZW50LlxuICogVGhlIFNGVSB3aWxsIHNlbmQgdGhpcyBldmVudCB3aGVuIGEgcGFydGljaXBhbnQgdW5wdWJsaXNoZXMgYSB0cmFjay5cbiAqL1xuY29uc3Qgd2F0Y2hUcmFja1VucHVibGlzaGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uVHJhY2tVbnB1Ymxpc2hlZChlKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICAgICAgLy8gQW4gb3B0aW1pemF0aW9uIGZvciBsYXJnZSBjYWxscy4gU2VlIGB3YXRjaFRyYWNrUHVibGlzaGVkYC5cbiAgICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICBzdGF0ZS51cGRhdGVPckFkZFBhcnRpY2lwYW50KHNlc3Npb25JZCwgcGFydGljaXBhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCAocCkgPT4gKHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoZWRUcmFja3M6IHAucHVibGlzaGVkVHJhY2tzLmZpbHRlcigodCkgPT4gdCAhPT0gdHlwZSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IHVuaXF1ZSA9ICh2LCBpLCBhcnIpID0+IGFyci5pbmRleE9mKHYpID09PSBpO1xuXG4vKipcbiAqIFdhdGNoZXMgZm9yIGBkb21pbmFudFNwZWFrZXJDaGFuZ2VkYCBldmVudHMuXG4gKi9cbmNvbnN0IHdhdGNoRG9taW5hbnRTcGVha2VyQ2hhbmdlZCA9IChkaXNwYXRjaGVyLCBzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQgfSA9IGU7XG4gICAgICAgIGlmIChzZXNzaW9uSWQgPT09IHN0YXRlLmRvbWluYW50U3BlYWtlcj8uc2Vzc2lvbklkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgIC8vIG1hcmsgdGhlIG5ldyBkb21pbmFudCBzcGVha2VyXG4gICAgICAgICAgICBpZiAocGFydGljaXBhbnQuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgaXNEb21pbmFudFNwZWFrZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVubWFyayB0aGUgb2xkIGRvbWluYW50IHNwZWFrZXJcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5pc0RvbWluYW50U3BlYWtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICBpc0RvbWluYW50U3BlYWtlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudDsgLy8gbm8gY2hhbmdlXG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgZm9yIGBhdWRpb0xldmVsQ2hhbmdlZGAgZXZlbnRzLlxuICovXG5jb25zdCB3YXRjaEF1ZGlvTGV2ZWxDaGFuZ2VkID0gKGRpc3BhdGNoZXIsIHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2F1ZGlvTGV2ZWxDaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBhdWRpb0xldmVscyB9ID0gZTtcbiAgICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnRzKGF1ZGlvTGV2ZWxzLnJlZHVjZSgocGF0Y2hlcywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcGF0Y2hlc1tjdXJyZW50LnNlc3Npb25JZF0gPSB7XG4gICAgICAgICAgICAgICAgYXVkaW9MZXZlbDogY3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgICAgICBpc1NwZWFraW5nOiBjdXJyZW50LmlzU3BlYWtpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVycyBmb3IgYSBjYWxsIGR1cmluZyBpdHMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIGZvci5cbiAqIEBwYXJhbSBzdGF0ZSB0aGUgY2FsbCBzdGF0ZS5cbiAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyLlxuICovXG5jb25zdCByZWdpc3RlckV2ZW50SGFuZGxlcnMgPSAoY2FsbCwgc3RhdGUsIGRpc3BhdGNoZXIpID0+IHtcbiAgICBjb25zdCBldmVudEhhbmRsZXJzID0gW1xuICAgICAgICBjYWxsLm9uKCdjYWxsLmVuZGVkJywgd2F0Y2hDYWxsRW5kZWQoY2FsbCkpLFxuICAgICAgICB3YXRjaExpdmVFbmRlZChkaXNwYXRjaGVyLCBjYWxsKSxcbiAgICAgICAgd2F0Y2hTZnVFcnJvclJlcG9ydHMoZGlzcGF0Y2hlciksXG4gICAgICAgIHdhdGNoQ2hhbmdlUHVibGlzaFF1YWxpdHkoZGlzcGF0Y2hlciwgY2FsbCksXG4gICAgICAgIHdhdGNoQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgd2F0Y2hQYXJ0aWNpcGFudENvdW50Q2hhbmdlZChkaXNwYXRjaGVyLCBzdGF0ZSksXG4gICAgICAgIGNhbGwub24oJ3BhcnRpY2lwYW50Sm9pbmVkJywgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZChzdGF0ZSkpLFxuICAgICAgICBjYWxsLm9uKCdwYXJ0aWNpcGFudExlZnQnLCB3YXRjaFBhcnRpY2lwYW50TGVmdChzdGF0ZSkpLFxuICAgICAgICBjYWxsLm9uKCd0cmFja1B1Ymxpc2hlZCcsIHdhdGNoVHJhY2tQdWJsaXNoZWQoc3RhdGUpKSxcbiAgICAgICAgY2FsbC5vbigndHJhY2tVbnB1Ymxpc2hlZCcsIHdhdGNoVHJhY2tVbnB1Ymxpc2hlZChzdGF0ZSkpLFxuICAgICAgICB3YXRjaEF1ZGlvTGV2ZWxDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgd2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgY2FsbC5vbignY2FsbEdyYW50c1VwZGF0ZWQnLCB3YXRjaENhbGxHcmFudHNVcGRhdGVkKHN0YXRlKSksXG4gICAgICAgIGNhbGwub24oJ3BpbnNVcGRhdGVkJywgd2F0Y2hQaW5zVXBkYXRlZChzdGF0ZSkpLFxuICAgICAgICBoYW5kbGVSZW1vdGVTb2Z0TXV0ZShjYWxsKSxcbiAgICBdO1xuICAgIGlmIChjYWxsLnJpbmdpbmcpIHtcbiAgICAgICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBvbmx5IHJlbGV2YW50IHdoZW4gdGhlIGNhbGwgaXMgcmluZ2luZ1xuICAgICAgICBldmVudEhhbmRsZXJzLnB1c2gocmVnaXN0ZXJSaW5naW5nQ2FsbEV2ZW50SGFuZGxlcnMoY2FsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goKHVuc3Vic2NyaWJlKSA9PiB1bnN1YnNjcmliZSgpKTtcbiAgICB9O1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGV2ZW50IGhhbmRsZXJzIGZvciBhIGNhbGwgdGhhdCBpcyBvZiByaW5naW5nIHR5cGUuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgZm9yLlxuICovXG5jb25zdCByZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyA9IChjYWxsKSA9PiB7XG4gICAgY29uc3QgY29vcmRpbmF0b3JSaW5nRXZlbnRzID0ge1xuICAgICAgICAnY2FsbC5hY2NlcHRlZCc6IHdhdGNoQ2FsbEFjY2VwdGVkKGNhbGwpLFxuICAgICAgICAnY2FsbC5yZWplY3RlZCc6IHdhdGNoQ2FsbFJlamVjdGVkKGNhbGwpLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5rZXlzKGNvb3JkaW5hdG9yUmluZ0V2ZW50cykubWFwKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIGNhbGwub24oZXZlbnROYW1lLCBjb29yZGluYXRvclJpbmdFdmVudHNbZXZlbnROYW1lXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29sbGVjdHMgYWxsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBqb2luIGEgY2FsbCwgdGFsa3MgdG8gdGhlIGNvb3JkaW5hdG9yXG4gKiBhbmQgcmV0dXJucyB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGpvaW4gdGhlIGNhbGwuXG4gKlxuICogQHBhcmFtIGh0dHBDbGllbnQgdGhlIGh0dHAgY2xpZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBjYWxsLlxuICogQHBhcmFtIGlkIHRoZSBpZCBvZiB0aGUgY2FsbC5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgY2FsbC5cbiAqL1xuY29uc3Qgam9pbiA9IGFzeW5jIChodHRwQ2xpZW50LCB0eXBlLCBpZCwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgY2FsbCwgY3JlZGVudGlhbHMsIG1lbWJlcnMsIG93bl9jYXBhYmlsaXRpZXMsIHN0YXRzX29wdGlvbnMgfSA9IGF3YWl0IGRvSm9pbihodHRwQ2xpZW50LCB0eXBlLCBpZCwgZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZzogdG9SdGNDb25maWd1cmF0aW9uKGNyZWRlbnRpYWxzLmljZV9zZXJ2ZXJzKSxcbiAgICAgICAgc2Z1U2VydmVyOiBjcmVkZW50aWFscy5zZXJ2ZXIsXG4gICAgICAgIHRva2VuOiBjcmVkZW50aWFscy50b2tlbixcbiAgICAgICAgbWV0YWRhdGE6IGNhbGwsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICAgIG93bkNhcGFiaWxpdGllczogb3duX2NhcGFiaWxpdGllcyxcbiAgICAgICAgc3RhdHNPcHRpb25zOiBzdGF0c19vcHRpb25zLFxuICAgIH07XG59O1xuY29uc3QgZG9Kb2luID0gYXN5bmMgKGh0dHBDbGllbnQsIHR5cGUsIGlkLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldExvY2F0aW9uSGludCgpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgIH07XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChgL2NhbGwvJHt0eXBlfS8ke2lkfS9qb2luYCwgcmVxdWVzdCk7XG59O1xuY29uc3QgdG9SdGNDb25maWd1cmF0aW9uID0gKGNvbmZpZykgPT4ge1xuICAgIGlmICghY29uZmlnIHx8IGNvbmZpZy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcnRjQ29uZmlnID0ge1xuICAgICAgICBpY2VTZXJ2ZXJzOiBjb25maWcubWFwKChpY2UpID0+ICh7XG4gICAgICAgICAgICB1cmxzOiBpY2UudXJscyxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBpY2UudXNlcm5hbWUsXG4gICAgICAgICAgICBjcmVkZW50aWFsOiBpY2UucGFzc3dvcmQsXG4gICAgICAgIH0pKSxcbiAgICB9O1xuICAgIHJldHVybiBydGNDb25maWc7XG59O1xuXG4vKipcbiAqIEZsYXR0ZW4gdGhlIHN0YXRzIHJlcG9ydCBpbnRvIGFuIGFycmF5IG9mIHN0YXRzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIGZsYXR0ZW4uXG4gKi9cbmNvbnN0IGZsYXR0ZW4kMSA9IChyZXBvcnQpID0+IHtcbiAgICBjb25zdCBzdGF0cyA9IFtdO1xuICAgIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHN0YXRzLnB1c2gocyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YXRzUmVwb3J0ZXIgaW5zdGFuY2UgdGhhdCBjb2xsZWN0cyBtZXRyaWNzIGFib3V0IHRoZSBvbmdvaW5nIGNhbGwgYW5kIHJlcG9ydHMgdGhlbSB0byB0aGUgc3RhdGUgc3RvcmVcbiAqL1xuY29uc3QgY3JlYXRlU3RhdHNSZXBvcnRlciA9ICh7IHN1YnNjcmliZXIsIHB1Ymxpc2hlciwgc3RhdGUsIHBvbGxpbmdJbnRlcnZhbEluTXMgPSAyMDAwLCB9KSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc3RhdHMnXSk7XG4gICAgY29uc3QgZ2V0UmF3U3RhdHNGb3JUcmFjayA9IGFzeW5jIChraW5kLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICBpZiAoa2luZCA9PT0gJ3N1YnNjcmliZXInICYmIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChraW5kID09PSAncHVibGlzaGVyJyAmJiBwdWJsaXNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwdWJsaXNoZXIuZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyKCd3YXJuJywgYENhbid0IHJldHJpZXZlIFJUQyBzdGF0cyBmb3IgJHtraW5kfWApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0U3RhdHNGb3JTdHJlYW0gPSBhc3luYyAoa2luZCwgbWVkaWFTdHJlYW0pID0+IHtcbiAgICAgICAgY29uc3QgcGMgPSBraW5kID09PSAnc3Vic2NyaWJlcicgPyBzdWJzY3JpYmVyIDogcHVibGlzaGVyO1xuICAgICAgICBjb25zdCBzdGF0c0ZvclN0cmVhbSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0cmFjayBvZiBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgcGMuZ2V0U3RhdHModHJhY2spO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB0cmFuc2Zvcm0ocmVwb3J0LCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRyYWNrS2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0c0ZvclN0cmVhbS5wdXNoKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHNGb3JTdHJlYW07XG4gICAgfTtcbiAgICBjb25zdCBzdGFydFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICBzZXNzaW9uSWRzVG9UcmFjay5hZGQoc2Vzc2lvbklkKTtcbiAgICAgICAgdm9pZCBydW4oKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0b3BSZXBvcnRpbmdTdGF0c0ZvciA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgc2Vzc2lvbklkc1RvVHJhY2suZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgICAgIHZvaWQgcnVuKCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXNzaW9uSWRzVG9UcmFjayA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBzdGF0cyByZXBvcnRpbmcgbG9vcC5cbiAgICAgKi9cbiAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50U3RhdHMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkcyA9IG5ldyBTZXQoc2Vzc2lvbklkc1RvVHJhY2spO1xuICAgICAgICBpZiAoc2Vzc2lvbklkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGFydGljaXBhbnQgb2Ygc3RhdGUucGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWRzLmhhcyhwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gcGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgID8gJ3B1Ymxpc2hlcidcbiAgICAgICAgICAgICAgICAgICAgOiAnc3Vic2NyaWJlcic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwYXJ0aWNpcGFudC52aWRlb1N0cmVhbT8uZ2V0VmlkZW9UcmFja3MoKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4ocGFydGljaXBhbnQuYXVkaW9TdHJlYW0/LmdldEF1ZGlvVHJhY2tzKCkgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRTdGF0c1twYXJ0aWNpcGFudC5zZXNzaW9uSWRdID0gYXdhaXQgZ2V0U3RhdHNGb3JTdHJlYW0oa2luZCwgbWVyZ2VkU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFN0cmVhbS5yZW1vdmVUcmFjayh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCBgRmFpbGVkIHRvIGNvbGxlY3Qgc3RhdHMgZm9yICR7a2luZH0gaWYgJHtwYXJ0aWNpcGFudC51c2VySWR9YCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzdWJzY3JpYmVyU3RhdHMsIHB1Ymxpc2hlclN0YXRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdHMoKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXBvcnQpID0+IHRyYW5zZm9ybShyZXBvcnQsIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnc3Vic2NyaWJlcicsXG4gICAgICAgICAgICAgICAgdHJhY2tLaW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oYWdncmVnYXRlKSxcbiAgICAgICAgICAgIHB1Ymxpc2hlclxuICAgICAgICAgICAgICAgIC5nZXRTdGF0cygpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcG9ydCkgPT4gdHJhbnNmb3JtKHJlcG9ydCwge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwdWJsaXNoZXInLFxuICAgICAgICAgICAgICAgIHRyYWNrS2luZDogJ3ZpZGVvJyxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC50aGVuKGFnZ3JlZ2F0ZSksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBbc3Vic2NyaWJlclJhd1N0YXRzLCBwdWJsaXNoZXJSYXdTdGF0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBnZXRSYXdTdGF0c0ZvclRyYWNrKCdzdWJzY3JpYmVyJyksXG4gICAgICAgICAgICBnZXRSYXdTdGF0c0ZvclRyYWNrKCdwdWJsaXNoZXInKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHN0YXRlLnNldENhbGxTdGF0c1JlcG9ydCh7XG4gICAgICAgICAgICBkYXRhY2VudGVyOiBwdWJsaXNoZXIuc2Z1Q2xpZW50LmVkZ2VOYW1lLFxuICAgICAgICAgICAgcHVibGlzaGVyU3RhdHMsXG4gICAgICAgICAgICBzdWJzY3JpYmVyU3RhdHMsXG4gICAgICAgICAgICBzdWJzY3JpYmVyUmF3U3RhdHMsXG4gICAgICAgICAgICBwdWJsaXNoZXJSYXdTdGF0cyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50czogcGFydGljaXBhbnRTdGF0cyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxJbk1zID4gMCkge1xuICAgICAgICBjb25zdCBsb29wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgcnVuKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIoJ2RlYnVnJywgJ0ZhaWxlZCB0byBjb2xsZWN0IHN0YXRzJywgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQobG9vcCwgcG9sbGluZ0ludGVydmFsSW5Ncyk7XG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgbG9vcCgpO1xuICAgIH1cbiAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0UmF3U3RhdHNGb3JUcmFjayxcbiAgICAgICAgZ2V0U3RhdHNGb3JTdHJlYW0sXG4gICAgICAgIHN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IsXG4gICAgICAgIHN0b3BSZXBvcnRpbmdTdGF0c0ZvcixcbiAgICAgICAgc3RvcCxcbiAgICB9O1xufTtcbi8qKlxuICogVHJhbnNmb3JtcyByYXcgUlRDIHN0YXRzIGludG8gYSBzbGltbWVyIGFuZCB1bmlmb3JtIGFjcm9zcyBicm93c2VycyBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSBvcHRzIHRoZSB0cmFuc2Zvcm0gb3B0aW9ucy5cbiAqL1xuY29uc3QgdHJhbnNmb3JtID0gKHJlcG9ydCwgb3B0cykgPT4ge1xuICAgIGNvbnN0IHsgdHJhY2tLaW5kLCBraW5kIH0gPSBvcHRzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGtpbmQgPT09ICdzdWJzY3JpYmVyJyA/ICdpbmJvdW5kLXJ0cCcgOiAnb3V0Ym91bmQtcnRwJztcbiAgICBjb25zdCBzdGF0cyA9IGZsYXR0ZW4kMShyZXBvcnQpO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBzdGF0c1xuICAgICAgICAuZmlsdGVyKChzdGF0KSA9PiBzdGF0LnR5cGUgPT09IGRpcmVjdGlvbiAmJlxuICAgICAgICBzdGF0LmtpbmQgPT09IHRyYWNrS2luZClcbiAgICAgICAgLm1hcCgoc3RhdCkgPT4ge1xuICAgICAgICBjb25zdCBydGNTdHJlYW1TdGF0cyA9IHN0YXQ7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gc3RhdHMuZmluZCgocykgPT4gcy50eXBlID09PSAnY29kZWMnICYmIHMuaWQgPT09IHJ0Y1N0cmVhbVN0YXRzLmNvZGVjSWQpOyAvLyBGSVhNRSBPTDogaW5jb3JyZWN0IHR5cGUhXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN0YXRzLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgcy5pZCA9PT0gcnRjU3RyZWFtU3RhdHMudHJhbnNwb3J0SWQpO1xuICAgICAgICBsZXQgcm91bmRUcmlwVGltZTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuZHRsc1N0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpciA9IHN0YXRzLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJlxuICAgICAgICAgICAgICAgIHMuaWQgPT09IHRyYW5zcG9ydC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCk7XG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lID0gY2FuZGlkYXRlUGFpcj8uY3VycmVudFJvdW5kVHJpcFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzU2VudDogcnRjU3RyZWFtU3RhdHMuYnl0ZXNTZW50LFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogcnRjU3RyZWFtU3RhdHMuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYz8ubWltZVR5cGUsXG4gICAgICAgICAgICBjdXJyZW50Um91bmRUcmlwVGltZTogcm91bmRUcmlwVGltZSxcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiBydGNTdHJlYW1TdGF0cy5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lc1BlclNlY29uZCxcbiAgICAgICAgICAgIGppdHRlcjogcnRjU3RyZWFtU3RhdHMuaml0dGVyLFxuICAgICAgICAgICAga2luZDogcnRjU3RyZWFtU3RhdHMua2luZCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGF2YWlsYWJsZSBpbiBDaHJvbWUgb25seSwgVFMgZG9lc24ndCByZWNvZ25pemUgdGhpc1xuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb246IHJ0Y1N0cmVhbVN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcmlkOiBydGNTdHJlYW1TdGF0cy5yaWQsXG4gICAgICAgICAgICBzc3JjOiBydGNTdHJlYW1TdGF0cy5zc3JjLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhd1N0YXRzOiByZXBvcnQsXG4gICAgICAgIHN0cmVhbXMsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xufTtcbi8qKlxuICogQWdncmVnYXRlcyBnZW5lcmljIHN0YXRzLlxuICpcbiAqIEBwYXJhbSBzdGF0cyB0aGUgc3RhdHMgdG8gYWdncmVnYXRlLlxuICovXG5jb25zdCBhZ2dyZWdhdGUgPSAoc3RhdHMpID0+IHtcbiAgICBjb25zdCBhZ2dyZWdhdGVkU3RhdHMgPSB7XG4gICAgICAgIHJhd1JlcG9ydDogc3RhdHMsXG4gICAgICAgIHRvdGFsQnl0ZXNTZW50OiAwLFxuICAgICAgICB0b3RhbEJ5dGVzUmVjZWl2ZWQ6IDAsXG4gICAgICAgIGF2ZXJhZ2VKaXR0ZXJJbk1zOiAwLFxuICAgICAgICBhdmVyYWdlUm91bmRUcmlwVGltZUluTXM6IDAsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uczogJ25vbmUnLFxuICAgICAgICBoaWdoZXN0RnJhbWVXaWR0aDogMCxcbiAgICAgICAgaGlnaGVzdEZyYW1lSGVpZ2h0OiAwLFxuICAgICAgICBoaWdoZXN0RnJhbWVzUGVyU2Vjb25kOiAwLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfTtcbiAgICBsZXQgbWF4QXJlYSA9IC0xO1xuICAgIGNvbnN0IGFyZWEgPSAodywgaCkgPT4gdyAqIGg7XG4gICAgY29uc3QgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBzdGF0cy5zdHJlYW1zO1xuICAgIGNvbnN0IHJlcG9ydCA9IHN0cmVhbXMucmVkdWNlKChhY2MsIHN0cmVhbSkgPT4ge1xuICAgICAgICBhY2MudG90YWxCeXRlc1NlbnQgKz0gc3RyZWFtLmJ5dGVzU2VudCB8fCAwO1xuICAgICAgICBhY2MudG90YWxCeXRlc1JlY2VpdmVkICs9IHN0cmVhbS5ieXRlc1JlY2VpdmVkIHx8IDA7XG4gICAgICAgIGFjYy5hdmVyYWdlSml0dGVySW5NcyArPSBzdHJlYW0uaml0dGVyIHx8IDA7XG4gICAgICAgIGFjYy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgKz0gc3RyZWFtLmN1cnJlbnRSb3VuZFRyaXBUaW1lIHx8IDA7XG4gICAgICAgIC8vIG5haXZlIGNhbGN1bGF0aW9uIG9mIHRoZSBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtQXJlYSA9IGFyZWEoc3RyZWFtLmZyYW1lV2lkdGggfHwgMCwgc3RyZWFtLmZyYW1lSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoc3RyZWFtQXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgICAgIGFjYy5oaWdoZXN0RnJhbWVXaWR0aCA9IHN0cmVhbS5mcmFtZVdpZHRoIHx8IDA7XG4gICAgICAgICAgICBhY2MuaGlnaGVzdEZyYW1lSGVpZ2h0ID0gc3RyZWFtLmZyYW1lSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBhY2MuaGlnaGVzdEZyYW1lc1BlclNlY29uZCA9IHN0cmVhbS5mcmFtZXNQZXJTZWNvbmQgfHwgMDtcbiAgICAgICAgICAgIG1heEFyZWEgPSBzdHJlYW1BcmVhO1xuICAgICAgICB9XG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucy5hZGQoc3RyZWFtLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uIHx8ICcnKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBhZ2dyZWdhdGVkU3RhdHMpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVwb3J0LmF2ZXJhZ2VKaXR0ZXJJbk1zID0gTWF0aC5yb3VuZCgocmVwb3J0LmF2ZXJhZ2VKaXR0ZXJJbk1zIC8gc3RyZWFtcy5sZW5ndGgpICogMTAwMCk7XG4gICAgICAgIHJlcG9ydC5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgPSBNYXRoLnJvdW5kKChyZXBvcnQuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zIC8gc3RyZWFtcy5sZW5ndGgpICogMTAwMCk7XG4gICAgfVxuICAgIGNvbnN0IHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uID0gW1xuICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdjcHUnKSAmJiAnY3B1JyxcbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zLmhhcygnYmFuZHdpZHRoJykgJiYgJ2JhbmR3aWR0aCcsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucy5oYXMoJ290aGVyJykgJiYgJ290aGVyJyxcbiAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgaWYgKHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uKSB7XG4gICAgICAgIHJlcG9ydC5xdWFsaXR5TGltaXRhdGlvblJlYXNvbnMgPSBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cbmNsYXNzIFNmdVN0YXRzUmVwb3J0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNmdUNsaWVudCwgeyBvcHRpb25zLCBjbGllbnREZXRhaWxzLCBzdWJzY3JpYmVyLCBwdWJsaXNoZXIgfSkge1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ1NmdVN0YXRzUmVwb3J0ZXInXSk7XG4gICAgICAgIHRoaXMucnVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N1YnNjcmliZXJTdGF0cywgcHVibGlzaGVyU3RhdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5nZXRTdGF0cygpLnRoZW4oZmxhdHRlbiQxKS50aGVuKEpTT04uc3RyaW5naWZ5KSxcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5nZXRTdGF0cygpLnRoZW4oZmxhdHRlbiQxKS50aGVuKEpTT04uc3RyaW5naWZ5KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuc2VuZFN0YXRzKHtcbiAgICAgICAgICAgICAgICBzZGs6IHRoaXMuc2RrTmFtZSxcbiAgICAgICAgICAgICAgICBzZGtWZXJzaW9uOiB0aGlzLnNka1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgd2VicnRjVmVyc2lvbjogdGhpcy53ZWJSVENWZXJzaW9uLFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJTdGF0cyxcbiAgICAgICAgICAgICAgICBwdWJsaXNoZXJTdGF0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXBvcnRpbmdfaW50ZXJ2YWxfbXMgPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW4oKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0ZhaWxlZCB0byByZXBvcnQgc3RhdHMnLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnJlcG9ydGluZ19pbnRlcnZhbF9tcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgICAgICBjb25zdCB3ZWJSVENJbmZvID0gZ2V0V2ViUlRDSW5mbygpO1xuICAgICAgICBjb25zdCB7IHNkaywgYnJvd3NlciB9ID0gY2xpZW50RGV0YWlscztcbiAgICAgICAgdGhpcy5zZGtOYW1lID1cbiAgICAgICAgICAgIHNkayAmJiBzZGsudHlwZSA9PT0gU2RrVHlwZS5SRUFDVFxuICAgICAgICAgICAgICAgID8gJ3N0cmVhbS1yZWFjdCdcbiAgICAgICAgICAgICAgICA6IHNkayAmJiBzZGsudHlwZSA9PT0gU2RrVHlwZS5SRUFDVF9OQVRJVkVcbiAgICAgICAgICAgICAgICAgICAgPyAnc3RyZWFtLXJlYWN0LW5hdGl2ZSdcbiAgICAgICAgICAgICAgICAgICAgOiAnc3RyZWFtLWpzJztcbiAgICAgICAgdGhpcy5zZGtWZXJzaW9uID0gc2RrXG4gICAgICAgICAgICA/IGAke3Nkay5tYWpvcn0uJHtzZGsubWlub3J9LiR7c2RrLnBhdGNofWBcbiAgICAgICAgICAgIDogJzAuMC4wLWRldmVsb3BtZW50JztcbiAgICAgICAgLy8gVGhlIFdlYlJUQyB2ZXJzaW9uIGlmIHBhc3NlZCBmcm9tIHRoZSBTREssIGl0IGlzIHRha2VuIGVsc2UgdGhlIGJyb3dzZXIgaW5mbyBpcyBzZW50LlxuICAgICAgICB0aGlzLndlYlJUQ1ZlcnNpb24gPVxuICAgICAgICAgICAgd2ViUlRDSW5mbz8udmVyc2lvbiB8fFxuICAgICAgICAgICAgICAgIGAke2Jyb3dzZXI/Lm5hbWUgfHwgJyd9LSR7YnJvd3Nlcj8udmVyc2lvbiB8fCAnJ31gIHx8XG4gICAgICAgICAgICAgICAgJ04vQSc7XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1RIUkVTSE9MRCA9IDAuMzU7XG5jbGFzcyBWaWV3cG9ydFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIC8vIGluIFJlYWN0IGNoaWxkcmVuIHJlbmRlciBiZWZvcmUgdmlld3BvcnQgaXMgc2V0LCBhZGRcbiAgICAgICAgLy8gdGhlbSB0byB0aGUgcXVldWUgYW5kIG9ic2VydmUgdGhlbSBvbmNlIHRoZSBvYnNlcnZlciBpcyByZWFkeVxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVldWVTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc2V0IHNjcm9sbGFibGUgdmlld3BvcnQgYXMgcm9vdCBmb3IgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLCByZXR1cm5zXG4gICAgICAgICAqIGNsZWFudXAgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB1cG9uIGRpc3Bvc2luZyBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZXdwb3J0RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyBVbm9ic2VydmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQgPSAodmlld3BvcnRFbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuZ2V0KGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI/LihlbnRyeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcm9vdDogdmlld3BvcnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiBvcHRpb25zPy50aHJlc2hvbGQgPz8gREVGQVVMVF9USFJFU0hPTEQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlU2V0LnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU2V0LmZvckVhY2goKFtxdWV1ZUVsZW1lbnQsIHF1ZXVlSGFuZGxlcl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZWxlbWVudCB3aGljaCByZXF1ZXN0ZWQgb2JzZXJ2YXRpb24gaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBvZiBhIHZpZXdwb3J0IGVsZW1lbnQsIHNraXAgaWYgaXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQuY29udGFpbnMocXVldWVFbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHF1ZXVlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuc2V0KHF1ZXVlRWxlbWVudCwgcXVldWVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU2V0LmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBzZXQgZWxlbWVudCB0byBvYnNlcnZlIGFuZCBoYW5kbGVyIHRvIGJlIHRyaWdnZXJlZCB3aGVuZXZlciBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgICAgKiBkZXRlY3RzIGEgcG9zc2libGUgY2hhbmdlIGluIGVsZW1lbnQncyB2aXNpYmlsaXR5IHdpdGhpbiBzcGVjaWZpZWQgdmlld3BvcnQsIHJldHVybnNcbiAgICAgICAgICogY2xlYW51cCBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHVwb24gZGlzcG9zaW5nIG9mIHRoZSBET00gZWxlbWVudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAgICAgKiBAcmV0dXJucyBVbm9ic2VydmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2JzZXJ2ZSA9IChlbGVtZW50LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZUl0ZW0gPSBbZWxlbWVudCwgaGFuZGxlcl07XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXI/LnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU2V0LmRlbGV0ZShxdWV1ZUl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTZXQuYWRkKHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5yb290LmNvbnRhaW5zKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50SGFuZGxlck1hcC5zZXQoZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgU2FmYXJpLlxuICovXG5jb25zdCBpc1NhZmFyaSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnKTtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgRmlyZWZveC5cbiAqL1xuY29uc3QgaXNGaXJlZm94ID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50Py5pbmNsdWRlcygnRmlyZWZveCcpO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBHb29nbGUgQ2hyb21lLlxuICovXG5jb25zdCBpc0Nocm9tZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudD8uaW5jbHVkZXMoJ0Nocm9tZScpO1xufTtcblxudmFyIGJyb3dzZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBpc0Nocm9tZTogaXNDaHJvbWUsXG4gICAgaXNGaXJlZm94OiBpc0ZpcmVmb3gsXG4gICAgaXNTYWZhcmk6IGlzU2FmYXJpXG59KTtcblxuY29uc3QgREVGQVVMVF9WSUVXUE9SVF9WSVNJQklMSVRZX1NUQVRFID0ge1xuICAgIHZpZGVvVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICAgIHNjcmVlblNoYXJlVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxufTtcbi8qKlxuICogQSBtYW5hZ2VyIGNsYXNzIHRoYXQgaGFuZGxlcyBkeW5hc2NhbGUgcmVsYXRlZCB0YXNrcyBsaWtlOlxuICpcbiAqIC0gYmluZGluZyB2aWRlbyBlbGVtZW50cyB0byBzZXNzaW9uIGlkc1xuICogLSBiaW5kaW5nIGF1ZGlvIGVsZW1lbnRzIHRvIHNlc3Npb24gaWRzXG4gKiAtIHRyYWNraW5nIGVsZW1lbnQgdmlzaWJpbGl0eVxuICogLSB1cGRhdGluZyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHZpZXdwb3J0IHZpc2liaWxpdHlcbiAqIC0gdXBkYXRpbmcgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAqIC0gdXBkYXRpbmcgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiBwdWJsaXNoZWQgdHJhY2tzXG4gKi9cbmNsYXNzIER5bmFzY2FsZU1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRHluYXNjYWxlTWFuYWdlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIG1hbmFnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWxsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlld3BvcnQgdHJhY2tlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3BvcnRUcmFja2VyID0gbmV3IFZpZXdwb3J0VHJhY2tlcigpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ0R5bmFzY2FsZU1hbmFnZXInXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGJlZ2luIHRyYWNraW5nIHRoZSBnaXZlbiBlbGVtZW50IGZvciB2aXNpYmlsaXR5IGNoYW5nZXMgd2l0aGluIHRoZVxuICAgICAgICAgKiBjb25maWd1cmVkIHZpZXdwb3J0IGVsZW1lbnQgKGBjYWxsLnNldFZpZXdwb3J0YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHRyYWNrLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHZpZGVvLlxuICAgICAgICAgKiBAcmV0dXJucyBVbnRyYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja0VsZW1lbnRWaXNpYmlsaXR5ID0gKGVsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gdGhpcy52aWV3cG9ydFRyYWNrZXIub2JzZXJ2ZShlbGVtZW50LCAoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCAocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWaXNpYmlsaXR5U3RhdGUgPSBwYXJ0aWNpcGFudC52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9WSUVXUE9SVF9WSVNJQklMSVRZX1NUQVRFO1xuICAgICAgICAgICAgICAgICAgICAvLyBvYnNlcnZlciB0cmlnZ2VycyB3aGVuIHRoZSBlbGVtZW50IGlzIFwibW92ZWRcIiB0byBiZSBhIGZ1bGxzY3JlZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGl0IFZJU0lCTEUgaWYgdGhhdCBoYXBwZW5zIHRvIHByZXZlbnQgZnVsbHNjcmVlbiB3aXRoIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ID09PSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFZpc2liaWxpdHlTdGF0ZS5WSVNJQkxFXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJldmlvdXNWaXNpYmlsaXR5U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RyYWNrVHlwZV06IGlzVmlzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHZpc2liaWxpdHkgc3RhdGUgdG8gVU5LTk9XTiB1cG9uIGNsZWFudXBcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBsYXlvdXRzIHRoYXQgYXJlIG5vdCBhY3RpdmVseSBvYnNlcnZlZFxuICAgICAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBmdW5jdGlvbiBub3JtYWxseSAocnVudGltZSBsYXlvdXQgc3dpdGNoaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSA9IHBhcnRpY2lwYW50LnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/XG4gICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJldmlvdXNWaXNpYmlsaXR5U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RyYWNrVHlwZV06IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIHRyYWNrIGJvdW5kIHZpZGVvIGVsZW1lbnRzIGZvciB2aXNpYmlsaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgdmlld3BvcnQgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFja2VyLnNldFZpZXdwb3J0KGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPHZpZGVvPiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgcGxheVxuICAgICAgICAgKiB0aGUgY29ycmVjdCB2aWRlbyBzdHJlYW0gZm9yIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmRlciB0aGUgaG9vZCwgaXQgd291bGQgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAgICAgICAgICogYW5kIHVwZGF0ZSB0aGUgc3Vic2NyaXB0aW9uIGFjY29yZGluZ2x5IGluIG9yZGVyIHRvIG9wdGltaXplIHRoZSBiYW5kd2lkdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgXCJ2aWV3cG9ydFwiIGlzIGNvbmZpZ3VyZWQsIHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgICAgICAgKiB0cmFja2VkIGZvciB2aXNpYmlsaXR5IGFuZCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudCB0aGUgdmlkZW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kVmlkZW9FbGVtZW50ID0gKHZpZGVvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kUGFydGljaXBhbnQgPSB0aGlzLmNhbGwuc3RhdGUuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmICghYm91bmRQYXJ0aWNpcGFudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyA9IChkZWJvdW5jZVR5cGUsIGRpbWVuc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb24gJiYgKGRpbWVuc2lvbi53aWR0aCA9PT0gMCB8fCBkaW1lbnNpb24uaGVpZ2h0ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgMHgwIGRpbWVuc2lvbnMuIHRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB2aXNpYmxlIChlLmcuLCBoYXMgZGlzcGxheTogbm9uZSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHRyZWF0IHRoaXMgYXMgXCJ1bnN1YnNjcmlwdGlvblwiIGFzIHdlIGRvbid0IHdhbnQgdG8ga2VlcFxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdW1pbmcgYmFuZHdpZHRoIGZvciBhIHZpZGVvIHRoYXQgaXMgbm90IHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYElnbm9yaW5nIDB4MCBkaW1lbnNpb25gLCBib3VuZFBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwudXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWwodHJhY2tUeXBlLCB7IFtzZXNzaW9uSWRdOiB7IGRpbWVuc2lvbiB9IH0sIGRlYm91bmNlVHlwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQkID0gdGhpcy5jYWxsLnN0YXRlLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmluZCgocGFydGljaXBhbnQpID0+IHBhcnRpY2lwYW50LnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSksIHRha2VXaGlsZSgocGFydGljaXBhbnQpID0+ICEhcGFydGljaXBhbnQpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2luY2UgdGhlIHZpZGVvIGVsZW1lbnRzIGFyZSBub3cgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBET00gKFJlYWN0IFNESykgdXBvblxuICAgICAgICAgICAgICogdmlzaWJpbGl0eSBjaGFuZ2UsIHRoaXMgc3Vic2NyaXB0aW9uIGlzIG5vdCBpbiB1c2UgYW4gc3RheXMgaGVyZSBvbmx5IGZvciB0aGVcbiAgICAgICAgICAgICAqIHBsYWluIEpTIGludGVncmF0aW9ucyB3aGVyZSBpbnRlZ3JhdG9ycyBtaWdodCBjaG9vc2Ugbm90IHRvIHJlbW92ZSB0aGUgdmlkZW9cbiAgICAgICAgICAgICAqIGVsZW1lbnRzIGZyb20gdGhlIERPTS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8ga2VlcCBjb3B5IGZvciByZXNpemUgb2JzZXJ2ZXIgaGFuZGxlclxuICAgICAgICAgICAgbGV0IHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGVTdWJzY3JpcHRpb24gPSBib3VuZFBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogcGFydGljaXBhbnQkXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG1hcCQxKChwKSA9PiBwLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy5bdHJhY2tUeXBlXSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKG5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGluaXRpYWwgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/PyBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5NRURJVU0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLk1FRElVTSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdmlkZW9FbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbGFzdERpbWVuc2lvbnM7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IGJvdW5kUGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGltZW5zaW9ucyA9IGAke3ZpZGVvRWxlbWVudC5jbGllbnRXaWR0aH0sJHt2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0fWA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaW5pdGlhbCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFzdERpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REaW1lbnNpb25zID0gY3VycmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3REaW1lbnNpb25zID09PSBjdXJyZW50RGltZW5zaW9ucyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuU0xPVywge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdmlkZW9FbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3REaW1lbnNpb25zID0gY3VycmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZSh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgLy8gZWxlbWVudCByZW5kZXJzIGFuZCBnZXRzIGJvdW5kIC0gdHJhY2sgc3Vic2NyaXB0aW9uIGdldHNcbiAgICAgICAgICAgIC8vIHRyaWdnZXJlZCBmaXJzdCBvdGhlciBvbmVzIGdldCBza2lwcGVkIG9uIGluaXRpYWwgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgY29uc3QgcHVibGlzaGVkVHJhY2tzU3Vic2NyaXB0aW9uID0gYm91bmRQYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHBhcnRpY2lwYW50JFxuICAgICAgICAgICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgncHVibGlzaGVkVHJhY2tzJyksIG1hcCQxKChwKSA9PiBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyh0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJ1xuICAgICAgICAgICAgICAgICAgICA/IFRyYWNrVHlwZS5WSURFT1xuICAgICAgICAgICAgICAgICAgICA6IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoaXNQdWJsaXNoaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1B1Ymxpc2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBqdXN0IHN0YXJ0ZWQgdG8gcHVibGlzaCBhIHRyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuRkFTVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2aWRlb0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQganVzdCBzdG9wcGVkIHB1Ymxpc2hpbmcgYSB0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLkZBU1QsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZXhwbGljaXRseSBtYXJraW5nIHRoZSBlbGVtZW50IGFzIG11dGVkIHdpbGwgYWxsb3cgYXV0b3BsYXkgdG8gd29ya1xuICAgICAgICAgICAgLy8gd2l0aG91dCBwcmlvciB1c2VyIGludGVyYWN0aW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvTWVkaWEvQXV0b3BsYXlfZ3VpZGVcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1TdWJzY3JpcHRpb24gPSBwYXJ0aWNpcGFudCRcbiAgICAgICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCh0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJyA/ICd2aWRlb1N0cmVhbScgOiAnc2NyZWVuU2hhcmVTdHJlYW0nKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdHJhY2tUeXBlID09PSAndmlkZW9UcmFjaycgPyBwLnZpZGVvU3RyZWFtIDogcC5zY3JlZW5TaGFyZVN0cmVhbTtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCA9PT0gc291cmNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHNvdXJjZSA/PyBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpIHx8IGlzRmlyZWZveCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHNvdXJjZSA/PyBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYEZhaWxlZCB0byBwbGF5IHN0cmVhbWAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhZGQgZXh0cmEgZGVsYXkgdW50aWwgd2UgYXR0ZW1wdCB0byBmb3JjZS1wbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQncyBtZWRpYSBzdHJlYW0gaW4gRmlyZWZveCBhbmQgU2FmYXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhleSBzZWVtIHRvIGhhdmUgc29tZSB0aW1pbmcgaXNzdWVzXG4gICAgICAgICAgICAgICAgICAgIH0sIDI1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLkZBU1QsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGVTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcHVibGlzaGVkVHJhY2tzU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPGF1ZGlvPiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBhdWRpbyBlbGVtZW50IHdpbGxcbiAgICAgICAgICogcGxheSB0aGUgY29ycmVjdCBhdWRpbyBzdHJlYW0gZm9yIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXVkaW9FbGVtZW50IHRoZSBhdWRpbyBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgYXVkaW8uXG4gICAgICAgICAqIEByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHdpbGwgdW5iaW5kIHRoZSBhdWRpbyBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kQXVkaW9FbGVtZW50ID0gKGF1ZGlvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5jYWxsLnN0YXRlLmZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkKHNlc3Npb25JZCk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50IHx8IHBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCQgPSB0aGlzLmNhbGwuc3RhdGUucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maW5kKChwKSA9PiBwLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSksIHRha2VXaGlsZSgocCkgPT4gISFwKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVNZWRpYVN0cmVhbVN1YnNjcmlwdGlvbiA9IHBhcnRpY2lwYW50JFxuICAgICAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlQXVkaW9UcmFjaydcbiAgICAgICAgICAgICAgICA/ICdzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtJ1xuICAgICAgICAgICAgICAgIDogJ2F1ZGlvU3RyZWFtJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlQXVkaW9UcmFjaydcbiAgICAgICAgICAgICAgICAgICAgPyBwLnNjcmVlblNoYXJlQXVkaW9TdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgOiBwLmF1ZGlvU3RyZWFtO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID09PSBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnNyY09iamVjdCA9IHNvdXJjZSA/PyBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYEZhaWxlZCB0byBwbGF5IHN0cmVhbWAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdWRpbyBvdXRwdXQgZGV2aWNlIHNoYWxsIGJlIHNldCBhZnRlciB0aGUgYXVkaW8gZWxlbWVudCBpcyBwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIGJyb3dzZXIgd2lsbCBub3QgcGljayBpdCB1cCwgYW5kIHdpbGwgYWx3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGF5IGF1ZGlvIHRocm91Z2ggdGhlIHN5c3RlbSdzIGRlZmF1bHQgZGV2aWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkRGV2aWNlIH0gPSB0aGlzLmNhbGwuc3BlYWtlci5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZERldmljZSAmJiAnc2V0U2lua0lkJyBpbiBhdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0VsZW1lbnQuc2V0U2lua0lkKHNlbGVjdGVkRGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzaW5rSWRTdWJzY3JpcHRpb24gPSAhKCdzZXRTaW5rSWQnIGluIGF1ZGlvRWxlbWVudClcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHRoaXMuY2FsbC5zcGVha2VyLnN0YXRlLnNlbGVjdGVkRGV2aWNlJC5zdWJzY3JpYmUoKGRldmljZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZvbHVtZVN1YnNjcmlwdGlvbiA9IGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5zcGVha2VyLnN0YXRlLnZvbHVtZSQsXG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQkLnBpcGUoZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ2F1ZGlvVm9sdW1lJykpLFxuICAgICAgICAgICAgXSkuc3Vic2NyaWJlKChbdm9sdW1lLCBwXSkgPT4ge1xuICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudC52b2x1bWUgPSBwLmF1ZGlvVm9sdW1lID8/IHZvbHVtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXVkaW9FbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2lua0lkU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHZvbHVtZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU1lZGlhU3RyZWFtU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdG9yZXMgdGhlIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudCB1c2VyIGFuZCBleHBvc2VzXG4gKiBhIGZldyBoZWxwZXIgbWV0aG9kcyB3aGljaCBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggcGVybWlzc2lvbnMuXG4gKlxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCBjbGFzcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGhcbiAqIGEge0BsaW5rIENhbGx9IGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQZXJtaXNzaW9uc0NvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb25zIHRoZSBwZXJtaXNzaW9ucyB0byBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBlcm1pc3Npb25zID0gKHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25zID0gcGVybWlzc2lvbnMgfHwgW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzZXR0aW5ncyBmb3IgdGhlIGJvdW5kIGNhbGwuXG4gICAgICAgICAqIEBwYXJhbSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDYWxsU2V0dGluZ3MgPSAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyBhIHNwZWNpZmljIHBlcm1pc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIHRoZSBwZXJtaXNzaW9uIHRvIGNoZWNrIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUGVybWlzc2lvbiA9IChwZXJtaXNzaW9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCB1c2VyIGNhbiByZXF1ZXN0IGEgc3BlY2lmaWMgcGVybWlzc2lvblxuICAgICAgICAgKiB3aXRoaW4gdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIHRoZSBwZXJtaXNzaW9uIHRvIGNoZWNrIGZvci5cbiAgICAgICAgICogQHBhcmFtIHNldHRpbmdzIHRoZSBjYWxsIHNldHRpbmdzIHRvIGNoZWNrIGFnYWluc3QgKG9wdGlvbmFsKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuUmVxdWVzdCA9IChwZXJtaXNzaW9uLCBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyBhdWRpbywgdmlkZW8sIHNjcmVlbnNoYXJpbmcgfSA9IHNldHRpbmdzO1xuICAgICAgICAgICAgc3dpdGNoIChwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfQVVESU86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdWRpby5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgICAgICAgICAgIGNhc2UgT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uYWNjZXNzX3JlcXVlc3RfZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY3JlZW5zaGFyaW5nLmFjY2Vzc19yZXF1ZXN0X2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2FsbCB0eXBlLlxuICovXG5jbGFzcyBDYWxsVHlwZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBDYWxsVHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBjYWxsIHR5cGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjYWxsIHR5cGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucyA9IHtcbiAgICAgICAgc29ydFBhcnRpY2lwYW50c0J5OiBkZWZhdWx0U29ydFByZXNldCxcbiAgICB9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJlZ2lzdHJ5IG9mIHtAbGluayBDYWxsVHlwZX1zLlxuICogWW91IGNhbiByZWdpc3RlciBhbmQgdW5yZWdpc3RlciBjYWxsIHR5cGVzLlxuICovXG5jbGFzcyBDYWxsVHlwZXNSZWdpc3RyeSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBDYWxsVHlwZXNSZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsVHlwZXMgdGhlIGluaXRpYWwgY2FsbCB0eXBlcyB0byByZWdpc3Rlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWxsVHlwZXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIG5ldyBjYWxsIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsVHlwZSB0aGUgY2FsbCB0eXBlIHRvIHJlZ2lzdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IChjYWxsVHlwZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHlwZXNbY2FsbFR5cGUubmFtZV0gPSBjYWxsVHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXJzIGEgY2FsbCB0eXBlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgY2FsbCB0eXBlIHRvIHVucmVnaXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbFR5cGVzW25hbWVdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIGNhbGwgdHlwZSBieSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgY2FsbCB0eXBlIHRvIGdldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0ID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsVHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKG5ldyBDYWxsVHlwZShuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsVHlwZXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FsbFR5cGVzID0gY2FsbFR5cGVzLnJlZHVjZSgoYWNjLCBjYWxsVHlwZSkgPT4ge1xuICAgICAgICAgICAgYWNjW2NhbGxUeXBlLm5hbWVdID0gY2FsbFR5cGU7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjYWxsIHR5cGVzIHJlZ2lzdHJ5LlxuICogWW91IGNhbiB1c2UgdGhpcyBpbnN0YW5jZSB0byBkeW5hbWljYWxseSByZWdpc3RlciBhbmQgdW5yZWdpc3RlciBjYWxsIHR5cGVzLlxuICovXG5jb25zdCBDYWxsVHlwZXMgPSBuZXcgQ2FsbFR5cGVzUmVnaXN0cnkoW1xuICAgIG5ldyBDYWxsVHlwZSgnZGVmYXVsdCcsIHtcbiAgICAgICAgc29ydFBhcnRpY2lwYW50c0J5OiBkZWZhdWx0U29ydFByZXNldCxcbiAgICB9KSxcbiAgICBuZXcgQ2FsbFR5cGUoJ2RldmVsb3BtZW50Jywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGRlZmF1bHRTb3J0UHJlc2V0LFxuICAgIH0pLFxuICAgIG5ldyBDYWxsVHlwZSgnbGl2ZXN0cmVhbScsIHtcbiAgICAgICAgc29ydFBhcnRpY2lwYW50c0J5OiBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0LFxuICAgIH0pLFxuICAgIG5ldyBDYWxsVHlwZSgnYXVkaW9fcm9vbScsIHtcbiAgICAgICAgc29ydFBhcnRpY2lwYW50c0J5OiBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0LFxuICAgIH0pLFxuXSk7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZXNcbiAqIHRoYXQgbWVldCB0aGUgZ2l2ZW4gY29uc3RyYWludHMuXG4gKlxuICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBkZXZpY2VzLlxuICogQHBhcmFtIGtpbmQgdGhlIGtpbmQgb2YgZGV2aWNlcyB0byBlbnVtZXJhdGUuXG4gKi9cbmNvbnN0IGdldERldmljZXMgPSAoY29uc3RyYWludHMsIGtpbmQpID0+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgY29uc3QgZW51bWVyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgcmVwb3J0IGVtcHR5IGRldmljZSBsYWJlbHMgKEZpcmVmb3gpLlxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHJlcXVlc3QgcGVybWlzc2lvbnMgKHZpYSBnZXRVc2VyTWVkaWEpXG4gICAgICAgICAgICAvLyB0byBiZSBhYmxlIHRvIGdldCB0aGUgZGV2aWNlIGxhYmVsc1xuICAgICAgICAgICAgY29uc3QgbmVlZHNHZXRVc2VyTWVkaWEgPSBkZXZpY2VzLnNvbWUoKGRldmljZSkgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQgJiYgZGV2aWNlLmxhYmVsID09PSAnJyk7XG4gICAgICAgICAgICBpZiAobmVlZHNHZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWFTdHJlYW07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYVN0cmVhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VPZk1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlcztcbiAgICAgICAgfTtcbiAgICAgICAgZW51bWVyYXRlKClcbiAgICAgICAgICAgIC50aGVuKChkZXZpY2VzKSA9PiB7XG4gICAgICAgICAgICAvLyBub3RpZnkgc3Vic2NyaWJlcnMgYW5kIGNvbXBsZXRlXG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZGV2aWNlcyk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydkZXZpY2VzJ10pO1xuICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gZW51bWVyYXRlIGRldmljZXMnLCBlcnJvcik7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBbVGVsbHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gb3V0cHV0IGNoYW5nZSBvbiAnYXVkaW8nIGVsZW1lbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQpLlxuICpcbiAqICAqL1xuY29uc3QgY2hlY2tJZkF1ZGlvT3V0cHV0Q2hhbmdlU3VwcG9ydGVkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBjb25zdHJhaW50cyB1c2VkIHRvIHJlcXVlc3QgYXVkaW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgYXVkaW9EZXZpY2VDb25zdHJhaW50cyA9IHtcbiAgICBhdWRpbzoge1xuICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gICAgICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gICAgfSxcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIHVzZWQgdG8gcmVxdWVzdCB2aWRlbyBkZXZpY2VzLlxuICovXG5jb25zdCB2aWRlb0RldmljZUNvbnN0cmFpbnRzID0ge1xuICAgIHZpZGVvOiB7XG4gICAgICAgIHdpZHRoOiAxMjgwLFxuICAgICAgICBoZWlnaHQ6IDcyMCxcbiAgICB9LFxufTtcbi8qKlxuICogQ3JlYXRlcyBhIG1lbW9pemVkIG9ic2VydmFibGUgaW5zdGFuY2VcbiAqIHRoYXQgd2lsbCBiZSBjcmVhdGVkIG9ubHkgb25jZSBhbmQgc2hhcmVkIGJldHdlZW4gYWxsIGNhbGxlcnMuXG4gKlxuICogQHBhcmFtIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBPYnNlcnZhYmxlLlxuICovXG5jb25zdCBtZW1vaXplZE9ic2VydmFibGUgPSAoY3JlYXRlKSA9PiB7XG4gICAgbGV0IG1lbW9pemVkO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghbWVtb2l6ZWQpXG4gICAgICAgICAgICBtZW1vaXplZCA9IGNyZWF0ZSgpO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcbn07XG5jb25zdCBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gICAgLy8gQXVkaW8gYW5kIHZpZGVvIGRldmljZXMgYXJlIHJlcXVlc3RlZCBpbiB0d28gc2VwYXJhdGUgcmVxdWVzdHMuXG4gICAgLy8gVGhhdCB3YXksIHVzZXJzIHdpbGwgYmUgcHJlc2VudGVkIHdpdGggdHdvIHNlcGFyYXRlIHByb21wdHNcbiAgICAvLyAtPiB0aGV5IGNhbiBnaXZlIGFjY2VzcyB0byBqdXN0IGNhbWVyYSwgb3IganVzdCBtaWNyb3Bob25lXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgIC8vICdhZGRFdmVudExpc3RlbmVyJyBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IE5hdGl2ZVxuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgbm90aWZ5ID0gKCkgPT4gc3Vic2NyaWJlci5uZXh0KCk7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgbm90aWZ5KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgbm90aWZ5KTtcbiAgICAgICAgfTtcbiAgICB9KS5waXBlKGRlYm91bmNlVGltZSg1MDApLCBjb25jYXRNYXAoKCkgPT4gZnJvbShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKSkpLCBzaGFyZVJlcGxheSgxKSk7XG59KTtcbmNvbnN0IGdldEF1ZGlvRGV2aWNlc09ic2VydmVyID0gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2UoZ2V0RGV2aWNlcyhhdWRpb0RldmljZUNvbnN0cmFpbnRzLCAnYXVkaW9pbnB1dCcpLCBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlcigpKS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcbn0pO1xuY29uc3QgZ2V0QXVkaW9PdXRwdXREZXZpY2VzT2JzZXJ2ZXIgPSBtZW1vaXplZE9ic2VydmFibGUoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZShnZXREZXZpY2VzKGF1ZGlvRGV2aWNlQ29uc3RyYWludHMsICdhdWRpb291dHB1dCcpLCBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlcigpKS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcbn0pO1xuY29uc3QgZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIgPSBtZW1vaXplZE9ic2VydmFibGUoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZShnZXREZXZpY2VzKHZpZGVvRGV2aWNlQ29uc3RyYWludHMsICd2aWRlb2lucHV0JyksIGdldERldmljZUNoYW5nZU9ic2VydmVyKCkpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xufSk7XG4vKipcbiAqIFByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgYXVkaW8gZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZCkgYW5kIGxpc3RzIHRoZSBhdmFpbGFibGUgJ2F1ZGlvaW5wdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC5cbiAqL1xuY29uc3QgZ2V0QXVkaW9EZXZpY2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBnZXRBdWRpb0RldmljZXNPYnNlcnZlcigpLnBpcGUobWFwJDEoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAnYXVkaW9pbnB1dCcpKSk7XG59O1xuLyoqXG4gKiBQcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIHZpZGVvIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpIGFuZCBsaXN0cyB0aGUgYXZhaWxhYmxlICd2aWRlb2lucHV0JyBkZXZpY2VzLCBpZiBkZXZpY2VzIGFyZSBhZGRlZC9yZW1vdmVkIHRoZSBsaXN0IGlzIHVwZGF0ZWQuXG4gKi9cbmNvbnN0IGdldFZpZGVvRGV2aWNlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIoKS5waXBlKG1hcCQxKCh2YWx1ZXMpID0+IHZhbHVlcy5maWx0ZXIoKGQpID0+IGQua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSkpO1xufTtcbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHVzZSBhdWRpbyBkZXZpY2VzIChpZiBub3QgYWxyZWFkeSBncmFudGVkKSBhbmQgbGlzdHMgdGhlIGF2YWlsYWJsZSAnYXVkaW9vdXRwdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC4gU2VsZWN0aW5nICdhdWRpb291dHB1dCcgZGV2aWNlIG9ubHkgbWFrZXMgc2Vuc2UgaWYgW3RoZSBicm93c2VyIGhhcyBzdXBwb3J0IGZvciBjaGFuZ2luZyBhdWRpbyBvdXRwdXQgb24gJ2F1ZGlvJyBlbGVtZW50c10oI2NoZWNraWZhdWRpb291dHB1dGNoYW5nZXN1cHBvcnRlZClcbiAqL1xuY29uc3QgZ2V0QXVkaW9PdXRwdXREZXZpY2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBnZXRBdWRpb091dHB1dERldmljZXNPYnNlcnZlcigpLnBpcGUobWFwJDEoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAnYXVkaW9vdXRwdXQnKSkpO1xufTtcbmNvbnN0IGdldFN0cmVhbSA9IGFzeW5jIChjb25zdHJhaW50cykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGdldExvZ2dlcihbJ2RldmljZXMnXSkoJ2Vycm9yJywgYEZhaWxlZCBnZXQgdXNlciBtZWRpYWAsIHtcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnRzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGF1ZGlvIG1lZGlhIHN0cmVhbSB0aGF0IGZ1bGZpbGxzIHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqIElmIG5vIGNvbnN0cmFpbnRzIGFyZSBwcm92aWRlZCwgaXQgdXNlcyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgb25lcy5cbiAqXG4gKiBAYW5ndWxhciBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgW2BEZXZpY2VNYW5hZ2VyU2VydmljZWBdKC4vRGV2aWNlTWFuYWdlclNlcnZpY2UubWQpIGZvciBhIGhpZ2hlciBsZXZlbCBBUEksIHVzZSB0aGlzIGxvdy1sZXZlbCBtZXRob2Qgb25seSBpZiB0aGUgYERldmljZU1hbmFnZXJTZXJ2aWNlYCBkb2Vzbid0IHN1aXQgeW91ciByZXF1aXJlbWVudHMuXG4gKiBAcGFyYW0gdHJhY2tDb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgc3RyZWFtLlxuICogQHJldHVybnMgdGhlIG5ldyBgTWVkaWFTdHJlYW1gIGZ1bGZpbGxpbmcgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICovXG5jb25zdCBnZXRBdWRpb1N0cmVhbSA9IGFzeW5jICh0cmFja0NvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAuLi5hdWRpb0RldmljZUNvbnN0cmFpbnRzLmF1ZGlvLFxuICAgICAgICAgICAgLi4udHJhY2tDb25zdHJhaW50cyxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRTdHJlYW0oY29uc3RyYWludHMpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIHZpZGVvIG1lZGlhIHN0cmVhbSB0aGF0IGZ1bGZpbGxzIHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqIElmIG5vIGNvbnN0cmFpbnRzIGFyZSBwcm92aWRlZCwgaXQgdXNlcyB0aGUgYnJvd3NlcidzIGRlZmF1bHQgb25lcy5cbiAqXG4gKiBAYW5ndWxhciBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgW2BEZXZpY2VNYW5hZ2VyU2VydmljZWBdKC4vRGV2aWNlTWFuYWdlclNlcnZpY2UubWQpIGZvciBhIGhpZ2hlciBsZXZlbCBBUEksIHVzZSB0aGlzIGxvdy1sZXZlbCBtZXRob2Qgb25seSBpZiB0aGUgYERldmljZU1hbmFnZXJTZXJ2aWNlYCBkb2Vzbid0IHN1aXQgeW91ciByZXF1aXJlbWVudHMuXG4gKiBAcGFyYW0gdHJhY2tDb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgc3RyZWFtLlxuICogQHJldHVybnMgYSBuZXcgYE1lZGlhU3RyZWFtYCBmdWxmaWxsaW5nIHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqL1xuY29uc3QgZ2V0VmlkZW9TdHJlYW0gPSBhc3luYyAodHJhY2tDb25zdHJhaW50cykgPT4ge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgLi4udmlkZW9EZXZpY2VDb25zdHJhaW50cy52aWRlbyxcbiAgICAgICAgICAgIC4uLnRyYWNrQ29uc3RyYWludHMsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0U3RyZWFtKGNvbnN0cmFpbnRzKTtcbn07XG4vKipcbiAqIFByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byBzaGFyZSBhIHNjcmVlbi5cbiAqIElmIHRoZSB1c2VyIGdyYW50cyB0aGUgcGVybWlzc2lvbiwgYSBzY3JlZW4gc2hhcmluZyBzdHJlYW0gaXMgcmV0dXJuZWQuIFRocm93cyBvdGhlcndpc2UuXG4gKlxuICogVGhlIGNhbGxlcnMgb2YgdGhpcyBBUEkgYXJlIHJlc3BvbnNpYmxlIHRvIGhhbmRsZSB0aGUgcG9zc2libGUgZXJyb3JzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBhbnkgYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFtgZ2V0RGlzcGxheU1lZGlhYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXREaXNwbGF5TWVkaWEpIEFQSS5cbiAqL1xuY29uc3QgZ2V0U2NyZWVuU2hhcmVTdHJlYW0gPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSh7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGlkZWFsOiAyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXV0b0dhaW5Db250cm9sOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBub2lzZVN1cHByZXNzaW9uOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gbm90IHByZXNlbnQgaW4gdHlwZXMgeWV0XG4gICAgICAgICAgICBzeXN0ZW1BdWRpbzogJ2luY2x1ZGUnLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGdldExvZ2dlcihbJ2RldmljZXMnXSkoJ2Vycm9yJywgJ0ZhaWxlZCB0byBnZXQgc2NyZWVuIHNoYXJlIHN0cmVhbScsIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG5jb25zdCBkZXZpY2VJZHMkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiBtZXJnZShmcm9tKG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKSwgZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIoKSkucGlwZShzaGFyZVJlcGxheSgxKSkpKClcbiAgICA6IHVuZGVmaW5lZDtcbi8qKlxuICogRGVhY3RpdmF0ZXMgTWVkaWFTdHJlYW0gKHN0b3BzIGFuZCByZW1vdmVzIHRyYWNrcykgdG8gYmUgbGF0ZXIgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqXG4gKiBAcGFyYW0gc3RyZWFtIE1lZGlhU3RyZWFtXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmNvbnN0IGRpc3Bvc2VPZk1lZGlhU3RyZWFtID0gKHN0cmVhbSkgPT4ge1xuICAgIGlmICghc3RyZWFtLmFjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgfSk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWxlYXNlKCkgaXMgcHJlc2VudCBpbiByZWFjdC1uYXRpdmUtd2VicnRjIGFuZCBtdXN0IGJlIGNhbGxlZCB0byBkaXNwb3NlIHRoZSBzdHJlYW1cbiAgICBpZiAodHlwZW9mIHN0cmVhbS5yZWxlYXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgc3RyZWFtLnJlbGVhc2UoKTtcbiAgICB9XG59O1xuXG5jbGFzcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgc3RhdGUsIHRyYWNrVHlwZSkge1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudHJhY2tUeXBlID0gdHJhY2tUeXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYgdHJ1ZSwgc3RvcHMgdGhlIG1lZGlhIHN0cmVhbSB3aGVuIGNhbGwgaXMgbGVmdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wT25MZWF2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2VzIHRoZSBtYW5hZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbYCR7VHJhY2tUeXBlW3RyYWNrVHlwZV0udG9Mb3dlckNhc2UoKX0gbWFuYWdlcmBdKTtcbiAgICAgICAgaWYgKGRldmljZUlkcyQgJiZcbiAgICAgICAgICAgICFpc1JlYWN0TmF0aXZlKCkgJiZcbiAgICAgICAgICAgICh0aGlzLnRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPIHx8IHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZE9yUmVwbGFjZWREZXZpY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBhdWRpby92aWRlbyBkZXZpY2VzXG4gICAgICpcbiAgICAgKiBOb3RlOiBJdCBwcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgd2lsbCBiZSB1cGRhdGVkIGlmIGEgZGV2aWNlIGlzIGNvbm5lY3RlZCBvciBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgc3RyZWFtLlxuICAgICAqL1xuICAgIGFzeW5jIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZW5hYmxlUHJvbWlzZSA9IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldFN0YXR1cygnZW5hYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgb3IgcGF1c2VzIHRoZSBzdHJlYW0gYmFzZWQgb24gc3RhdGUuZGlzYWJsZU1vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVN0b3A9ZmFsc2VdIHdoZW4gdHJ1ZSwgc3RvcHMgdGhlIHRyYWNrcyByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZS5kaXNhYmxlTW9kZVxuICAgICAqL1xuICAgIGFzeW5jIGRpc2FibGUoZm9yY2VTdG9wID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wcmV2U3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gICAgICAgIGlmICghZm9yY2VTdG9wICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzdG9wVHJhY2tzID0gZm9yY2VTdG9wIHx8IHRoaXMuc3RhdGUuZGlzYWJsZU1vZGUgPT09ICdzdG9wLXRyYWNrcyc7XG4gICAgICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB0aGlzLm11dGVTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTdGF0dXMoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHN0YXR1cyB3YXMgcHJldmlvdXNseSBlbmFibGVkLCBpdCB3aWxsIHJlLWVuYWJsZSB0aGUgZGV2aWNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucHJldlN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY3VycmVudCBkZXZpY2Ugc3RhdHVzIGlzIGRpc2FibGVkLCBpdCB3aWxsIGVuYWJsZSB0aGUgZGV2aWNlLFxuICAgICAqIGVsc2UgaXQgd2lsbCBkaXNhYmxlIGl0LlxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGZpbHRlciB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgZmlsdGVyIHdpbGwgZ2V0IHRoZSBleGlzdGluZyBzdHJlYW0sIGFuZCBpdCBzaG91bGQgcmV0dXJuXG4gICAgICogYSBuZXcgc3RyZWFtIHdpdGggdGhlIGFwcGxpZWQgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlciB0aGUgZmlsdGVyIHRvIHJlZ2lzdGVyLlxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHVucmVnaXN0ZXIgdGhlIGZpbHRlci5cbiAgICAgKi9cbiAgICBhc3luYyByZWdpc3RlckZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IHRoaXMuZmlsdGVycy5maWx0ZXIoKGYpID0+IGYgIT09IGZpbHRlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHNldCB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgICAgICB0aGlzLnN0YXRlLnNldERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgZGV2aWNlIGlkIHRvIHNlbGVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QoZGV2aWNlSWQpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvcmVhY3RuYXRpdmUvY29yZS9jYW1lcmEtYW5kLW1pY3JvcGhvbmUvI3NwZWFrZXItbWFuYWdlbWVudCBmb3IgcmVmZXJlbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXZpY2VJZCA9PT0gdGhpcy5zdGF0ZS5zZWxlY3RlZERldmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKGRldmljZUlkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICB9XG4gICAgYXN5bmMgYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tdXRlU3RyZWFtKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVubXV0ZVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFRyYWNrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubWVkaWFTdHJlYW0/LmdldFRyYWNrcygpID8/IFtdO1xuICAgIH1cbiAgICBhc3luYyBtdXRlU3RyZWFtKHN0b3BUcmFja3MgPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYCR7c3RvcFRyYWNrcyA/ICdTdG9wcGluZycgOiAnRGlzYWJsaW5nJ30gc3RyZWFtYCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGwuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0ZUxvY2FsU3RyZWFtKHN0b3BUcmFja3MpO1xuICAgICAgICBjb25zdCBhbGxFbmRlZCA9IHRoaXMuZ2V0VHJhY2tzKCkuZXZlcnkoKHQpID0+IHQucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJyk7XG4gICAgICAgIGlmIChhbGxFbmRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubWVkaWFTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlbGVhc2UoKSBpcyBwcmVzZW50IGluIHJlYWN0LW5hdGl2ZS13ZWJydGNcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbS5yZWxlYXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYWxsZWQgdG8gZGlzcG9zZSB0aGUgc3RyZWFtIGluIFJOXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbS5yZWxlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lZGlhU3RyZWFtKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbXV0ZVRyYWNrcygpIHtcbiAgICAgICAgdGhpcy5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmVuYWJsZWQpXG4gICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5tdXRlVHJhY2tzKCkge1xuICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYWNrLmVuYWJsZWQpXG4gICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wVHJhY2tzKCkge1xuICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnKVxuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11dGVMb2NhbFN0cmVhbShzdG9wVHJhY2tzKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wVHJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BUcmFja3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubXV0ZVRyYWNrcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVubXV0ZVN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1N0YXJ0aW5nIHN0cmVhbScpO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRUcmFja3MoKS5ldmVyeSgodCkgPT4gdC5yZWFkeVN0YXRlID09PSAnbGl2ZScpKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtO1xuICAgICAgICAgICAgdGhpcy51bm11dGVUcmFja3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb25zdHJhaW50cyA9IHRoaXMuc3RhdGUuZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdENvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hhaW5zIHR3byBtZWRpYSBzdHJlYW1zIHRvZ2V0aGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG91ciBjYXNlLCBmaWx0ZXJzIE1lZGlhU3RyZWFtcyBhcmUgZGVyaXZlZCBmcm9tIHRoZWlyIHBhcmVudCBNZWRpYVN0cmVhbS5cbiAgICAgICAgICAgICAqIEhvd2V2ZXIsIG9uY2UgYSBjaGlsZCBmaWx0ZXIncyB0cmFjayBpcyBzdG9wcGVkLFxuICAgICAgICAgICAgICogdGhlIHRyYWNrcyBvZiB0aGUgcGFyZW50IE1lZGlhU3RyZWFtIGFyZW4ndCBhdXRvbWF0aWNhbGx5IHN0b3BwZWQuXG4gICAgICAgICAgICAgKiBUaGlzIGxlYWRzIHRvIGEgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaW5kaWNhdG9yIGxpZ2h0IGlzIHN0aWxsIG9uXG4gICAgICAgICAgICAgKiBldmVuIHRob3VnaCB0aGUgdXNlciBzdG9wcGVkIHB1Ymxpc2hpbmcgdmlkZW8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiB3b3JrcyBhcm91bmQgdGhpcyBpc3N1ZSBieSBzdG9wcGluZyB0aGUgcGFyZW50IE1lZGlhU3RyZWFtJ3MgdHJhY2tzXG4gICAgICAgICAgICAgKiBhcyB3ZWxsIG9uY2UgdGhlIGNoaWxkIGZpbHRlcidzIHRyYWNrcyBhcmUgc3RvcHBlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJdCB3b3JrcyBieSBwYXRjaGluZyB0aGUgc3RvcCgpIG1ldGhvZCBvZiB0aGUgY2hpbGQgZmlsdGVyJ3MgdHJhY2tzIHRvIGFsc28gc3RvcFxuICAgICAgICAgICAgICogdGhlIHBhcmVudCBNZWRpYVN0cmVhbSdzIHRyYWNrcyBvZiB0aGUgc2FtZSB0eXBlLiBIZXJlIHdlIGFzc3VtZSB0aGF0XG4gICAgICAgICAgICAgKiB0aGUgcGFyZW50IE1lZGlhU3RyZWFtIGhhcyBvbmx5IG9uZSB0cmFjayBvZiBlYWNoIHR5cGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHBhcmVudFN0cmVhbSB0aGUgcGFyZW50IE1lZGlhU3RyZWFtLiBPbWl0IGZvciB0aGUgcm9vdCBzdHJlYW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGNoYWluV2l0aCA9IChwYXJlbnRTdHJlYW0pID0+IGFzeW5jIChmaWx0ZXJTdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFN0cmVhbSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclN0cmVhbTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE9MOiB0YWtlIGNhcmUgb2YgdHJhY2suZW5hYmxlZCBwcm9wZXJ0eSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gYXdhaXQgcGFyZW50U3RyZWFtO1xuICAgICAgICAgICAgICAgIGZpbHRlclN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSB0cmFjay5zdG9wO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKChwYXJlbnRUcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFjay5raW5kID09PSB0cmFjay5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuZ2V0VHJhY2tzKCkuZm9yRWFjaCgocGFyZW50VHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcGFyZW50IHN0cmVhbSBhYnJ1cHRseSBlbmRzLCB3ZSBwcm9wYWdhdGUgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBmaWx0ZXIgc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIHRoZSBjYW1lcmEvbWljcm9waG9uZSBwZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgcmV2b2tlZCBvciB3aGVuIHRoZSBkZXZpY2UgaXMgZGlzY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVQYXJlbnRUcmFja0VuZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYWNrLmtpbmQgIT09IHRyYWNrLmtpbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2VuZGVkJykpOyAvLyBwcm9wYWdhdGUgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVQYXJlbnRUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVQYXJlbnRUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclN0cmVhbTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB3ZSBwdWJsaXNoIHRoZSBsYXN0IE1lZGlhU3RyZWFtIG9mIHRoZSBjaGFpblxuICAgICAgICAgICAgc3RyZWFtID0gYXdhaXQgdGhpcy5maWx0ZXJzLnJlZHVjZSgocGFyZW50LCBmaWx0ZXIpID0+IHBhcmVudC50aGVuKGZpbHRlcikudGhlbihjaGFpbldpdGgocGFyZW50KSksIHRoaXMuZ2V0U3RyZWFtKGNvbnN0cmFpbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaFN0cmVhbShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1lZGlhU3RyZWFtICE9PSBzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVkaWFTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1lZGlhRGV2aWNlS2luZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8pIHtcbiAgICAgICAgICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgICAgICAgIHJldHVybiAndmlkZW9pbnB1dCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBoYW5kbGVEaXNjb25uZWN0ZWRPclJlcGxhY2VkRGV2aWNlcygpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goY3JlYXRlU3Vic2NyaXB0aW9uKGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgZGV2aWNlSWRzJC5waXBlKHBhaXJ3aXNlKCkpLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3RlZERldmljZSQsXG4gICAgICAgIF0pLCBhc3luYyAoW1twcmV2RGV2aWNlcywgY3VycmVudERldmljZXNdLCBkZXZpY2VJZF0pID0+IHtcbiAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzRGV2aWNlRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXNEZXZpY2VSZXBsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERldmljZSA9IHRoaXMuZmluZERldmljZUluTGlzdChjdXJyZW50RGV2aWNlcywgZGV2aWNlSWQpO1xuICAgICAgICAgICAgY29uc3QgcHJldkRldmljZSA9IHRoaXMuZmluZERldmljZUluTGlzdChwcmV2RGV2aWNlcywgZGV2aWNlSWQpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGV2aWNlICYmIHByZXZEZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBpc0RldmljZURpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RGV2aWNlICYmXG4gICAgICAgICAgICAgICAgcHJldkRldmljZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZGV2aWNlSWQgPT09IHByZXZEZXZpY2UuZGV2aWNlSWQgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLmdyb3VwSWQgIT09IHByZXZEZXZpY2UuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGlzRGV2aWNlUmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGV2aWNlRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RldmljZVJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmaW5kRGV2aWNlSW5MaXN0KGRldmljZXMsIGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VzLmZpbmQoKGQpID0+IGQuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIGQua2luZCA9PT0gdGhpcy5tZWRpYURldmljZUtpbmQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBuZXcgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNhYmxlTW9kZSB0aGUgZGlzYWJsZSBtb2RlIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgdGhlIHBlcm1pc3Npb24gbmFtZSB0byB1c2UgZm9yIHF1ZXJ5aW5nLlxuICAgICAqIGB1bmRlZmluZWRgIG1lYW5zIG5vIHBlcm1pc3Npb24gaXMgcmVxdWlyZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlzYWJsZU1vZGUgPSAnc3RvcC10cmFja3MnLCBwZXJtaXNzaW9uTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVNb2RlID0gZGlzYWJsZU1vZGU7XG4gICAgICAgIHRoaXMucGVybWlzc2lvbk5hbWUgPSBwZXJtaXNzaW9uTmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBtZWRpYSBzdHJlYW0sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBkZXZpY2UgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSQgPSB0aGlzLm1lZGlhU3RyZWFtU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZERldmljZSQgPSB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgZGV2aWNlIHN0YXR1c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMkID0gdGhpcy5zdGF0dXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzJCA9IHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9ic2VydmFibGUgdGhhdCB3aWxsIGVtaXQgYHRydWVgIGlmIGJyb3dzZXIvc3lzdGVtIHBlcm1pc3Npb25cbiAgICAgICAgICogaXMgZ3JhbnRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0Jyb3dzZXJQZXJtaXNzaW9uJCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3RpZnlHcmFudGVkID0gKCkgPT4gc3Vic2NyaWJlci5uZXh0KHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnNBUElBdmFpbGFibGUgPSAhIW5hdmlnYXRvcj8ucGVybWlzc2lvbnM/LnF1ZXJ5O1xuICAgICAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSB8fCAhdGhpcy5wZXJtaXNzaW9uTmFtZSB8fCAhcGVybWlzc2lvbnNBUElBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBnZXRMb2dnZXIoWydkZXZpY2VzJ10pKCd3YXJuJywgYFBlcm1pc3Npb25zIGNhbid0IGJlIHF1ZXJpZWQuIEFzc3VtaW5nIGdyYW50ZWQuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeUdyYW50ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwZXJtaXNzaW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBub3RpZnkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KFxuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHRoZSAnY2hhbmdlJyBldmVudCBkb2Vzbid0IHJlbGlhYmx5IGVtaXQgYW5kIGhlbmNlLFxuICAgICAgICAgICAgICAgIC8vIHBlcm1pc3Npb25TdGF0ZSBzdGF5cyBpbiAncHJvbXB0JyBzdGF0ZSBmb3JldmVyLlxuICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSwgdGhpcyBoYXBwZW5zIHdoZW4gYSB1c2VyIGdyYW50cyBvbmUtdGltZSBwZXJtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgY2hlY2tpbmcgaWYgYSBwZXJtaXNzaW9uIGlzIGdyYW50ZWQsIHdlIGNoZWNrIGlmIGl0IGlzbid0IGRlbmllZFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25TdGF0ZS5zdGF0ZSAhPT0gJ2RlbmllZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5hdmlnYXRvci5wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIC5xdWVyeSh7IG5hbWU6IHRoaXMucGVybWlzc2lvbk5hbWUgfSlcbiAgICAgICAgICAgICAgICAudGhlbigocGVybWlzc2lvblN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25TdGF0ZSA9IHBlcm1pc3Npb25TdGF0dXM7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG5vdGlmeSk7XG4gICAgICAgICAgICAgICAgbm90aWZ5KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcGVybWlzc2lvbiBkb2Vzbid0IGV4aXN0IG9yIGNhbid0IGJlIHF1ZXJpZWQgLT4gYXNzdW1lIGl0J3MgZ3JhbnRlZFxuICAgICAgICAgICAgICAgIC8vIGFuIGV4YW1wbGUgd291bGQgYmUgRmlyZWZveCxcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBuZWl0aGVyIGNhbWVyYSBtaWNyb3Bob25lIHBlcm1pc3Npb24gY2FuIGJlIHF1ZXJpZWRcbiAgICAgICAgICAgICAgICBub3RpZnlHcmFudGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlPy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkucGlwZShzaGFyZVJlcGxheSgxKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIG9ic2VydmFibGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXNcbiAgICAgICAgICogbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYnNlcnZhYmxlJCB0aGUgb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBTdWJqZWN0LlxuICAgICAgICAgKiBBbiBgdXBkYXRlYCBjYW4gZWl0aGVyIGJlIGEgbmV3IHZhbHVlIG9yIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXNcbiAgICAgICAgICogdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGUgdGhlIHVwZGF0ZSB0byBhcHBseSB0byB0aGUgc3ViamVjdC5cbiAgICAgICAgICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlID0gc2V0Q3VycmVudFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGV2aWNlIHN0YXR1c1xuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXR1cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZERldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbWVkaWEgc3RyZWFtLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgZGV2aWNlIGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBnZXQgbWVkaWFTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm1lZGlhU3RyZWFtJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhdHVzU3ViamVjdCwgc3RhdHVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHN0cmVhbSB0aGUgc3RyZWFtIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZWRpYVN0cmVhbVN1YmplY3QsIHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGV2aWNlKHRoaXMuZ2V0RGV2aWNlSWRGcm9tU3RyZWFtKHN0cmVhbSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgZGV2aWNlIGlkIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXREZXZpY2UoZGV2aWNlSWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QsIGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdENvbnN0cmFpbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kZWZhdWx0Q29uc3RyYWludHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmRlZmF1bHRDb25zdHJhaW50c1N1YmplY3QsIGNvbnN0cmFpbnRzKTtcbiAgICB9XG59XG5cbmNsYXNzIENhbWVyYU1hbmFnZXJTdGF0ZSBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RvcC10cmFja3MnLCBcbiAgICAgICAgLy8gYGNhbWVyYWAgaXMgbm90IGluIHRoZSBXM0Mgc3RhbmRhcmQgeWV0LFxuICAgICAgICAvLyBidXQgaXQncyBzdXBwb3J0ZWQgYnkgQ2hyb21lIGFuZCBTYWZhcmkuXG4gICAgICAgICdjYW1lcmEnKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiQgPSB0aGlzLmRpcmVjdGlvblN1YmplY3RcbiAgICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQgY2FtZXJhIGRpcmVjdGlvblxuICAgICAqIGZyb250IC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIHVzZXJcbiAgICAgKiBiYWNrIC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIGVudmlyb25tZW50XG4gICAgICovXG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZGlyZWN0aW9uJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5kaXJlY3Rpb25TdWJqZWN0LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgc3VwZXIuc2V0TWVkaWFTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgLy8gUk4gZ2V0U2V0dGluZ3MoKSBkb2Vzbid0IHJldHVybiBmYWNpbmdNb2RlLCBzbyB3ZSBkb24ndCB2ZXJpZnkgY2FtZXJhIGRpcmVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gaXNSZWFjdE5hdGl2ZSgpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRpcmVjdGlvblxuICAgICAgICAgICAgICAgIDogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0/LmdldFNldHRpbmdzKCkuZmFjaW5nTW9kZSA9PT0gJ2Vudmlyb25tZW50J1xuICAgICAgICAgICAgICAgICAgICA/ICdiYWNrJ1xuICAgICAgICAgICAgICAgICAgICA6ICdmcm9udCc7XG4gICAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERldmljZUlkRnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdPy5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FtZXJhTWFuYWdlciBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG5ldyBDYW1lcmFNYW5hZ2VyU3RhdGUoKSwgVHJhY2tUeXBlLlZJREVPKTtcbiAgICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgICAgICBoZWlnaHQ6IDcyMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBjYW1lcmEgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjYW1lcmEgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgLy8gUHJvdmlkaW5nIGJvdGggZGV2aWNlIGlkIGFuZCBkaXJlY3Rpb24gZG9lc24ndCB3b3JrLCBzbyB3ZSBkZXNlbGVjdCB0aGUgZGV2aWNlXG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKHVuZGVmaW5lZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsaXBzIHRoZSBjYW1lcmEgZGlyZWN0aW9uOiBpZiBpdCdzIGZyb250IGl0IHdpbGwgY2hhbmdlIHRvIGJhY2ssIGlmIGl0J3MgYmFjaywgaXQgd2lsbCBjaGFuZ2UgdG8gZnJvbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgY2FtZXJhIHdpdGggdGhlIGRlc2lyZWQgZGlyZWN0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBmbGlwKCkge1xuICAgICAgICBjb25zdCBuZXdEaXJlY3Rpb24gPSB0aGlzLnN0YXRlLmRpcmVjdGlvbiA9PT0gJ2Zyb250JyA/ICdiYWNrJyA6ICdmcm9udCc7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VsZWN0RGlyZWN0aW9uKG5ld0RpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdFRhcmdldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbi53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gY291bGRuJ3QgZW5hYmxlIGRldmljZSwgdGFyZ2V0IHJlc29sdXRpb24gd2lsbCBiZSBhcHBsaWVkIHRoZSBuZXh0IHRpbWUgdXNlciBhdHRlbXB0cyB0byBzdGFydCB0aGUgZGV2aWNlXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnY291bGQgbm90IGFwcGx5IHRhcmdldCByZXNvbHV0aW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc3RhdGVcbiAgICAgICAgICAgICAgICAubWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXVxuICAgICAgICAgICAgICAgID8uZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLndpZHRoIHx8XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICE9PSB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgJHt3aWR0aH14JHtoZWlnaHR9IHRhcmdldCByZXNvbHV0aW9uIGFwcGxpZWQgdG8gbWVkaWEgc3RyZWFtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJlZmVycmVkIGNvZGVjIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWwgaW50ZXJuYWwgdXNlIG9ubHksIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLlxuICAgICAqIEBwYXJhbSBjb2RlYyB0aGUgY29kZWMgdG8gdXNlIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgc2V0UHJlZmVycmVkQ29kZWMoY29kZWMpIHtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRDb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBnZXREZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gZ2V0VmlkZW9EZXZpY2VzKCk7XG4gICAgfVxuICAgIGdldFN0cmVhbShjb25zdHJhaW50cykge1xuICAgICAgICBjb25zdHJhaW50cy53aWR0aCA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgY29uc3RyYWludHMuaGVpZ2h0ID0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc2V0IGJvdGggZGV2aWNlIGlkIGFuZCBmYWNpbmcgbW9kZVxuICAgICAgICAvLyBEZXZpY2UgaWQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzLmRldmljZUlkICYmIHRoaXMuc3RhdGUuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy5mYWNpbmdNb2RlID1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpcmVjdGlvbiA9PT0gJ2Zyb250JyA/ICd1c2VyJyA6ICdlbnZpcm9ubWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFZpZGVvU3RyZWFtKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgcHVibGlzaFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5wdWJsaXNoVmlkZW9TdHJlYW0oc3RyZWFtLCB7XG4gICAgICAgICAgICBwcmVmZXJyZWRDb2RlYzogdGhpcy5wcmVmZXJyZWRDb2RlYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuVklERU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbn1cblxuY2xhc3MgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZGlzYWJsZS10cmFja3MnLCBcbiAgICAgICAgLy8gYG1pY3JvcGhvbmVgIGlzIG5vdCBpbiB0aGUgVzNDIHN0YW5kYXJkIHlldCxcbiAgICAgICAgLy8gYnV0IGl0J3Mgc3VwcG9ydGVkIGJ5IENocm9tZSBhbmQgU2FmYXJpLlxuICAgICAgICAnbWljcm9waG9uZScpO1xuICAgICAgICB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5zcGVha2luZ1doaWxlTXV0ZWQkID0gdGhpcy5zcGVha2luZ1doaWxlTXV0ZWRTdWJqZWN0XG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIHVzZXIncyBtaWNyb3Bob25lIGlzIG11dGVkIGJ1dCB0aGV5J2FyZSBzcGVha2luZy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBSZWFjdCBOYXRpdmUgU0RLLlxuICAgICAqL1xuICAgIGdldCBzcGVha2luZ1doaWxlTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNwZWFraW5nV2hpbGVNdXRlZCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXRTcGVha2luZ1doaWxlTXV0ZWQoaXNTcGVha2luZykge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3QsIGlzU3BlYWtpbmcpO1xuICAgIH1cbiAgICBnZXREZXZpY2VJZEZyb21TdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXT8uZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9XG59XG5cbmNvbnN0IERFVEVDVElPTl9GUkVRVUVOQ1lfSU5fTVMgPSA1MDA7XG5jb25zdCBBVURJT19MRVZFTF9USFJFU0hPTEQkMSA9IDE1MDtcbmNvbnN0IEZGVF9TSVpFID0gMTI4O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvdW5kIGRldGVjdG9yLlxuICpcbiAqIEBwYXJhbSBhdWRpb1N0cmVhbSB0aGUgYXVkaW8gc3RyZWFtIHRvIG9ic2VydmUuIERlcGVuZGluZyBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgdGhpcyBzdHJlYW0gbWlnaHQgYmUgZGVzdHJveWVkIHdoZW4gdGhlIHNvdW5kIGRldGVjdG9yIGlzIHN0b3BwZWQuXG4gKiBAcGFyYW0gb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHNvdW5kIHN0YXRlIGNoYW5nZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyBjdXN0b20gb3B0aW9ucyBmb3IgdGhlIHNvdW5kIGRldGVjdG9yLlxuICogQHJldHVybnMgYSBjbGVhbi11cCBmdW5jdGlvbiB3aGljaCBvbmNlIGludm9rZWQgc3RvcHMgdGhlIHNvdW5kIGRldGVjdG9yLlxuICovXG5jb25zdCBjcmVhdGVTb3VuZERldGVjdG9yID0gKGF1ZGlvU3RyZWFtLCBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgZGV0ZWN0aW9uRnJlcXVlbmN5SW5NcyA9IERFVEVDVElPTl9GUkVRVUVOQ1lfSU5fTVMsIGF1ZGlvTGV2ZWxUaHJlc2hvbGQgPSBBVURJT19MRVZFTF9USFJFU0hPTEQkMSwgZmZ0U2l6ZSA9IEZGVF9TSVpFLCBkZXN0cm95U3RyZWFtT25TdG9wID0gdHJ1ZSwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemU7XG4gICAgY29uc3QgbWljcm9waG9uZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShhdWRpb1N0cmVhbSk7XG4gICAgbWljcm9waG9uZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgICAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhKTtcbiAgICAgICAgY29uc3QgaXNTb3VuZERldGVjdGVkID0gZGF0YS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPj0gYXVkaW9MZXZlbFRocmVzaG9sZCk7XG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VkRGF0YVZhbHVlID0gZGF0YS5yZWR1Y2UoKHB2LCBjdikgPT4gcHYgKyBjdiwgMCkgLyBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGF2ZXJhZ2VkRGF0YVZhbHVlID4gYXVkaW9MZXZlbFRocmVzaG9sZFxuICAgICAgICAgICAgPyAxMDBcbiAgICAgICAgICAgIDogTWF0aC5yb3VuZCgoYXZlcmFnZWREYXRhVmFsdWUgLyBhdWRpb0xldmVsVGhyZXNob2xkKSAqIDEwMCk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRyYWNrIGlzIGRpc2FibGVkLCBpdCB0YWtlcyB0aW1lIGZvciB0aGUgYnVmZmVyIHRvIGVtcHR5XG4gICAgICAgIC8vIFRoaXMgY2hlY2sgd2lsbCBlbnN1cmUgdGhhdCB3ZSBkb24ndCBzZW5kIGFueXRoaW5nIGlmIHRoZSB0cmFjayBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAoYXVkaW9TdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXT8uZW5hYmxlZCkge1xuICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHsgaXNTb3VuZERldGVjdGVkLCBhdWRpb0xldmVsOiBwZXJjZW50YWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHsgaXNTb3VuZERldGVjdGVkOiBmYWxzZSwgYXVkaW9MZXZlbDogMCB9KTtcbiAgICAgICAgfVxuICAgIH0sIGRldGVjdGlvbkZyZXF1ZW5jeUluTXMpO1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAvLyBjbGVhbi11cCB0aGUgQXVkaW9Db250ZXh0IGVsZW1lbnRzXG4gICAgICAgIG1pY3JvcGhvbmUuZGlzY29ubmVjdCgpO1xuICAgICAgICBhbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICAvLyBzdG9wIHRoZSBzdHJlYW1cbiAgICAgICAgaWYgKGRlc3Ryb3lTdHJlYW1PblN0b3ApIHtcbiAgICAgICAgICAgIGF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIGF1ZGlvU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgc3RhdHMgcmVwb3J0IGludG8gYW4gYXJyYXkgb2Ygc3RhdHMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gZmxhdHRlbi5cbiAqL1xuY29uc3QgZmxhdHRlbiA9IChyZXBvcnQpID0+IHtcbiAgICBjb25zdCBzdGF0cyA9IFtdO1xuICAgIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHN0YXRzLnB1c2gocyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRzO1xufTtcbmNvbnN0IEFVRElPX0xFVkVMX1RIUkVTSE9MRCA9IDAuMjtcbmNsYXNzIFJOU3BlZWNoRGV0ZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBjMSA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7fSk7XG4gICAgICAgIHRoaXMucGMyID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBzcGVlY2ggZGV0ZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGMxLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzIuYWRkSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYzIuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjMS5hZGRJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpb1N0cmVhbVxuICAgICAgICAgICAgICAgIC5nZXRUcmFja3MoKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh0cmFjaykgPT4gdGhpcy5wYzEuYWRkVHJhY2sodHJhY2ssIGF1ZGlvU3RyZWFtKSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMxLmNyZWF0ZU9mZmVyKHt9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMyLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMxLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wYzIuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBjMS5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzIuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSBhdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtdXRlIHRoZSBhdWRpbyB0cmFjayBmb3IgdGhpcyB0ZW1wb3Jhcnkgc3RyZWFtLCBvciBlbHNlIHlvdSB3aWxsIGhlYXIgeW91cnNlbGYgdHdpY2Ugd2hpbGUgaW4gdGhlIGNhbGwuXG4gICAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4gKHRyYWNrLmVuYWJsZWQgPSBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29ubmVjdGluZyBhbmQgbmVnb3RpYXRpbmcgYmV0d2VlbiBQZWVyQ29ubmVjdGlvbnM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBzcGVlY2ggZGV0ZWN0aW9uIGFuZCByZWxlYXNlcyBhbGwgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnBjMS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBjMi5jbG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0aGF0IGRldGVjdHMgdGhlIGF1ZGlvIGxldmVscyBhbmQgcmV0dXJucyB0aGUgc3RhdHVzLlxuICAgICAqL1xuICAgIG9uU3BlYWtpbmdEZXRlY3RlZFN0YXRlQ2hhbmdlKG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IChhd2FpdCB0aGlzLnBjMS5nZXRTdGF0cygpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IGZsYXR0ZW4oc3RhdHMpO1xuICAgICAgICAgICAgLy8gQXVkaW8gbGV2ZWxzIGFyZSBwcmVzZW50IGluc2lkZSBzdGF0cyBvZiB0eXBlIGBtZWRpYS1zb3VyY2VgIGFuZCBvZiBraW5kIGBhdWRpb2BcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvTWVkaWFTb3VyY2VTdGF0cyA9IHJlcG9ydC5maW5kKChzdGF0KSA9PiBzdGF0LnR5cGUgPT09ICdtZWRpYS1zb3VyY2UnICYmXG4gICAgICAgICAgICAgICAgc3RhdC5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgICAgICAgIGlmIChhdWRpb01lZGlhU291cmNlU3RhdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1ZGlvTGV2ZWwgfSA9IGF1ZGlvTWVkaWFTb3VyY2VTdGF0cztcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9MZXZlbCA+PSBBVURJT19MRVZFTF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTb3VuZERldGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTb3VuZERldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0xldmVsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgTWljcm9waG9uZU1hbmFnZXIgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICBzdXBlcihjYWxsLCBuZXcgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSgpLCBUcmFja1R5cGUuQVVESU8pO1xuICAgICAgICBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUkLFxuICAgICAgICAgICAgdGhpcy5jYWxsLnN0YXRlLm93bkNhcGFiaWxpdGllcyQsXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlJCxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzJCxcbiAgICAgICAgXSkuc3Vic2NyaWJlKGFzeW5jIChbY2FsbGluZ1N0YXRlLCBvd25DYXBhYmlsaXRpZXMsIGRldmljZUlkLCBzdGF0dXNdKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9wU3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvd25DYXBhYmlsaXRpZXMuaW5jbHVkZXMoT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERldmljZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdWRpb0RldmljZXMoKTtcbiAgICB9XG4gICAgZ2V0U3RyZWFtKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBnZXRBdWRpb1N0cmVhbShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHB1Ymxpc2hTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwucHVibGlzaEF1ZGlvU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICAgIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuQVVESU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5yblNwZWVjaERldGVjdG9yID0gbmV3IFJOU3BlZWNoRGV0ZWN0b3IoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucm5TcGVlY2hEZXRlY3Rvci5zdGFydCgpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLnJuU3BlZWNoRGV0ZWN0b3I/Lm9uU3BlYWtpbmdEZXRlY3RlZFN0YXRlQ2hhbmdlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0U3BlYWtpbmdXaGlsZU11dGVkKGV2ZW50LmlzU291bmREZXRlY3RlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3I/LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBzdGFydCBhIG5ldyBzdHJlYW0gdGhhdCdzIG5vdCBjb25uZWN0ZWQgdG8gcHVibGlzaGVyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLmdldFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSBjcmVhdGVTb3VuZERldGVjdG9yKHN0cmVhbSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTcGVha2luZ1doaWxlTXV0ZWQoZXZlbnQuaXNTb3VuZERldGVjdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U3BlYWtpbmdXaGlsZU11dGVkKGZhbHNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc291bmREZXRlY3RvckNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNjcmVlblNoYXJlU3RhdGUgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIGF1ZGlvIHN0YXR1cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkJCA9IHRoaXMuYXVkaW9FbmFibGVkU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzJCA9IHRoaXMuc2V0dGluZ3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldmljZUlkRnJvbVN0cmVhbSA9IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt0cmFja10gPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2s/LmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBhdWRpbyBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYXVkaW9FbmFibGVkJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgYXVkaW8gc3RhdHVzLlxuICAgICAqL1xuICAgIHNldEF1ZGlvRW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0LCBpc0VuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICovXG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5ncyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIHRoZSBzY3JlZW4gc2hhcmUgc2V0dGluZ3MgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2V0dGluZ3NTdWJqZWN0LCBzZXR0aW5ncyk7XG4gICAgfVxufVxuXG5jbGFzcyBTY3JlZW5TaGFyZU1hbmFnZXIgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICBzdXBlcihjYWxsLCBuZXcgU2NyZWVuU2hhcmVTdGF0ZSgpLCBUcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBlbmFibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IGZvciBvbmdvaW5nIHNjcmVlbiBzaGFyZSwgYXVkaW8gd29uJ3QgYmUgZW5hYmxlZCB1bnRpbCB5b3VcbiAgICAgKiByZS1wdWJsaXNoIHRoZSBzY3JlZW4gc2hhcmUgc3RyZWFtLlxuICAgICAqL1xuICAgIGVuYWJsZVNjcmVlblNoYXJlQXVkaW8oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0QXVkaW9FbmFibGVkKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGRpc2FibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNhYmxlU2NyZWVuU2hhcmVBdWRpbygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRBdWRpb0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYWxsLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyB0aGUgc2V0dGluZ3MgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH1cbiAgICBnZXREZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gb2YoW10pOyAvLyB0aGVyZSBhcmUgbm8gZGV2aWNlcyB0byBiZSBsaXN0ZWQgZm9yIFNjcmVlbiBTaGFyZVxuICAgIH1cbiAgICBnZXRTdHJlYW0oY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmF1ZGlvRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U2NyZWVuU2hhcmVTdHJlYW0oY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBwdWJsaXNoU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLnB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbShzdHJlYW0sIHtcbiAgICAgICAgICAgIHNjcmVlblNoYXJlU2V0dGluZ3M6IHRoaXMuc3RhdGUuc2V0dGluZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUHVibGlzaFN0cmVhbShzdG9wVHJhY2tzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuU0NSRUVOX1NIQVJFLCBzdG9wVHJhY2tzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYHNlbGVjdGAgbWV0aG9kIHRvIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRldmljZUlkIGlnbm9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0KGRldmljZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBmb3IgU2NyZWVuIFNoYXJlJyk7XG4gICAgfVxufVxuXG5jbGFzcyBTcGVha2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoJycpO1xuICAgICAgICB0aGlzLnZvbHVtZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogW1RlbGxzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIG91dHB1dCBjaGFuZ2Ugb24gJ2F1ZGlvJyBlbGVtZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvc2V0U2lua0lkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNEZXZpY2VTZWxlY3Rpb25TdXBwb3J0ZWQgPSBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgICAgICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAgICAgICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUgPSBzZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREZXZpY2UkID0gdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3RcbiAgICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgICAgIHRoaXMudm9sdW1lJCA9IHRoaXMudm9sdW1lU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkZXZpY2VcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZERldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCB2b2x1bWVcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqL1xuICAgIGdldCB2b2x1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnZvbHVtZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICAgKi9cbiAgICBzZXREZXZpY2UoZGV2aWNlSWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QsIGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHZvbHVtZVxuICAgICAqL1xuICAgIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy52b2x1bWVTdWJqZWN0LCB2b2x1bWUpO1xuICAgIH1cbn1cblxuY2xhc3MgU3BlYWtlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTcGVha2VyU3RhdGUoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlcyB0aGUgbWFuYWdlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGRldmljZUlkcyQgJiYgIWlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goY29tYmluZUxhdGVzdChbZGV2aWNlSWRzJCwgdGhpcy5zdGF0ZS5zZWxlY3RlZERldmljZSRdKS5zdWJzY3JpYmUoKFtkZXZpY2VzLCBkZXZpY2VJZF0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKChkKSA9PiBkLmRldmljZUlkID09PSBkZXZpY2VJZCAmJiBkLmtpbmQgPT09ICdhdWRpb291dHB1dCcpO1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBhdWRpbyBvdXRwdXQgZGV2aWNlc1xuICAgICAqXG4gICAgICogTm90ZTogSXQgcHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHVzZSBkZXZpY2VzIChpZiBub3QgYWxyZWFkeSBncmFudGVkKVxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgd2lsbCBiZSB1cGRhdGVkIGlmIGEgZGV2aWNlIGlzIGNvbm5lY3RlZCBvciBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlcygpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuIFBsZWFzZSB2aXNpdCBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL3JlYWN0bmF0aXZlL2NvcmUvY2FtZXJhLWFuZC1taWNyb3Bob25lLyNzcGVha2VyLW1hbmFnZW1lbnQgZm9yIG1vcmUgZGV0YWlscycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBdWRpb091dHB1dERldmljZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgZGV2aWNlLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCBlbXB0eSBzdHJpbmcgbWVhbnMgdGhlIHN5c3RlbSBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0KGRldmljZUlkKSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnNldERldmljZShkZXZpY2VJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdm9sdW1lIG9mIHRoZSBhdWRpbyBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB2b2x1bWUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICAgKi9cbiAgICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm9sdW1lICYmICh2b2x1bWUgPCAwIHx8IHZvbHVtZSA+IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZvbHVtZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdm9sdW1lIG9mIGEgcGFydGljaXBhbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHBhcnRpY2lwYW50J3Mgc2Vzc2lvbiBpZC5cbiAgICAgKiBAcGFyYW0gdm9sdW1lIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gU2V0IGl0IHRvIGB1bmRlZmluZWRgIHRvIHVzZSB0aGUgZGVmYXVsdCB2b2x1bWUuXG4gICAgICovXG4gICAgc2V0UGFydGljaXBhbnRWb2x1bWUoc2Vzc2lvbklkLCB2b2x1bWUpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuIFBsZWFzZSB2aXNpdCBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL3JlYWN0bmF0aXZlL2NvcmUvY2FtZXJhLWFuZC1taWNyb3Bob25lLyNzcGVha2VyLW1hbmFnZW1lbnQgZm9yIG1vcmUgZGV0YWlscycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2x1bWUgJiYgKHZvbHVtZSA8IDAgfHwgdm9sdW1lID4gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGwuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7IGF1ZGlvVm9sdW1lOiB2b2x1bWUgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGBDYWxsYC5cbiAqL1xuY2xhc3MgQ2FsbCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgQ2FsbGAgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBOT1RFOiBEb24ndCBjYWxsIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseSwgaW5zdGVhZFxuICAgICAqIFVzZSB0aGUgW2BTdHJlYW1WaWRlb0NsaWVudC5jYWxsYF0oLi9TdHJlYW1WaWRlb0NsaWVudC5tZC8jY2FsbClcbiAgICAgKiBtZXRob2QgdG8gY29uc3RydWN0IGEgYENhbGxgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdHlwZSwgaWQsIHN0cmVhbUNsaWVudCwgbWVtYmVycywgb3duQ2FwYWJpbGl0aWVzLCBzb3J0UGFydGljaXBhbnRzQnksIGNsaWVudFN0b3JlLCByaW5naW5nID0gZmFsc2UsIHdhdGNoaW5nID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdGF0ZSBvZiB0aGlzIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IENhbGxTdGF0ZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIER5bmFzY2FsZU1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmR5bmFzY2FsZU1hbmFnZXIgPSBuZXcgRHluYXNjYWxlTWFuYWdlcih0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwZXJtaXNzaW9ucyBjb250ZXh0IG9mIHRoaXMgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVybWlzc2lvbnNDb250ZXh0ID0gbmV3IFBlcm1pc3Npb25zQ29udGV4dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgaW5zdGFuY2UgZGVkaWNhdGVkIHRvIHRoaXMgQ2FsbCBpbnN0YW5jZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKCk7XG4gICAgICAgIHRoaXMudHJhY2tTdWJzY3JpcHRpb25zU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoeyB0eXBlOiBEZWJvdW5jZVR5cGUuTUVESVVNLCBkYXRhOiBbXSB9KTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMgPSAxMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBob29rcy9mdW5jdGlvbnMgdG8gaW52b2tlIHdoZW4gdGhlIGNhbGwgaXMgbGVmdC5cbiAgICAgICAgICogQSB0eXBpY2FsIHVzZSBjYXNlIGlzIHRvIGNsZWFuIHVwIHNvbWUgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiBzdWJzY3JpYmUgdG8gV2ViU29ja2V0IGV2ZW50cyBwcm92aWRlZCBieSB0aGUgQVBJLiBUbyByZW1vdmUgYSBzdWJzY3JpcHRpb24sIGNhbGwgdGhlIGBvZmZgIG1ldGhvZC5cbiAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCBzdWJzY3JpYmluZyB0byBXZWJTb2NrZXQgZXZlbnRzIGlzIGFuIGFkdmFuY2VkIHVzZS1jYXNlLlxuICAgICAgICAgKiBGb3IgbW9zdCB1c2UtY2FzZXMsIGl0IHNob3VsZCBiZSBlbm91Z2ggdG8gd2F0Y2ggZm9yIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgdGhlIGV2ZW50IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBmbiB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub24gPSAoZXZlbnROYW1lLCBmbikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU2Z1RXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIub24oZXZlbnROYW1lLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZIYW5kbGVyID0gdGhpcy5zdHJlYW1DbGllbnQub24oZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY2FsbF9jaWQgJiYgZXZlbnQuY2FsbF9jaWQgPT09IHRoaXMuY2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGtlZXAgdGhlICdvZmYnIHJlZmVyZW5jZSByZXR1cm5lZCBieSB0aGUgc3RyZWFtIGNsaWVudFxuICAgICAgICAgICAgdGhpcy5zdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzLnNldChmbiwgb2ZmSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzdWJzY3JpcHRpb24gZm9yIFdlYlNvY2tldCBldmVudHMgdGhhdCB3ZXJlIGNyZWF0ZWQgYnkgdGhlIGBvbmAgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHRoZSBldmVudCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0gZm4gdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZiA9IChldmVudE5hbWUsIGZuKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTZnVFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5vZmYoZXZlbnROYW1lLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIHRoZSBzdHJlYW0gY2xpZW50IGV2ZW50IGJ5IHVzaW5nIHRoZSAnb2ZmJyByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRPZmZIYW5kbGVyID0gdGhpcy5zdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzLmdldChmbik7XG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZE9mZkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkT2ZmSGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGVhdmUgdGhlIGNhbGwgYW5kIHN0b3AgdGhlIG1lZGlhIHN0cmVhbXMgdGhhdCB3ZXJlIHB1Ymxpc2hlZCBieSB0aGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVhdmUgPSBhc3luYyAoeyByZWplY3QgPSBmYWxzZSwgcmVhc29uID0gJ3VzZXIgaXMgbGVhdmluZyB0aGUgY2FsbCcsIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbGluZ1N0YXRlID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGU7XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxlYXZlIGNhbGwgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGxlZnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTklORykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIEknbSB0aGUgb25lIHdobyBzdGFydGVkIHRoZSBjYWxsLCBzbyBJIHNob3VsZCBjYW5jZWwgaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzT3RoZXJQYXJ0aWNpcGFudHMgPSB0aGlzLnN0YXRlLnJlbW90ZVBhcnRpY2lwYW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ3JlYXRlZEJ5TWUgJiYgIWhhc090aGVyUGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpZ25hbHMgb3RoZXIgdXNlcnMgdGhhdCBJIGhhdmUgY2FuY2VsbGVkIG15IGNhbGwgdG8gdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhleSBhY2NlcHRlZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVqZWN0ICYmIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmFscyBvdGhlciB1c2VycyB0aGF0IEkgaGF2ZSByZWplY3RlZCB0aGUgaW5jb21pbmcgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXI/LnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlcj8uc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyPy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXI/LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50Py5jbG9zZShTdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnNmdUNsaWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5vZmZBbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5MRUZUKTtcbiAgICAgICAgICAgIC8vIENhbGwgYWxsIGxlYXZlIGNhbGwgaG9va3MsIGUuZy4gdG8gY2xlYW4gdXAgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmZvckVhY2goKGhvb2spID0+IGhvb2soKSk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFN0b3JlLnVucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuU2hhcmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zcGVha2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BPbkxlYXZlUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYS5zdG9wT25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLmNhbWVyYS5kaXNhYmxlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuc3RvcE9uTGVhdmUpIHtcbiAgICAgICAgICAgICAgICBzdG9wT25MZWF2ZVByb21pc2VzLnB1c2godGhpcy5taWNyb3Bob25lLmRpc2FibGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyZWVuU2hhcmUuc3RvcE9uTGVhdmUpIHtcbiAgICAgICAgICAgICAgICBzdG9wT25MZWF2ZVByb21pc2VzLnB1c2godGhpcy5zY3JlZW5TaGFyZS5kaXNhYmxlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0b3BPbkxlYXZlUHJvbWlzZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZHMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zLnJpbmcgaWYgc2V0IHRvIHRydWUsIGEgYGNhbGwucmluZ2AgZXZlbnQgd2lsbCBiZSBzZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMubm90aWZ5IGlmIHNldCB0byB0cnVlLCBhIGBjYWxsLm5vdGlmaWNhdGlvbmAgZXZlbnQgd2lsbCBiZSBzZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMubWVtYmVyc19saW1pdCB0aGUgdG90YWwgbnVtYmVyIG9mIG1lbWJlcnMgdG8gcmV0dXJuIGFzIHBhcnQgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LmdldCh0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRoLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcz8ucmluZyAmJiAhdGhpcy5yaW5naW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaW5naW5nU3ViamVjdC5uZXh0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKHJlc3BvbnNlLmNhbGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKHJlc3BvbnNlLm1lbWJlcnMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMocmVzcG9uc2Uub3duX2NhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW1DbGllbnQuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRTdG9yZS5yZWdpc3RlckNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGV2aWNlQ29uZmlnKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGwgYW5kIGNyZWF0ZXMgaXQgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgdG8gY3JlYXRlIHRoZSBjYWxsIHdpdGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE9yQ3JlYXRlID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQucG9zdCh0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRoLCBkYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhPy5yaW5nICYmICF0aGlzLnJpbmdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpbmdpbmdTdWJqZWN0Lm5leHQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UocmVzcG9uc2UuY2FsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMocmVzcG9uc2UubWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE93bkNhcGFiaWxpdGllcyhyZXNwb25zZS5vd25fY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNsaWVudC5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudFN0b3JlLnJlZ2lzdGVyQ2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZXZpY2VDb25maWcoKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjYWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIHRvIGNyZWF0ZSB0aGUgY2FsbCB3aXRoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGUgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JDcmVhdGUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNob3J0Y3V0IGZvciB7QGxpbmsgQ2FsbC5nZXR9IHdpdGggYHJpbmdgIHBhcmFtZXRlciBzZXQgdG8gYHRydWVgLlxuICAgICAgICAgKiBXaWxsIHNlbmQgYSBgY2FsbC5yaW5nYCBldmVudCB0byB0aGUgY2FsbCBtZW1iZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0KHsgcmluZzogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnRjdXQgZm9yIHtAbGluayBDYWxsLmdldH0gd2l0aCBgbm90aWZ5YCBwYXJhbWV0ZXIgc2V0IHRvIGB0cnVlYC5cbiAgICAgICAgICogV2lsbCBzZW5kIGEgYGNhbGwubm90aWZpY2F0aW9uYCBldmVudCB0byB0aGUgY2FsbCBtZW1iZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub3RpZnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoeyBub3RpZnk6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgaW5jb21pbmcgY2FsbCBhcyBhY2NlcHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgb25seSBmb3IgXCJyaW5naW5nXCIgY2FsbCBmbG93cy5cbiAgICAgICAgICoge0BsaW5rIENhbGwuam9pbn0gaW52b2tlcyB0aGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGZvciB5b3Ugd2hlbiBqb2luaW5nIGEgY2FsbC5cbiAgICAgICAgICogVW5sZXNzIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3VzdG9tIFwicmluZ2luZ1wiIGZsb3csIHlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZXB0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vYWNjZXB0YCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgaW5jb21pbmcgY2FsbCBhcyByZWplY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgb25seSBmb3IgXCJyaW5naW5nXCIgY2FsbCBmbG93cy5cbiAgICAgICAgICoge0BsaW5rIENhbGwubGVhdmV9IGludm9rZXMgdGhpcyBtZXRob2QgYXV0b21hdGljYWxseSBmb3IgeW91IHdoZW4geW91IGxlYXZlIG9yIHJlamVjdCB0aGlzIGNhbGwuXG4gICAgICAgICAqIFVubGVzcyB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSBcInJpbmdpbmdcIiBmbG93LCB5b3Ugc2hvdWxkIG5vdCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlamVjdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3JlamVjdGApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBzdGFydCB0byB3YXRjaCBmb3IgY2FsbCByZWxhdGVkIFdlYlNvY2tldCBldmVudHMgYW5kIGluaXRpYXRlIGEgY2FsbCBzZXNzaW9uIHdpdGggdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIG9uY2UgdGhlIGNhbGwgam9pbi1mbG93IGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuam9pbiA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsaW5nU3RhdGUgPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZTtcbiAgICAgICAgICAgIGlmIChbQ2FsbGluZ1N0YXRlLkpPSU5FRCwgQ2FsbGluZ1N0YXRlLkpPSU5JTkddLmluY2x1ZGVzKGNhbGxpbmdTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdKb2luIG1ldGhvZCBjYWxsZWQgdHdpY2UsIHlvdSBzaG91bGQgb25seSBjYWxsIHRoaXMgb25jZScpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBTdGF0ZTogQWxyZWFkeSBqb2luZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBTdGF0ZTogQ2Fubm90IGpvaW4gYWxyZWFkeSBsZWZ0IGNhbGwuIENyZWF0ZSBhIG5ldyBDYWxsIGluc3RhbmNlIHRvIGpvaW4gYSBjYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNNaWdyYXRpbmcgPSBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5NSUdSQVRJTkc7XG4gICAgICAgICAgICBjb25zdCBpc1JlY29ubmVjdGluZyA9IGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElORztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5KT0lOSU5HKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsICdTdGFydGluZyBqb2luIGZsb3cnKTtcbiAgICAgICAgICAgIGlmIChkYXRhPy5yaW5nICYmICF0aGlzLnJpbmdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpbmdpbmdTdWJqZWN0Lm5leHQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yaW5naW5nICYmICF0aGlzLmlzQ3JlYXRlZEJ5TWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYWxzIG90aGVyIHVzZXJzIHRoYXQgSSBoYXZlIGFjY2VwdGVkIHRoZSBpbmNvbWluZyBjYWxsLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2Z1U2VydmVyO1xuICAgICAgICAgICAgbGV0IHNmdVRva2VuO1xuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBsZXQgc3RhdHNPcHRpb25zO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcHJldmlvdXMgU0ZVIGNvbmZpZ3VyYXRpb24gYW5kIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnID0gdGhpcy5wdWJsaXNoZXI/LmNvbm5lY3Rpb25Db25maWd1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzZnVTZXJ2ZXIgPSB0aGlzLnNmdUNsaWVudC5zZnVTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNmdVRva2VuID0gdGhpcy5zZnVDbGllbnQudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzT3B0aW9ucyA9IHRoaXMuc2Z1U3RhdHNSZXBvcnRlcj8ub3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bGwgam9pbiBmbG93IC0gbGV0IHRoZSBDb29yZGluYXRvciBwaWNrIGEgbmV3IFNGVSBmb3IgdXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbCA9IGF3YWl0IGpvaW4odGhpcy5zdHJlYW1DbGllbnQsIHRoaXMudHlwZSwgdGhpcy5pZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKGNhbGwubWVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKGNhbGwub3duQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyA9IGNhbGwuY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgc2Z1U2VydmVyID0gY2FsbC5zZnVTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNmdVRva2VuID0gY2FsbC50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNPcHRpb25zID0gY2FsbC5zdGF0c09wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNsaWVudC5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXRjaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIHByZXZpb3VzIGNhbGwgc3RhdGUgaWYgdGhlIGpvaW4tZmxvdyBmYWlsc1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKGNhbGxpbmdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1NmdUNsaWVudCA9IHRoaXMuc2Z1Q2xpZW50O1xuICAgICAgICAgICAgY29uc3Qgc2Z1Q2xpZW50ID0gKHRoaXMuc2Z1Q2xpZW50ID0gbmV3IFN0cmVhbVNmdUNsaWVudCh7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlcjogdGhpcy5kaXNwYXRjaGVyLFxuICAgICAgICAgICAgICAgIHNmdVNlcnZlcixcbiAgICAgICAgICAgICAgICB0b2tlbjogc2Z1VG9rZW4sXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwcmV2aW91c1NmdUNsaWVudD8uc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNsb3N1cmUgd2hpY2ggaGlkZXMgYXdheSB0aGUgcmUtY29ubmVjdGlvbiBsb2dpYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcmVjb25uZWN0ID0gYXN5bmMgKHN0cmF0ZWd5LCByZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSBDYWxsaW5nU3RhdGUuTUlHUkFUSU5HIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHBhcmFsbGVsIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShzdHJhdGVneSA9PT0gJ21pZ3JhdGUnXG4gICAgICAgICAgICAgICAgICAgID8gQ2FsbGluZ1N0YXRlLk1JR1JBVElOR1xuICAgICAgICAgICAgICAgICAgICA6IENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkcpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ21pZ3JhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBbTWlncmF0aW9uXTogbWlncmF0aW5nIGNhbGwgJHt0aGlzLmNpZH0gYXdheSBmcm9tICR7c2Z1U2VydmVyLmVkZ2VfbmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LmlzTWlncmF0aW5nQXdheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgW1Jlam9pbl06ICR7c3RyYXRlZ3l9IHJlam9pbiBjYWxsICR7dGhpcy5jaWR9ICgke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9KS4uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0YWtlIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgXCJsb2NhbCBwYXJ0aWNpcGFudFwiIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gd2UnbGwgbmVlZCBpdCBmb3IgcmVzdG9yaW5nIHRoZSBwcmV2aW91cyBwdWJsaXNoaW5nIHN0YXRlIGxhdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxQYXJ0aWNpcGFudCA9IHRoaXMuc3RhdGUubG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09ICdmYXN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuY2xvc2UoU3RyZWFtU2Z1Q2xpZW50LkVSUk9SX0NPTk5FQ1RJT05fQlJPS0VOLCBgYXR0ZW1wdGluZyBmYXN0IHJlY29ubmVjdDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cmF0ZWd5ID09PSAnZnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWlncmF0aW9uIG9yIHJlY292ZXJ5IHNjZW5hcmlvcywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB0byBhbiBTRlUgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RBdHRlbXB0cykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBmdWxsLXJlY29ubmVjdCwgd2UgbmVlZCB0byBkaXNwb3NlIGFsbCBQZWVyIENvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcj8uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlcj8uY2xvc2UoeyBzdG9wVHJhY2tzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlcj8uc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNmdVN0YXRzUmVwb3J0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIGN1cnJlbnQgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuY2xvc2UoU3RyZWFtU2Z1Q2xpZW50Lk5PUk1BTF9DTE9TVVJFLCBgYXR0ZW1wdGluZyBmdWxsIHJlY29ubmVjdDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuam9pbih7XG4gICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdHJhdGVneSA9PT0gJ21pZ3JhdGUnICYmIHsgbWlncmF0aW5nX2Zyb206IHNmdVNlcnZlci5lZGdlX25hbWUgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgcHJldmlvdXMgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ21pZ3JhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5jbG9zZShTdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUsICdhdHRlbXB0aW5nIG1pZ3JhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBbUmVqb2luXTogQXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9IHN1Y2Nlc3NmdWwhYCk7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IGJlIHJlcHVibGlzaGluZyB0aGUgc3RyZWFtcyBpZiB3ZSdyZSBtaWdyYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgdW5kZXJseWluZyBwZWVyIGNvbm5lY3Rpb24gd2lsbCB0YWtlIGNhcmUgb2YgaXQgYXMgcGFydFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBpY2UtcmVzdGFydCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsUGFydGljaXBhbnQgJiYgc3RyYXRlZ3kgPT09ICdmdWxsJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGF1ZGlvU3RyZWFtLCB2aWRlb1N0cmVhbSwgc2NyZWVuU2hhcmVTdHJlYW0sIHNjcmVlblNoYXJlQXVkaW9TdHJlYW0sIH0gPSBsb2NhbFBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NyZWVuU2hhcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JlZW5TaGFyZVN0cmVhbSB8fCBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVTdHJlYW0/LmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZT8uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtPy5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmU/LmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgcHVibGlzaGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9TdHJlYW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBdWRpb1N0cmVhbShhdWRpb1N0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb1N0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVmlkZW9TdHJlYW0odmlkZW9TdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRDb2RlYzogdGhpcy5jYW1lcmEucHJlZmVycmVkQ29kZWMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NyZWVuU2hhcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbShzY3JlZW5TaGFyZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFtSZWpvaW5dOiBTdGF0ZSByZXN0b3JlZC4gQXR0ZW1wdDogJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZWNvbm5lY3QgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCB1bmV4cGVjdGVkbHkuIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyAtIFNGVSBjcmFzaCBvciByZXN0YXJ0XG4gICAgICAgICAgICAvLyAtIG5ldHdvcmsgY2hhbmdlXG4gICAgICAgICAgICBzZnVDbGllbnQuc2lnbmFsUmVhZHkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aGUgXCJnb0F3YXlcIiBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHVucmVnaXN0ZXJHb0F3YXkgPSB0aGlzLmRpc3BhdGNoZXIub24oJ2dvQXdheScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlYXNvbiB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFtNaWdyYXRpb25dOiBHb2luZyBhd2F5IGZyb20gU0ZVLi4uIFJlYXNvbjogJHtHb0F3YXlSZWFzb25bcmVhc29uXX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0KCdtaWdyYXRlJywgR29Bd2F5UmVhc29uW3JlYXNvbl0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYFtNaWdyYXRpb25dOiBGYWlsZWQgdG8gbWlncmF0ZSB0byBhbm90aGVyIFNGVS5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZnVDbGllbnQuc2lnbmFsV3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBcImdvQXdheVwiIGhhbmRsZXIsIGFzIHdlIHdvbid0IG5lZWQgaXQgYW55bW9yZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXBjb21pbmcgcmUtam9pbiB3aWxsIHJlZ2lzdGVyIGEgbmV3IGhhbmRsZXIgYW55d2F5XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJHb0F3YXkoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gU3RyZWFtU2Z1Q2xpZW50Lk5PUk1BTF9DTE9TVVJFKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVjYXVzZSBvZiBhIHBvbGljeSB2aW9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiwgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZCBieSBhbiBhZG1pbiBvciBtb2RlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gS25vd25Db2Rlcy5XU19QT0xJQ1lfVklPTEFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBTRlUgaXMgYmVpbmcgc2h1dCBkb3duLCBpdCBzZW5kcyBhIGdvQXdheSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBtaWdyYXRlIHRvIGFub3RoZXIgU0ZVLCB3ZSBtaWdodCBoYXZlIHRoZSBXUyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBvbGQgU0ZVIGNsb3NlZCBhYnJ1cHRseS4gSW4gdGhpcyBjYXNlLCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlY29ubmVjdCB0byB0aGUgb2xkIFNGVSwgYnV0IHJhdGhlciB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNNaWdyYXRpbmdBd2F5ID0gZS5jb2RlID09PSBLbm93bkNvZGVzLldTX0NMT1NFRF9BQlJVUFRMWSAmJiBzZnVDbGllbnQuaXNNaWdyYXRpbmdBd2F5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Zhc3RSZWNvbm5lY3RpbmcgPSBlLmNvZGUgPT09IEtub3duQ29kZXMuV1NfQ0xPU0VEX0FCUlVQVExZICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaWdyYXRpbmdBd2F5IHx8IGlzRmFzdFJlY29ubmVjdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlY2F1c2Ugb2YgYSBmYXN0IHJlY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSBTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LmlzRmFzdFJlY29ubmVjdGluZyA9IHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IHNmdUNsaWVudC5pc0Zhc3RSZWNvbm5lY3RpbmcgPyAnZmFzdCcgOiAnZnVsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3Qoc3RyYXRlZ3ksIGBTRlUgY2xvc2VkIHRoZSBXUyB3aXRoIGNvZGU6ICR7ZS5jb2RlfWApLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl06ICR7c3RyYXRlZ3l9IHJlam9pbiBmYWlsZWQgZm9yICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gdGltZXMuIEdpdmluZyB1cC5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkdfRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1tSZWpvaW5dOiBSZWNvbm5lY3QgYXR0ZW1wdHMgZXhjZWVkZWQuIEdpdmluZyB1cC4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGhhbmRsZXJzIGZvciBjb25uZWN0aW9uIG9ubGluZS9vZmZsaW5lIGV2ZW50c1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVPbmxpbmVFdmVudCA9IHRoaXMuc3RyZWFtQ2xpZW50Lm9uKCdjb25uZWN0aW9uLmNoYW5nZWQnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgIT09ICdjb25uZWN0aW9uLmNoYW5nZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFlLm9ubGluZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlT25saW5lRXZlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGluZ1N0YXRlID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVjb25uZWN0ID0gY3VycmVudENhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkUgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdbUmVqb2luXTogR29pbmcgb25saW5lLi4uJyk7XG4gICAgICAgICAgICAgICAgbGV0IGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nID0gaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZWNvbm5lY3QoaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQgPyAnZmFzdCcgOiAnZnVsbCcsICdOZXR3b3JrOiBvbmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYnJlYWsgdGhlIGxvb3AgaWYgcmVqb2luIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl1bTmV0d29ya106IFJlam9pbiBmYWlsZWQgZm9yIGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfWAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgYSBiaXQgYmVmb3JlIHRyeWluZyB0byByZWNvbm5lY3QgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUsIGl0IG1lYW5zIHRoYXQgd2UndmUgZXhoYXVzdGVkIGFsbCB0aGUgcmVjb25uZWN0IGF0dGVtcHRzXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFtSZWpvaW5dW05ldHdvcmtdOiBSZWpvaW4gZmFpbGVkLiBHaXZpbmcgdXAuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCA9IHRoaXMuc3RyZWFtQ2xpZW50Lm9uKCdjb25uZWN0aW9uLmNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgIT09ICdjb25uZWN0aW9uLmNoYW5nZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGUub25saW5lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVPZmZsaW5lRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuT0ZGTElORSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU9ubGluZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVPZmZsaW5lRXZlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcih7XG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlcjogdGhpcy5kaXNwYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpb1NldHRpbmdzID0gdGhpcy5zdGF0ZS5zZXR0aW5ncz8uYXVkaW87XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEdHhFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5vcHVzX2R0eF9lbmFibGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVkRW5hYmxlZCA9ICEhYXVkaW9TZXR0aW5ncz8ucmVkdW5kYW50X2NvZGluZ19lbmFibGVkO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFB1Ymxpc2hlcih7XG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlcjogdGhpcy5kaXNwYXRjaGVyLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgaXNEdHhFbmFibGVkLFxuICAgICAgICAgICAgICAgICAgICBpc1JlZEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHNSZXBvcnRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IGNyZWF0ZVN0YXRzUmVwb3J0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyOiB0aGlzLnN1YnNjcmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlcjogdGhpcy5wdWJsaXNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50RGV0YWlscyA9IGdldENsaWVudERldGFpbHMoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZnVTdGF0c1JlcG9ydGVyICYmIHN0YXRzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlciA9IG5ldyBTZnVTdGF0c1JlcG9ydGVyKHNmdUNsaWVudCwge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzdGF0c09wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXI6IHRoaXMuc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyOiB0aGlzLnB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNmdVN0YXRzUmVwb3J0ZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gMS4gd2FpdCBmb3IgdGhlIHNpZ25hbCBzZXJ2ZXIgdG8gYmUgcmVhZHkgYmVmb3JlIHNlbmRpbmcgXCJqb2luUmVxdWVzdFwiXG4gICAgICAgICAgICAgICAgc2Z1Q2xpZW50LnNpZ25hbFJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB0aGlzLmxvZ2dlcignZXJyb3InLCAnU2lnbmFsIHJlYWR5IGZhaWxlZCcsIGVycikpXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgYSBnZW5lcmljIFNEUCBhbmQgc2VuZCBpdCB0byB0aGUgU0ZVLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgdGhyb3ctYXdheSBTRFAgdGhhdCB0aGUgU0ZVIHdpbGwgdXNlIHRvIGRldGVybWluZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBjbGllbnQgKGNvZGVjIHN1cHBvcnQsIGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGdldEdlbmVyaWNTZHAoJ3JlY3Zvbmx5JykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChzZHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGdldEN1cnJlbnRWYWx1ZSh0aGlzLnRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWdyYXRpb24gPSBpc01pZ3JhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVNmdUlkOiBkYXRhPy5taWdyYXRpbmdfZnJvbSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBzdWJzY3JpcHRpb25zLmRhdGEgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3VuY2VkVHJhY2tzOiB0aGlzLnB1Ymxpc2hlcj8uZ2V0Q3VycmVudFRyYWNrSW5mb3MoKSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Z1Q2xpZW50LmpvaW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclNkcDogc2RwIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50RGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhc3RSZWNvbm5lY3Q6IHByZXZpb3VzU2Z1Q2xpZW50Py5pc0Zhc3RSZWNvbm5lY3RpbmcgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIDIuIGluIHBhcmFsbGVsLCB3YWl0IGZvciB0aGUgU0ZVIHRvIHNlbmQgdXMgdGhlIFwiam9pblJlc3BvbnNlXCJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFNGVSByZWplY3RzIHRoZSBqb2luIHJlcXVlc3Qgb3JcbiAgICAgICAgICAgICAgICAvLyBmYWlscyB0byByZXNwb25kIGluIHRpbWVcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhbGxTdGF0ZSwgcmVjb25uZWN0ZWQgfSA9IGF3YWl0IHRoaXMud2FpdEZvckpvaW5SZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnW1Jlam9pbl0gZmFzdCByZWNvbm5lY3RlZDonLCByZWNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc01pZ3JhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIubWlncmF0ZVRvKHNmdUNsaWVudCwgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLm1pZ3JhdGVUbyhzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgU0ZVIGNsaWVudCBpbnN0YW5jZSBvbiB0aGUgc3Vic2NyaWJlciBhbmQgcHVibGlzaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5zZXRTZnVDbGllbnQoc2Z1Q2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwZXJmb3JtIGEgZnVsbCBJQ0UgcmVzdGFydCBvbiB0aGUgcHVibGlzaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZXN0YXJ0SWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXNTZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb25uZWN0aW9uIHdhc24ndCBwb3NzaWJsZSwgc28gd2UgbmVlZCB0byBkbyBhIGZ1bGwgcmVqb2luXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVjb25uZWN0KCdmdWxsJywgJ3JlLWF0dGVtcHRpbmcnKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFtSZWpvaW5dOiBSZWpvaW4gZmFpbGVkIGZvcmNlZCBmdWxsIHJlam9pbi5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnRpY2lwYW50cyA9IGNhbGxTdGF0ZT8ucGFydGljaXBhbnRzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50Q291bnQgPSBjYWxsU3RhdGU/LnBhcnRpY2lwYW50Q291bnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gY2FsbFN0YXRlPy5zdGFydGVkQXRcbiAgICAgICAgICAgICAgICAgICAgPyBUaW1lc3RhbXAudG9EYXRlKGNhbGxTdGF0ZS5zdGFydGVkQXQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW5zID0gY2FsbFN0YXRlPy5waW5zID8/IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0UGFydGljaXBhbnRzKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnRMb29rdXAgPSB0aGlzLnN0YXRlLmdldFBhcnRpY2lwYW50TG9va3VwQnlTZXNzaW9uSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIHRoZSBsb2NhbCBzdGF0ZSBvZiB0aGUgcGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIHZpZGVvRGltZW5zaW9uLCB2aXNpYmlsaXR5U3RhdGUsIHBpbm5lZEF0LCBldGMuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQgZG9lc24ndCBleGlzdCBvbiB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJ0aWNpcGFudCA9IHBhcnRpY2lwYW50TG9va3VwW3Auc2Vzc2lvbklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIGV4aXN0aW5nUGFydGljaXBhbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsUGFydGljaXBhbnQ6IHAuc2Vzc2lvbklkID09PSBzZnVDbGllbnQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiBleGlzdGluZ1BhcnRpY2lwYW50Py52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/PyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZVRyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0UGFydGljaXBhbnRDb3VudChwYXJ0aWNpcGFudENvdW50Py50b3RhbCB8fCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudD8uYW5vbnltb3VzIHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0U3RhcnRlZEF0KHN0YXJ0ZWRBdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZXJ2ZXJTaWRlUGlucyhwaW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDsgLy8gcmVzZXQgdGhlIHJlY29ubmVjdCBhdHRlbXB0cyBjb3VudGVyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLkpPSU5FRCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0Q2FtZXJhKHsgc2V0U3RhdHVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRNaWMoeyBzZXRTdGF0dXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdDYW1lcmEgYW5kL29yIG1pYyBpbml0IGZhaWxlZCBkdXJpbmcgam9pbiBjYWxsJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAzLiBvbmNlIHdlIGhhdmUgdGhlIFwiam9pblJlc3BvbnNlXCIsIGFuZCBwb3NzaWJseSByZWNvbmNpbGVkIHRoZSBsb2NhbCBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHdlIHNjaGVkdWxlIGEgZmFzdCBzdWJzY3JpcHRpb24gdXBkYXRlIGZvciBhbGwgcmVtb3RlIHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2VyZSB2aXNpYmxlIGJlZm9yZSB3ZSByZWNvbm5lY3RlZCBvciBtaWdyYXRlZCB0byBhIG5ldyBTRlUuXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZW1vdGVQYXJ0aWNpcGFudHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZVBhcnRpY2lwYW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucyhyZW1vdGVQYXJ0aWNpcGFudHMsIERlYm91bmNlVHlwZS5GQVNUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgSm9pbmVkIGNhbGwgJHt0aGlzLmNpZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBqb2luIGZhaWxlZCwgdHJ5IHRvIHJlam9pblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl06IFJlam9pbiAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9IGZhaWxlZC5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZWNvbm5lY3QoJ2Z1bGwnLCAncHJldmlvdXMgYXR0ZW1wdCBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgW1Jlam9pbl06IFJlam9pbiAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9IHN1Y2Nlc3NmdWwhYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl06IFJlam9pbiBmYWlsZWQgZm9yICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gdGltZXMuIEdpdmluZyB1cC5gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pvaW4gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhaXRGb3JKb2luUmVzcG9uc2UgPSAodGltZW91dCA9IDUwMDApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uKCdqb2luUmVzcG9uc2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdXYWl0aW5nIGZvciBcImpvaW5SZXNwb25zZVwiIGhhcyB0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBwdWJsaXNoaW5nIHRoZSBnaXZlbiB2aWRlbyBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAgICAgICAqIFRoZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkIGlmIHRoZSB1c2VyIGNoYW5nZXMgYW4gaW5wdXQgZGV2aWNlLCBvciBpZiB0aGUgdXNlciBsZWF2ZXMgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgcHJldmlvdXNseSBwdWJsaXNoZWQgc3RyZWFtLlxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgdmlkZW8gc3RyZWFtIHdpbGwgYmUgc3RvcHBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvU3RyZWFtIHRoZSB2aWRlbyBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gcHVibGlzaGluZyB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdWJsaXNoVmlkZW9TdHJlYW0gPSBhc3luYyAodmlkZW9TdHJlYW0sIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHdhaXQgdW50aWwgd2UgZ2V0IGEgSm9pblJlc3BvbnNlIGZyb20gdGhlIFNGVSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSByaXNrIGJyZWFraW5nIHRoZSBJQ0VUcmlja2xlIGZsb3cuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydENhbGxKb2luZWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnVHJ5aW5nIHRvIHB1Ymxpc2ggdmlkZW8gYmVmb3JlIGpvaW4gaXMgY29tcGxldGVkJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIG5vdCBqb2luZWQgeWV0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3ZpZGVvVHJhY2tdID0gdmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBUaGVyZSBpcyBubyB2aWRlbyB0cmFjayB0byBwdWJsaXNoIGluIHRoZSBzdHJlYW0uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIucHVibGlzaFN0cmVhbSh2aWRlb1N0cmVhbSwgdmlkZW9UcmFjaywgVHJhY2tUeXBlLlZJREVPLCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBwdWJsaXNoaW5nIHRoZSBnaXZlbiBhdWRpbyBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAgICAgICAqIFRoZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkIGlmIHRoZSB1c2VyIGNoYW5nZXMgYW4gaW5wdXQgZGV2aWNlLCBvciBpZiB0aGUgdXNlciBsZWF2ZXMgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgYXVkaW8gc3RyZWFtIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICAgICAgICogVGhlIHByZXZpb3VzIGF1ZGlvIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhdWRpb1N0cmVhbSB0aGUgYXVkaW8gc3RyZWFtIHRvIHB1Ymxpc2guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1Ymxpc2hBdWRpb1N0cmVhbSA9IGFzeW5jIChhdWRpb1N0cmVhbSkgPT4ge1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHdhaXQgdW50aWwgd2UgZ2V0IGEgSm9pblJlc3BvbnNlIGZyb20gdGhlIFNGVSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSByaXNrIGJyZWFraW5nIHRoZSBJQ0VUcmlja2xlIGZsb3cuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydENhbGxKb2luZWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnVHJ5aW5nIHRvIHB1Ymxpc2ggYXVkaW8gYmVmb3JlIGpvaW4gaXMgY29tcGxldGVkJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIG5vdCBqb2luZWQgeWV0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2F1ZGlvVHJhY2tdID0gYXVkaW9TdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmICghYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBUaGVyZSBpcyBubyBhdWRpbyB0cmFjayBpbiB0aGUgc3RyZWFtIHRvIHB1Ymxpc2hgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoU3RyZWFtKGF1ZGlvU3RyZWFtLCBhdWRpb1RyYWNrLCBUcmFja1R5cGUuQVVESU8pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHNjcmVlbi1zaGFyZSBzdHJlYW0gdG8gdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnNlY3V0aXZlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpbGwgcmVwbGFjZSB0aGUgcHJldmlvdXMgc2NyZWVuLXNoYXJlIHN0cmVhbS5cbiAgICAgICAgICogVGhlIHByZXZpb3VzIHNjcmVlbi1zaGFyZSBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2NyZWVuU2hhcmVTdHJlYW0gdGhlIHNjcmVlbi1zaGFyZSBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gcHVibGlzaGluZyB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdWJsaXNoU2NyZWVuU2hhcmVTdHJlYW0gPSBhc3luYyAoc2NyZWVuU2hhcmVTdHJlYW0sIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHdhaXQgdW50aWwgd2UgZ2V0IGEgSm9pblJlc3BvbnNlIGZyb20gdGhlIFNGVSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSByaXNrIGJyZWFraW5nIHRoZSBJQ0VUcmlja2xlIGZsb3cuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydENhbGxKb2luZWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnVHJ5aW5nIHRvIHB1Ymxpc2ggc2NyZWVuIHNoYXJlIGJlZm9yZSBqb2luIGlzIGNvbXBsZXRlZCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCBub3Qgam9pbmVkIHlldC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtzY3JlZW5TaGFyZVRyYWNrXSA9IHNjcmVlblNoYXJlU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAoIXNjcmVlblNoYXJlVHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgVGhlcmUgaXMgbm8gdmlkZW8gdHJhY2sgaW4gdGhlIHNjcmVlbiBzaGFyZSBzdHJlYW0gdG8gcHVibGlzaGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oc2NyZWVuU2hhcmVTdHJlYW0sIHNjcmVlblNoYXJlVHJhY2ssIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUsIG9wdHMpO1xuICAgICAgICAgICAgY29uc3QgW3NjcmVlblNoYXJlQXVkaW9UcmFja10gPSBzY3JlZW5TaGFyZVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgaWYgKHNjcmVlblNoYXJlQXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oc2NyZWVuU2hhcmVTdHJlYW0sIHNjcmVlblNoYXJlQXVkaW9UcmFjaywgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTywgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBwdWJsaXNoaW5nIHRoZSBnaXZlbiB0cmFjayB0eXBlIHRvIHRoZSBjYWxsLCBpZiBpdCBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkLlxuICAgICAgICAgKiBVbmRlcmx5aW5nIHRyYWNrIHdpbGwgYmUgc3RvcHBlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBwdWJsaXNoZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gc3RvcCBwdWJsaXNoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gc3RvcFRyYWNrIGlmIGB0cnVlYCB0aGUgdHJhY2sgd2lsbCBiZSBzdG9wcGVkLCBlbHNlIGl0IHdpbGwgYmUganVzdCBkaXNhYmxlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wUHVibGlzaCA9IGFzeW5jICh0cmFja1R5cGUsIHN0b3BUcmFjayA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYHN0b3BQdWJsaXNoICR7VHJhY2tUeXBlW3RyYWNrVHlwZV19LCBzdG9wIHRyYWNrczogJHtzdG9wVHJhY2t9YCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlcj8udW5wdWJsaXNoU3RyZWFtKHRyYWNrVHlwZSwgc3RvcFRyYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0cmFjayBzdWJzY3JpcHRpb24gY29uZmlndXJhdGlvbiBmb3Igb25lIG9yIG1vcmUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKiBZb3UgaGF2ZSB0byBjcmVhdGUgYSBzdWJzY3JpcHRpb24gZm9yIGVhY2ggcGFydGljaXBhbnQgZm9yIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzIG9mIHRyYWNrcyB5b3Ugd2FudCB0byByZWNlaXZlLlxuICAgICAgICAgKiBZb3UgY2FuIG9ubHkgc3Vic2NyaWJlIGZvciB0cmFja3MgYWZ0ZXIgdGhlIHBhcnRpY2lwYW50IHN0YXJ0ZWQgcHVibGlzaGluZyB0aGUgZ2l2ZW4ga2luZCBvZiB0cmFjay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBzdWJzY3JpcHRpb24gdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gY2hhbmdlcyB0aGUgbGlzdCBvZiBzdWJzY3JpcHRpb24gY2hhbmdlcyB0byBkby5cbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIGRlYm91bmNlIHR5cGUgdG8gdXNlIGZvciB0aGUgdXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbCA9ICh0cmFja1R5cGUsIGNoYW5nZXMsIHR5cGUgPSBEZWJvdW5jZVR5cGUuU0xPVykgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrVHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYHVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsOiAke3RyYWNrVHlwZX0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHN3aXRjaCB0byAndmlkZW9UcmFjaydgKTtcbiAgICAgICAgICAgICAgICB0cmFja1R5cGUgPSAndmlkZW9UcmFjayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cmFja1R5cGUgPT09ICdzY3JlZW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgdXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWw6ICR7dHJhY2tUeXBlfSBpcyBkZXByZWNhdGVkLiBQbGVhc2Ugc3dpdGNoIHRvICdzY3JlZW5TaGFyZVRyYWNrJ2ApO1xuICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9ICdzY3JlZW5TaGFyZVRyYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnRzKE9iamVjdC5lbnRyaWVzKGNoYW5nZXMpLnJlZHVjZSgoYWNjLCBbc2Vzc2lvbklkLCBjaGFuZ2VdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5kaW1lbnNpb24/LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGltZW5zaW9uLmhlaWdodCA9IE1hdGguY2VpbChjaGFuZ2UuZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGltZW5zaW9uPy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGltZW5zaW9uLndpZHRoID0gTWF0aC5jZWlsKGNoYW5nZS5kaW1lbnNpb24ud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gdHJhY2tUeXBlID09PSAndmlkZW9UcmFjaydcbiAgICAgICAgICAgICAgICAgICAgPyAndmlkZW9EaW1lbnNpb24nXG4gICAgICAgICAgICAgICAgICAgIDogdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVUcmFjaydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3NjcmVlblNoYXJlRGltZW5zaW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW3Nlc3Npb25JZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbcHJvcF06IGNoYW5nZS5kaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSkpO1xuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucyhwYXJ0aWNpcGFudHMsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMgPSAocGFydGljaXBhbnRzLCB0eXBlID0gRGVib3VuY2VUeXBlLlNMT1cpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHN1YnNjcmliZSB0byBvdXIgb3duIHRyYWNrc1xuICAgICAgICAgICAgICAgIGlmIChwLmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogYXVkaW8gdHJhY2tzIGRvbid0IGhhdmUgdG8gYmUgcmVxdWVzdGVkIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgU0ZVIHdpbGwgaW1wbGljaXRseSBzdWJzY3JpYmUgdXMgdG8gYWxsIG9mIHRoZW0sXG4gICAgICAgICAgICAgICAgLy8gb25jZSB0aGV5IGJlY29tZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgaWYgKHAudmlkZW9EaW1lbnNpb24gJiYgcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlZJREVPKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkOiBwLnVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1R5cGU6IFRyYWNrVHlwZS5WSURFTyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogcC52aWRlb0RpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwLnNjcmVlblNoYXJlRGltZW5zaW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZTogVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogcC5zY3JlZW5TaGFyZURpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkOiBwLnVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1R5cGU6IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0Lm5leHQoeyB0eXBlLCBkYXRhOiBzdWJzY3JpcHRpb25zIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBlbmhhbmNlIHRoZSByZXBvcnRlZCBzdGF0cyB3aXRoIGFkZGl0aW9uYWwgcGFydGljaXBhbnQtc3BlY2lmaWMgaW5mb3JtYXRpb24gKGBjYWxsU3RhdHNSZXBvcnQkYCBzdGF0ZSBbc3RvcmUgdmFyaWFibGVdKC4vU3RyZWFtVmlkZW9DbGllbnQubWQvI3JlYWRvbmx5c3RhdGVzdG9yZSkpLlxuICAgICAgICAgKiBUaGlzIGlzIHVzdWFsbHkgaGVscGZ1bCB3aGVuIGRldGFpbGVkIHN0YXRzIGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50IGFyZSBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCB0byBzdGFydCByZXBvcnRpbmcgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcihzZXNzaW9uSWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3Bwb3NpdGUgb2YgYHN0YXJ0UmVwb3J0aW5nU3RhdHNGb3JgLlxuICAgICAgICAgKiBXaWxsIHR1cm4gb2ZmIHN0YXRzIHJlcG9ydGluZyBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHN0b3AgcmVwb3J0aW5nIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RvcFJlcG9ydGluZ1N0YXRzRm9yKHNlc3Npb25JZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGxhc3Qgc2VudCByZWFjdGlvbiBmb3IgdGhlIHVzZXIgaG9sZGluZyB0aGUgZ2l2ZW4gYHNlc3Npb25JZGAuIFRoaXMgaXMgYSBsb2NhbCBhY3Rpb24sIGl0IHdvbid0IHJlc2V0IHRoZSByZWFjdGlvbiBvbiB0aGUgYmFja2VuZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXRSZWFjdGlvbiA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbGlzdCBvZiBjcml0ZXJpYSB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMgYnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjcml0ZXJpYSB0aGUgbGlzdCBvZiBjcml0ZXJpYSB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMgYnkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNvcnRQYXJ0aWNpcGFudHNCeSA9IChjcml0ZXJpYSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2V0U29ydFBhcnRpY2lwYW50c0J5KGNyaXRlcmlhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGxpc3Qgb2YgdmlkZW8gbGF5ZXJzIHRvIHB1Ymxpc2guXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gZW5hYmxlZExheWVycyB0aGUgbGlzdCBvZiBsYXllcnMgdG8gZW5hYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVQdWJsaXNoUXVhbGl0eSA9IGFzeW5jIChlbmFibGVkTGF5ZXJzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXI/LnVwZGF0ZVZpZGVvUHVibGlzaFF1YWxpdHkoZW5hYmxlZExheWVycyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlJFxuICAgICAgICAgICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKHN0YXRlKSA9PiBzdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCwgdHJ1ZSksIGZpbHRlcigocykgPT4gcyA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSByZWFjdGlvbiB0byB0aGUgb3RoZXIgY2FsbCBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZWFjdGlvbiB0aGUgcmVhY3Rpb24gdG8gc2VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZFJlYWN0aW9uID0gYXN5bmMgKHJlYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9yZWFjdGlvbmAsIHJlYWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJsb2NrcyB0aGUgdXNlciB3aXRoIHRoZSBnaXZlbiBgdXNlcklkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrVXNlciA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2Jsb2NrYCwge1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5ibG9ja3MgdGhlIHVzZXIgd2l0aCB0aGUgZ2l2ZW4gYHVzZXJJZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyIHRvIHVuYmxvY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuYmxvY2tVc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdW5ibG9ja2AsIHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11dGVzIHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBtdXRlIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZVNlbGYgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbXlVc2VySWQgPSB0aGlzLmN1cnJlbnRVc2VySWQ7XG4gICAgICAgICAgICBpZiAobXlVc2VySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tdXRlVXNlcihteVVzZXJJZCwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRlcyBhbGwgdGhlIG90aGVyIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIG11dGUgb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdXRlT3RoZXJzID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrVHlwZSA9IG11dGVUeXBlVG9UcmFja1R5cGUodHlwZSk7XG4gICAgICAgICAgICBpZiAoIXRyYWNrVHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB1c2VySWRzVG9NdXRlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnRpY2lwYW50IG9mIHRoaXMuc3RhdGUucmVtb3RlUGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyh0cmFja1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJJZHNUb011dGUucHVzaChwYXJ0aWNpcGFudC51c2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11dGVVc2VyKHVzZXJJZHNUb011dGUsIHR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTXV0ZXMgdGhlIHVzZXIgd2l0aCB0aGUgZ2l2ZW4gYHVzZXJJZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyIHRvIG11dGUuXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBtdXRlIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZVVzZXIgPSAodXNlcklkLCB0eXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9tdXRlX3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIHVzZXJfaWRzOiBBcnJheS5pc0FycmF5KHVzZXJJZCkgPyB1c2VySWQgOiBbdXNlcklkXSxcbiAgICAgICAgICAgICAgICBbdHlwZV06IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgbXV0ZSBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBtdXRlIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZUFsbFVzZXJzID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L211dGVfdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgbXV0ZV9hbGxfdXNlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgW3R5cGVdOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcmVjb3JkaW5nIHRoZSBjYWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0YXJ0X3JlY29yZGluZ2AsIHJlcXVlc3QgPyByZXF1ZXN0IDoge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgcmVjb3JkaW5nIHRoZSBjYWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdG9wX3JlY29yZGluZ2AsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyB0aGUgdHJhbnNjcmlwdGlvbiBvZiB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3QgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0YXJ0X3RyYW5zY3JpcHRpb25gLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHRoZSB0cmFuc2NyaXB0aW9uIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wVHJhbnNjcmlwdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfdHJhbnNjcmlwdGlvbmApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBgY2FsbC5wZXJtaXNzaW9uX3JlcXVlc3RgIGV2ZW50IHRvIGFsbCB1c2VycyBjb25uZWN0ZWQgdG8gdGhlIGNhbGwuIFRoZSBjYWxsIHNldHRpbmdzIG9iamVjdCBjb250YWlucyBpbmZvbXJhdGlvbiBhYm91dCB3aGljaCBwZXJtaXNzaW9ucyBjYW4gYmUgcmVxdWVzdGVkIGR1cmluZyBhIGNhbGwgKGZvciBleGFtcGxlIGEgdXNlciBtaWdodCBiZSBhbGxvd2VkIHRvIHJlcXVlc3QgcGVybWlzc2lvbiB0byBwdWJsaXNoIGF1ZGlvLCBidXQgbm90IHZpZGVvKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWVzdFBlcm1pc3Npb25zID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCBjYW5SZXF1ZXN0UGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucy5ldmVyeSgocGVybWlzc2lvbikgPT4gdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChwZXJtaXNzaW9uKSk7XG4gICAgICAgICAgICBpZiAoIWNhblJlcXVlc3RQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGFyZSBub3QgYWxsb3dlZCB0byByZXF1ZXN0IHBlcm1pc3Npb25zOiAke3Blcm1pc3Npb25zLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9yZXF1ZXN0X3Blcm1pc3Npb25gLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gZ3JhbnQgY2VydGFpbiBwZXJtaXNzaW9ucyB0byBhIHVzZXIgaW4gYSBjYWxsLlxuICAgICAgICAgKiBUaGUgcGVybWlzc2lvbnMgYXJlIHNwZWNpZmljIHRvIHRoZSBjYWxsIGV4cGVyaWVuY2UgYW5kIGRvIG5vdCBzdXJ2aXZlIHRoZSBjYWxsIGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIGdyYW50ZWQgYXJlOlxuICAgICAgICAgKiAtIGBzZW5kLWF1ZGlvYFxuICAgICAgICAgKiAtIGBzZW5kLXZpZGVvYFxuICAgICAgICAgKiAtIGBzY3JlZW5zaGFyZWBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gZ3JhbnQgcGVybWlzc2lvbnMgdG8uXG4gICAgICAgICAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gZ3JhbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyYW50UGVybWlzc2lvbnMgPSBhc3luYyAodXNlcklkLCBwZXJtaXNzaW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zKHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICAgICAgZ3JhbnRfcGVybWlzc2lvbnM6IHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIHJldm9rZSBjZXJ0YWluIHBlcm1pc3Npb25zIGZyb20gYSB1c2VyIGluIGEgY2FsbC5cbiAgICAgICAgICogVGhlIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpYyB0byB0aGUgY2FsbCBleHBlcmllbmNlIGFuZCBkbyBub3Qgc3Vydml2ZSB0aGUgY2FsbCBpdHNlbGYuXG4gICAgICAgICAqXG4gICAgICAgICAqIFN1cHBvcnRlZCBwZXJtaXNzaW9ucyB0aGF0IGNhbiBiZSByZXZva2VkIGFyZTpcbiAgICAgICAgICogLSBgc2VuZC1hdWRpb2BcbiAgICAgICAgICogLSBgc2VuZC12aWRlb2BcbiAgICAgICAgICogLSBgc2NyZWVuc2hhcmVgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyIHRvIHJldm9rZSBwZXJtaXNzaW9ucyBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnMgdGhlIHBlcm1pc3Npb25zIHRvIHJldm9rZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmV2b2tlUGVybWlzc2lvbnMgPSBhc3luYyAodXNlcklkLCBwZXJtaXNzaW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zKHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICAgICAgcmV2b2tlX3Blcm1pc3Npb25zOiBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHlvdSB0byBncmFudCBvciByZXZva2UgYSBzcGVjaWZpYyBwZXJtaXNzaW9uIHRvIGEgdXNlciBpbiBhIGNhbGwuIFRoZSBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWMgdG8gdGhlIGNhbGwgZXhwZXJpZW5jZSBhbmQgZG8gbm90IHN1cnZpdmUgdGhlIGNhbGwgaXRzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHJldm9raW5nIGEgcGVybWlzc2lvbiwgdGhpcyBlbmRwb2ludCB3aWxsIGFsc28gbXV0ZSB0aGUgcmVsZXZhbnQgdHJhY2sgZnJvbSB0aGUgdXNlci4gVGhpcyBpcyBzaW1pbGFyIHRvIG11dGluZyBhIHVzZXIgd2l0aCB0aGUgZGlmZmVyZW5jZSB0aGF0IHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gdW5tdXRlIGFmdGVyd2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFN1cHBvcnRlZCBwZXJtaXNzaW9ucyB0aGF0IGNhbiBiZSBncmFudGVkIG9yIHJldm9rZWQ6IGBzZW5kLWF1ZGlvYCwgYHNlbmQtdmlkZW9gIGFuZCBgc2NyZWVuc2hhcmVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgY2FsbC5wZXJtaXNzaW9uc191cGRhdGVkYCBldmVudCBpcyBzZW50IHRvIGFsbCBtZW1iZXJzIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdXNlcl9wZXJtaXNzaW9uc2AsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHRoZSBsaXZlc3RyZWFtaW5nIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgcmVxdWVzdCBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIHRoZSByZXF1ZXN0IHBhcmFtcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ29MaXZlID0gYXN5bmMgKGRhdGEgPSB7fSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9nb19saXZlYCwgZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHRoZSBsaXZlc3RyZWFtaW5nIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wTGl2ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfbGl2ZWAsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyB0aGUgYnJvYWRjYXN0aW5nIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydEhMUyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0YXJ0X2Jyb2FkY2FzdGluZ2AsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHRoZSBicm9hZGNhc3Rpbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BITFMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdG9wX2Jyb2FkY2FzdGluZ2AsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNhbGwgc2V0dGluZ3Mgb3IgY3VzdG9tIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGVzIHRoZSB1cGRhdGVzIHRvIGFwcGx5IHRvIHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGUgPSBhc3luYyAodXBkYXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wYXRjaChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofWAsIHVwZGF0ZXMpO1xuICAgICAgICAgICAgY29uc3QgeyBjYWxsLCBtZW1iZXJzLCBvd25fY2FwYWJpbGl0aWVzIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKG93bl9jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5kcyB0aGUgY2FsbC4gT25jZSB0aGUgY2FsbCBpcyBlbmRlZCwgaXQgY2Fubm90IGJlIHJlLWpvaW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kQ2FsbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L21hcmtfZW5kZWRgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBpbnMgdGhlIGdpdmVuIHNlc3Npb24gdG8gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCB0byBwaW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBpbiA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCB7XG4gICAgICAgICAgICAgICAgcGluOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzTG9jYWxQaW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBpbm5lZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHBhcnRpY2lwYW50cyBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgdG8gdW5waW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucGluID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHtcbiAgICAgICAgICAgICAgICBwaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiB0byB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdCBmb3IgZXZlcnlvbmVcbiAgICAgICAgICogaW4gdGhlIGNhbGwuXG4gICAgICAgICAqIFlvdSBjYW4gZXhlY3V0ZSB0aGlzIG1ldGhvZCBvbmx5IGlmIHlvdSBoYXZlIHRoZSBgcGluLWZvci1ldmVyeW9uZWAgY2FwYWJpbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waW5Gb3JFdmVyeW9uZSA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9waW5gLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHBhcnRpY2lwYW50cyBsaXN0IGZvciBldmVyeW9uZVxuICAgICAgICAgKiBpbiB0aGUgY2FsbC5cbiAgICAgICAgICogWW91IGNhbiBleGVjdXRlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IGhhdmUgdGhlIGBwaW4tZm9yLWV2ZXJ5b25lYCBjYXBhYmlsaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucGluRm9yRXZlcnlvbmUgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdW5waW5gLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVycyB3aXRoIGZpbHRlciBxdWVyeS4gVGhlIHJlc3VsdCB3b24ndCBiZSBzdG9yZWQgaW4gY2FsbCBzdGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHJlcXVlc3RcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVlcnlNZW1iZXJzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvY2FsbC9tZW1iZXJzJywge1xuICAgICAgICAgICAgICAgIC4uLihyZXF1ZXN0IHx8IHt9KSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgdXBkYXRlIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSByZXF1ZXN0IGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxNZW1iZXJzID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L21lbWJlcnNgLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjaGVkdWxlcyBhbiBhdXRvLWRyb3AgdGltZW91dCBiYXNlZCBvbiB0aGUgY2FsbCBzZXR0aW5ncy5cbiAgICAgICAgICogQXBwbGljYWJsZSBvbmx5IGZvciByaW5naW5nIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZUF1dG9Ecm9wID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZHJvcFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUuc2V0dGluZ3MkLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGlmIHRoZSBjYWxsIGlzIG5vdCByaW5naW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuUklOR0lORylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJbk1zID0gc2V0dGluZ3MucmluZy5hdXRvX2NhbmNlbF90aW1lb3V0X21zO1xuICAgICAgICAgICAgICAgIC8vIDAgbWVhbnMgbm8gYXV0by1kcm9wXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJbk1zIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlKHsgcmVhc29uOiAncmluZzogdGltZW91dCcgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBkcm9wIGNhbGwnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0SW5Ncyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgcmVjb3JkaW5ncyBmb3IgdGhlIGN1cnJlbnQgY2FsbCBvciBjYWxsIHNlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBjYWxsU2Vzc2lvbklkYCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHJlY29yZGluZ3MgZm9yIHRoYXQgY2FsbCBzZXNzaW9uLlxuICAgICAgICAgKiBPdGhlcndpc2UsIGFsbCByZWNvcmRpbmdzIGZvciB0aGUgY3VycmVudCBjYWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsU2Vzc2lvbklkIHRoZSBjYWxsIHNlc3Npb24gaWQgdG8gcmV0cmlldmUgcmVjb3JkaW5ncyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnF1ZXJ5UmVjb3JkaW5ncyA9IGFzeW5jIChjYWxsU2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICBsZXQgZW5kcG9pbnQgPSB0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRoO1xuICAgICAgICAgICAgaWYgKGNhbGxTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS8ke2NhbGxTZXNzaW9uSWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoYCR7ZW5kcG9pbnR9L3JlY29yZGluZ3NgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiB0cmFuc2NyaXB0aW9ucyBmb3IgdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNjcmlwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnF1ZXJ5VHJhbnNjcmlwdGlvbnMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3RyYW5zY3JpcHRpb25zYCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBjYWxsIHN0YXRpc3RpY3MgZm9yIGEgcGFydGljdWxhciBjYWxsIHNlc3Npb24gKGhpc3RvcmljYWwpLlxuICAgICAgICAgKiBIZXJlIGBjYWxsU2Vzc2lvbklEYCBpcyBtYW5kYXRvcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjYWxsU2Vzc2lvbklEIHRoZSBjYWxsIHNlc3Npb24gSUQgdG8gcmV0cmlldmUgc3RhdGlzdGljcyBmb3IuXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBjYWxsIHN0YXRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDYWxsU3RhdHMgPSBhc3luYyAoY2FsbFNlc3Npb25JRCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdGF0cy8ke2NhbGxTZXNzaW9uSUR9YDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBjdXN0b20gZXZlbnQgdG8gYWxsIGNhbGwgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZCB0aGUgcGF5bG9hZCB0byBzZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kQ3VzdG9tRXZlbnQgPSBhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vZXZlbnRgLCB7IGN1c3RvbTogcGF5bG9hZCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseURldmljZUNvbmZpZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbWVyYSh7IHNldFN0YXR1czogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLmluaXRNaWMoeyBzZXRTdGF0dXM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBiZWdpbiB0cmFja2luZyB0aGUgZ2l2ZW4gZWxlbWVudCBmb3IgdmlzaWJpbGl0eSBjaGFuZ2VzIHdpdGhpbiB0aGVcbiAgICAgICAgICogY29uZmlndXJlZCB2aWV3cG9ydCBlbGVtZW50IChgY2FsbC5zZXRWaWV3cG9ydGApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byB0cmFjay5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdmlkZW8gbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50VmlzaWJpbGl0eSA9IChlbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHluYXNjYWxlTWFuYWdlci50cmFja0VsZW1lbnRWaXNpYmlsaXR5KGVsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdHJhY2sgYm91bmQgdmlkZW8gZWxlbWVudHMgZm9yIHZpc2liaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLnNldFZpZXdwb3J0KGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPHZpZGVvPiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgcGxheVxuICAgICAgICAgKiB0aGUgY29ycmVjdCB2aWRlbyBzdHJlYW0gZm9yIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmRlciB0aGUgaG9vZCwgaXQgd291bGQgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAgICAgICAgICogYW5kIHVwZGF0ZSB0aGUgc3Vic2NyaXB0aW9uIGFjY29yZGluZ2x5IGluIG9yZGVyIHRvIG9wdGltaXplIHRoZSBiYW5kd2lkdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgXCJ2aWV3cG9ydFwiIGlzIGNvbmZpZ3VyZWQsIHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgICAgICAgKiB0cmFja2VkIGZvciB2aXNpYmlsaXR5IGFuZCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudCB0aGUgdmlkZW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kVmlkZW9FbGVtZW50ID0gKHZpZGVvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9IHRoaXMuZHluYXNjYWxlTWFuYWdlci5iaW5kVmlkZW9FbGVtZW50KHZpZGVvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICAgICAgaWYgKCF1bmJpbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQodW5iaW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5kZWxldGUodW5iaW5kKTtcbiAgICAgICAgICAgICAgICB1bmJpbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8YXVkaW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGF1ZGlvIGVsZW1lbnQgd2lsbFxuICAgICAgICAgKiBwbGF5IHRoZSBjb3JyZWN0IGF1ZGlvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhdWRpb0VsZW1lbnQgdGhlIGF1ZGlvIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBhdWRpby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZEF1ZGlvRWxlbWVudCA9IChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlID0gJ2F1ZGlvVHJhY2snKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmJpbmQgPSB0aGlzLmR5bmFzY2FsZU1hbmFnZXIuYmluZEF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgICAgIGlmICghdW5iaW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKHVuYmluZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuZGVsZXRlKHVuYmluZCk7XG4gICAgICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPGltZz4gZWxlbWVudCB0byB0aGlzIGNhbGwncyB0aHVtYm5haWwgKGlmIGVuYWJsZWQgaW4gc2V0dGluZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IHRoZSBpbWFnZSBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIHRoZSBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kQ2FsbFRodW1ibmFpbEVsZW1lbnQgPSAoaW1hZ2VFbGVtZW50LCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPVxuICAgICAgICAgICAgICAgICAgICBvcHRzLmZhbGxiYWNrSW1hZ2VTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dldHN0cmVhbS5pby9yYW5kb21fc3ZnLz9uYW1lPXgmaWQ9eCc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS50aHVtYm5haWxzJCwgKHRodW1ibmFpbHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRodW1ibmFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdGh1bWJuYWlsVXJsID0gbmV3IFVSTCh0aHVtYm5haWxzLmltYWdlX3VybCk7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3cnLCBTdHJpbmcoaW1hZ2VFbGVtZW50LmNsaWVudFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2gnLCBTdHJpbmcoaW1hZ2VFbGVtZW50LmNsaWVudEhlaWdodCkpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSB0aHVtYm5haWxVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jaWQgPSBgJHt0eXBlfToke2lkfWA7XG4gICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHJpbmdpbmcpO1xuICAgICAgICB0aGlzLndhdGNoaW5nID0gd2F0Y2hpbmc7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gc3RyZWFtQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudFN0b3JlID0gY2xpZW50U3RvcmU7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGggPSBgL2NhbGwvJHt0aGlzLnR5cGV9LyR7dGhpcy5pZH1gO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ0NhbGwnXSk7XG4gICAgICAgIGNvbnN0IGNhbGxUeXBlQ29uZmlnID0gQ2FsbFR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnRTb3J0ZXIgPSBzb3J0UGFydGljaXBhbnRzQnkgfHwgY2FsbFR5cGVDb25maWcub3B0aW9ucy5zb3J0UGFydGljaXBhbnRzQnk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudFNvcnRlcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTb3J0UGFydGljaXBhbnRzQnkocGFydGljaXBhbnRTb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0TWVtYmVycyhtZW1iZXJzIHx8IFtdKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMob3duQ2FwYWJpbGl0aWVzIHx8IFtdKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUocmluZ2luZyA/IENhbGxpbmdTdGF0ZS5SSU5HSU5HIDogQ2FsbGluZ1N0YXRlLklETEUpO1xuICAgICAgICB0aGlzLm9uKCdhbGwnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSB3aXRoIHRoZSBsYXRlc3QgZXZlbnQgZGF0YVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQocmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMsIHRoaXMuc3RhdGUsIHRoaXMuZGlzcGF0Y2hlcikpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRWZmZWN0cygpO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChjcmVhdGVTdWJzY3JpcHRpb24odGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0LnBpcGUoZGVib3VuY2UoKHYpID0+IHRpbWVyKHYudHlwZSkpLCBtYXAkMSgodikgPT4gdi5kYXRhKSksIChzdWJzY3JpcHRpb25zKSA9PiB0aGlzLnNmdUNsaWVudD8udXBkYXRlU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zKSkpO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmFNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLm1pY3JvcGhvbmUgPSBuZXcgTWljcm9waG9uZU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc3BlYWtlciA9IG5ldyBTcGVha2VyTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zY3JlZW5TaGFyZSA9IG5ldyBTY3JlZW5TaGFyZU1hbmFnZXIodGhpcyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyRWZmZWN0cygpIHtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIGhhbmRsZXMgdXBkYXRpbmcgdGhlIHBlcm1pc3Npb25zIGNvbnRleHQgd2hlbiB0aGUgc2V0dGluZ3MgY2hhbmdlLlxuICAgICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5zZXR0aW5ncyQsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5zZXRDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKFxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiB0aGUgdXNlciBwZXJtaXNzaW9ucyBhcmUgbW9kaWZpZWQuXG4gICAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLm93bkNhcGFiaWxpdGllcyQsIChvd25DYXBhYmlsaXRpZXMpID0+IHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGVybWlzc2lvbiBjb250ZXh0LlxuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuc2V0UGVybWlzc2lvbnMob3duQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdWJsaXNoZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHVzZXIgc3RpbGwgaGFzIHB1Ymxpc2hpbmcgcGVybWlzc2lvbnMgYW5kIHN0b3AgcHVibGlzaGluZyBpZiBub3QuXG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uVG9UcmFja1R5cGUgPSB7XG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0VORF9BVURJT106IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPXTogVHJhY2tUeXBlLlZJREVPLFxuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFXTogVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtwZXJtaXNzaW9uLCB0cmFja1R5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHBlcm1pc3Npb25Ub1RyYWNrVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbihwZXJtaXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24gJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucHVibGlzaGVyLmlzUHVibGlzaGluZyh0cmFja1R5cGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5pc0xpdmUodHJhY2tUeXBlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCB0cmFja3MsIHRoZW4gbm90aWZ5IGRldmljZSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcFB1Ymxpc2godHJhY2tUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBFcnJvciBzdG9wcGluZyBwdWJsaXNoICR7dHJhY2tUeXBlfWAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kaXNhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMubG9nZ2VyKCdlcnJvcicsIGBFcnJvciBkaXNhYmxpbmcgY2FtZXJhIGFmdGVyIHBlcm1pc3Npb24gcmV2b2tlZGAsIGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kaXNhYmxlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMubG9nZ2VyKCdlcnJvcicsIGBFcnJvciBkaXNhYmxpbmcgbWljcm9waG9uZSBhZnRlciBwZXJtaXNzaW9uIHJldm9rZWRgLCBlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKFxuICAgICAgICAvLyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gdGhlIHVzZXIgaXMgYmxvY2tlZCBieSB0aGUgY2FsbCBvd25lci5cbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUuYmxvY2tlZFVzZXJJZHMkLCBhc3luYyAoYmxvY2tlZFVzZXJJZHMpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxvY2tlZFVzZXJJZHMgfHwgYmxvY2tlZFVzZXJJZHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVc2VySWQgPSB0aGlzLmN1cnJlbnRVc2VySWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFVzZXJJZCAmJiBibG9ja2VkVXNlcklkcy5pbmNsdWRlcyhjdXJyZW50VXNlcklkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ0xlYXZpbmcgY2FsbCBiZWNhdXNlIG9mIGJlaW5nIGJsb2NrZWQnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxlYXZlKHsgcmVhc29uOiAndXNlciBibG9ja2VkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgICAgLy8gd2F0Y2ggZm9yIGF1dG8gZHJvcCBjYW5jZWxsYXRpb25cbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlJCwgKGNhbGxpbmdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJpbmdpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCB8fFxuICAgICAgICAgICAgICAgIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5JTkcgfHxcbiAgICAgICAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZHJvcFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIFwicmluZ2luZ1wiIG1vZGUgZWZmZWN0cyBhbmQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMucmluZ2luZ1N1YmplY3QsIChpc1JpbmdpbmcpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNSaW5naW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBdXRvRHJvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SSU5HSU5HKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKHJlZ2lzdGVyUmluZ2luZ0NhbGxFdmVudEhhbmRsZXJzKHRoaXMpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjYWxsIGlzIFwicmluZ2luZ1wiIHR5cGUgb2YgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmluZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRWYWx1ZSh0aGlzLnJpbmdpbmdTdWJqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHVzZXIgSUQuXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRVc2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFN0b3JlLmNvbm5lY3RlZFVzZXI/LmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjYWxsIHdhcyBjcmVhdGVkIGJ5IHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICovXG4gICAgZ2V0IGlzQ3JlYXRlZEJ5TWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNyZWF0ZWRCeT8uaWQgPT09IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdENhbWVyYShvcHRpb25zKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBpbiBwcm9ncmVzcyBjYW1lcmEgb3BlcmF0aW9uXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYS5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbWVyYS5lbmFibGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYS5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZGlzYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubG9jYWxQYXJ0aWNpcGFudD8udmlkZW9TdHJlYW0gfHxcbiAgICAgICAgICAgICF0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5oYXNQZXJtaXNzaW9uKCdzZW5kLXZpZGVvJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgY2FtZXJhIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCB5ZXQgc2V0XG4gICAgICAgIGlmICghdGhpcy5jYW1lcmEuc3RhdGUuZGlyZWN0aW9uICYmICF0aGlzLmNhbWVyYS5zdGF0ZS5zZWxlY3RlZERldmljZSkge1xuICAgICAgICAgICAgbGV0IGRlZmF1bHREaXJlY3Rpb24gPSAnZnJvbnQnO1xuICAgICAgICAgICAgY29uc3QgYmFja2VuZFNldHRpbmcgPSB0aGlzLnN0YXRlLnNldHRpbmdzPy52aWRlby5jYW1lcmFfZmFjaW5nO1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRTZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpcmVjdGlvbiA9IGJhY2tlbmRTZXR0aW5nID09PSAnZnJvbnQnID8gJ2Zyb250JyA6ICdiYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnNldERpcmVjdGlvbihkZWZhdWx0RGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGFyZ2V0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLnRhcmdldF9yZXNvbHV0aW9uO1xuICAgICAgICBpZiAodGFyZ2V0UmVzb2x1dGlvbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuc2VsZWN0VGFyZ2V0UmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXRTdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggYWxyZWFkeSB0aGF0IHdhcyBzZXQgYmVmb3JlIHdlIGpvaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc3RhdGUubWVkaWFTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wdWJsaXNoZXI/LmlzUHVibGlzaGluZyhUcmFja1R5cGUuVklERU8pKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVmlkZW9TdHJlYW0odGhpcy5jYW1lcmEuc3RhdGUubWVkaWFTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkQ29kZWM6IHRoaXMuY2FtZXJhLnByZWZlcnJlZENvZGVjLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgY2FtZXJhIGlmIGJhY2tlbmQgY29uZmlnIHNwZWNpZmllcywgYW5kIHRoZXJlIGlzIG5vIGxvY2FsIHNldHRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYS5zdGF0ZS5zdGF0dXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLmNhbWVyYV9kZWZhdWx0X29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW5pdE1pYyhvcHRpb25zKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBpbiBwcm9ncmVzcyBtaWMgb3BlcmF0aW9uXG4gICAgICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuZW5hYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmVuYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmRpc2FibGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxvY2FsUGFydGljaXBhbnQ/LmF1ZGlvU3RyZWFtIHx8XG4gICAgICAgICAgICAhdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbignc2VuZC1hdWRpbycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2V0U3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBQdWJsaXNoIG1lZGlhIHN0cmVhbSB0aGF0IHdhcyBzZXQgYmVmb3JlIHdlIGpvaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWljcm9waG9uZS5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5BVURJTykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBdWRpb1N0cmVhbSh0aGlzLm1pY3JvcGhvbmUuc3RhdGUubWVkaWFTdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgbWljIGlmIGJhY2tlbmQgY29uZmlnIHNwZWNpZmllcywgYW5kIHRoZXJlIGlzIG5vIGxvY2FsIHNldHRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldHRpbmdzPy5hdWRpby5taWNfZGVmYXVsdF9vbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubWljcm9waG9uZS5lbmFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSW5zaWdodE1ldHJpY3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMud3NUb3RhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgdGhpcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmluc3RhbmNlQ2xpZW50SWQgPSByYW5kb21JZCgpO1xuICAgIH1cbn1cbi8qKlxuICogcG9zdEluc2lnaHRzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGJ5IGVuZCB1c2VycyBkaXJlY3RseSB3aXRoaW4gY2hhdCBhcHBsaWNhdGlvbiwgYW5kIHRodXMgaXMga2VwdCBpc29sYXRlZFxuICogZnJvbSBhbGwgdGhlIGNsaWVudC9jb25uZWN0aW9uIGNvZGUvbG9naWMuXG4gKlxuICogQHBhcmFtIGluc2lnaHRUeXBlXG4gKiBAcGFyYW0gaW5zaWdodHNcbiAqL1xuY29uc3QgcG9zdEluc2lnaHRzID0gYXN5bmMgKGluc2lnaHRUeXBlLCBpbnNpZ2h0cykgPT4ge1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYGh0dHBzOi8vY2hhdC1pbnNpZ2h0cy5nZXRzdHJlYW0uaW8vaW5zaWdodHMvJHtpbnNpZ2h0VHlwZX1gLCBpbnNpZ2h0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKChpICsgMSkgKiAzMDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5mdW5jdGlvbiBidWlsZFdzRmF0YWxJbnNpZ2h0KGNvbm5lY3Rpb24sIGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIC4uLmJ1aWxkV3NCYXNlSW5zaWdodChjb25uZWN0aW9uKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRXc0Jhc2VJbnNpZ2h0KGNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gY29ubmVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkeV9zdGF0ZTogY29ubmVjdGlvbi53cz8ucmVhZHlTdGF0ZSxcbiAgICAgICAgdXJsOiBjb25uZWN0aW9uLl9idWlsZFVybCgpLFxuICAgICAgICBhcGlfa2V5OiBjbGllbnQua2V5LFxuICAgICAgICBzdGFydF90czogY2xpZW50Lmluc2lnaHRNZXRyaWNzLmNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCxcbiAgICAgICAgZW5kX3RzOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgYXV0aF90eXBlOiBjbGllbnQuZ2V0QXV0aFR5cGUoKSxcbiAgICAgICAgdG9rZW46IGNsaWVudC50b2tlbk1hbmFnZXIudG9rZW4sXG4gICAgICAgIHVzZXJfaWQ6IGNsaWVudC51c2VySUQsXG4gICAgICAgIHVzZXJfZGV0YWlsczogY2xpZW50Ll91c2VyLFxuICAgICAgICAvLyBkZXZpY2U6IGNsaWVudC5vcHRpb25zLmRldmljZSxcbiAgICAgICAgZGV2aWNlOiAnYnJvd3NlcicsXG4gICAgICAgIGNsaWVudF9pZDogY29ubmVjdGlvbi5jb25uZWN0aW9uSUQsXG4gICAgICAgIHdzX2RldGFpbHM6IGNvbm5lY3Rpb24ud3MsXG4gICAgICAgIHdzX2NvbnNlY3V0aXZlX2ZhaWx1cmVzOiBjbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzLFxuICAgICAgICB3c190b3RhbF9mYWlsdXJlczogY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzVG90YWxGYWlsdXJlcyxcbiAgICAgICAgcmVxdWVzdF9pZDogY29ubmVjdGlvbi5yZXF1ZXN0SUQsXG4gICAgICAgIG9ubGluZTogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3I/Lm9uTGluZSA6IG51bGwsXG4gICAgICAgIHVzZXJfYWdlbnQ6IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yPy51c2VyQWdlbnQgOiBudWxsLFxuICAgICAgICBpbnN0YW5jZV9jbGllbnRfaWQ6IGNsaWVudC5pbnNpZ2h0TWV0cmljcy5pbnN0YW5jZUNsaWVudElkLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFdzU3VjY2Vzc0FmdGVyRmFpbHVyZUluc2lnaHQoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBidWlsZFdzQmFzZUluc2lnaHQoY29ubmVjdGlvbik7XG59XG5cbi8vIFR5cGUgZ3VhcmRzIHRvIGNoZWNrIFdlYlNvY2tldCBlcnJvciB0eXBlXG5jb25zdCBpc0Nsb3NlRXZlbnQgPSAocmVzKSA9PiByZXMuY29kZSAhPT0gdW5kZWZpbmVkO1xuY29uc3QgaXNFcnJvckV2ZW50ID0gKHJlcykgPT4gcmVzLmVycm9yICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIFN0YWJsZVdTQ29ubmVjdGlvbiAtIEEgV1MgY29ubmVjdGlvbiB0aGF0IHJlY29ubmVjdHMgdXBvbiBmYWlsdXJlLlxuICogLSB0aGUgYnJvd3NlciB3aWxsIHNvbWV0aW1lcyByZXBvcnQgdGhhdCB5b3UncmUgb25saW5lIG9yIG9mZmxpbmVcbiAqIC0gdGhlIFdTIGNvbm5lY3Rpb24gY2FuIGJyZWFrIGFuZCBmYWlsICh0aGVyZSBpcyBhIDMwcyBoZWFsdGggY2hlY2spXG4gKiAtIHNvbWV0aW1lcyB5b3VyIFdTIGNvbm5lY3Rpb24gd2lsbCBzZWVtIHRvIHdvcmsgd2hpbGUgdGhlIHVzZXIgaXMgaW4gZmFjdCBvZmZsaW5lXG4gKiAtIHRvIHNwZWVkIHVwIG9ubGluZS9vZmZsaW5lIGRldGVjdGlvbiB5b3UgY2FuIHVzZSB0aGUgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnKTtcbiAqXG4gKiBUaGVyZSBhcmUgNCB3YXlzIGluIHdoaWNoIGEgY29ubmVjdGlvbiBjYW4gYmVjb21lIHVuaGVhbHRoeTpcbiAqIC0gd2Vic29ja2V0Lm9uZXJyb3IgaXMgY2FsbGVkXG4gKiAtIHdlYnNvY2tldC5vbmNsb3NlIGlzIGNhbGxlZFxuICogLSB0aGUgaGVhbHRoIGNoZWNrIGZhaWxzIGFuZCBubyBldmVudCBpcyByZWNlaXZlZCBmb3IgfjQwIHNlY29uZHNcbiAqIC0gdGhlIGJyb3dzZXIgaW5kaWNhdGVzIHRoZSBjb25uZWN0aW9uIGlzIG5vdyBvZmZsaW5lXG4gKlxuICogVGhlcmUgYXJlIDIgYXNzdW1wdGlvbnMgd2UgbWFrZSBhYm91dCB0aGUgc2VydmVyOlxuICogLSBzdGF0ZSBjYW4gYmUgcmVjb3ZlcmVkIGJ5IHF1ZXJ5aW5nIHRoZSBjaGFubmVsIGFnYWluXG4gKiAtIGlmIHRoZSBzZXJ2ZXJzIGZhaWxzIHRvIHB1Ymxpc2ggYSBtZXNzYWdlIHRvIHRoZSBjbGllbnQsIHRoZSBXUyBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZFxuICovXG5jbGFzcyBTdGFibGVXU0Nvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9sb2cgPSAobXNnLCBleHRyYSA9IHt9LCBsZXZlbCA9ICdpbmZvJykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyKGxldmVsLCAnY29ubmVjdGlvbjonICsgbXNnLCB7XG4gICAgICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDbGllbnQgPSAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyBhbmQgcmV0dXJucyB0aGUgdXJsIGZvciB3ZWJzb2NrZXQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHVybCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2J1aWxkVXJsID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgLy8gY29uc3QgcXMgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5jbGllbnQuX2J1aWxkV1NQYXlsb2FkKHRoaXMucmVxdWVzdElEKSk7XG4gICAgICAgICAgICAvLyBwYXJhbXMuc2V0KCdqc29uJywgcXMpO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgnYXBpX2tleScsIHRoaXMuY2xpZW50LmtleSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdzdHJlYW0tYXV0aC10eXBlJywgdGhpcy5jbGllbnQuZ2V0QXV0aFR5cGUoKSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdYLVN0cmVhbS1DbGllbnQnLCB0aGlzLmNsaWVudC5nZXRVc2VyQWdlbnQoKSk7XG4gICAgICAgICAgICAvLyBwYXJhbXMuYXBwZW5kKCdhdXRob3JpemF0aW9uJywgdGhpcy5jbGllbnQuX2dldFRva2VuKCkhKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmNsaWVudC53c0Jhc2VVUkx9L2Nvbm5lY3Q/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb25saW5lU3RhdHVzQ2hhbmdlZCAtIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgY29ubmVjdHMgb3IgZGlzY29ubmVjdHMgZnJvbSB0aGUgaW50ZXJuZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IHdpdGggdHlwZSBvbmxpbmUgb3Igb2ZmbGluZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0dXNDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ29mZmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayB0aGUgY29ubmVjdGlvbiBhcyBkb3duXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdvbmxpbmVTdGF0dXNDaGFuZ2VkKCkgLSBTdGF0dXMgY2hhbmdpbmcgdG8gb2ZmbGluZScpO1xuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgYXBwIGlzIG9mZmxpbmUgc28gZGlzcGF0Y2ggdGhlIHVuaGVhbHRoeSBjb25uZWN0aW9uIGV2ZW50IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdvbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgcmlnaHQgbm93Li4uXG4gICAgICAgICAgICAgICAgLy8gV2UgY2hlY2sgdGhpcy5pc0hlYWx0aHksIG5vdCBzdXJlIGlmIGl0J3MgYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gc21hcnQgdG8gY3JlYXRlIGEgbmV3IFdTIGNvbm5lY3Rpb24gaWYgdGhlIG9sZCBvbmUgaXMgc3RpbGwgdXAgYW5kIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB3ZSBkaWRuJ3QgbWlzcyBhbnkgbWVzc2FnZXMsIHNvIHRoaXMgcHJvY2VzcyBpcyBqdXN0IGV4cGVuc2l2ZSBhbmQgbm90IG5lZWRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYG9ubGluZVN0YXR1c0NoYW5nZWQoKSAtIFN0YXR1cyBjaGFuZ2luZyB0byBvbmxpbmUuIGlzSGVhbHRoeTogJHt0aGlzLmlzSGVhbHRoeX1gKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCh7IGludGVydmFsOiAxMCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25vcGVuID0gKHdzSUQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzSUQgIT09IHdzSUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IHRoaXMuY2xpZW50LnVzZXI7XG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIoJ2Vycm9yJywgYFVzZXIgbm90IHNldCwgY2FuJ3QgY29ubmVjdCB0byBXU2ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jbGllbnQuX2dldFRva2VuKCk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyKCdlcnJvcicsIGBUb2tlbiBub3Qgc2V0LCBjYW4ndCBjb25uZWN0IGF1dGhlbnRpY2F0ZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIHVzZXJfZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXNlci5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tOiB1c2VyLmN1c3RvbSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25TZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud3M/LnNlbmQoSlNPTi5zdHJpbmdpZnkoYXV0aE1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnb25vcGVuKCkgLSBvbm9wZW4gY2FsbGJhY2snLCB7IHdzSUQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25tZXNzYWdlID0gKHdzSUQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnb25tZXNzYWdlKCkgLSBvbm1lc3NhZ2UgY2FsbGJhY2snLCB7IGV2ZW50LCB3c0lEIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIC8vIHdlIHdhaXQgdGlsbCB0aGUgZmlyc3QgbWVzc2FnZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gb3Blbi5cbiAgICAgICAgICAgIC8vIHRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBhdXRoIGVycm9ycyBhbmQgc2ltaWxhciBlcnJvcnMgdHJpZ2dlciBhIHdzLm9ub3BlbiBhbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoYXQgYSB3cy5vbmNsb3NlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVzb2x2ZWQgJiYgZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLmVycm9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoZSB0eXBlcyBvZiBfZXJyb3JGcm9tV1NFdmVudCBhcmUgaW5jb3JyZWN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQoZGF0YSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50Li5cbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmXG4gICAgICAgICAgICAgICAgKGRhdGEudHlwZSA9PT0gJ2hlYWx0aC5jaGVjaycgfHwgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5vaycpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgaGVhbHRoLWNoZWNrIHNob3VsZCBjb21lIGZyb20gdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVOZXh0UGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5vaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5lcnJvcicgJiYgZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZGF0YS5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGVhbHRoeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gV1MgZmFpbHVyZSBkdWUgdG8gZXhwaXJlZCB0b2tlbiwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlbG9hZCB0b2tlbiBhbmQgcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCh7IHJlZnJlc2hUb2tlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jbG9zZSA9ICh3c0lELCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9sb2coJ29uY2xvc2UoKSAtIG9uY2xvc2UgY2FsbGJhY2sgLSAnICsgZXZlbnQuY29kZSwgeyBldmVudCwgd3NJRCB9KTtcbiAgICAgICAgICAgIGlmIChldmVudC5jb2RlID09PSBLbm93bkNvZGVzLldTX0NMT1NFRF9TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHBlcm1hbmVudCBlcnJvciByYWlzZWQgYnkgc3RyZWFtLi5cbiAgICAgICAgICAgICAgICAvLyB1c3VhbGx5IGNhdXNlZCBieSBpbnZhbGlkIGF1dGggZGV0YWlsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBXUyBjb25uZWN0aW9uIHJlamVjdCB3aXRoIGVycm9yICR7ZXZlbnQucmVhc29ufWApO1xuICAgICAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9IGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZXZlbnQuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci53YXNDbGVhbiA9IGV2ZW50Lndhc0NsZWFuO1xuICAgICAgICAgICAgICAgIGVycm9yLnRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/LihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBvbmNsb3NlKCkgLSBXUyBjb25uZWN0aW9uIHJlamVjdCB3aXRoIGVycm9yICR7ZXZlbnQucmVhc29ufWAsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWFsdGgoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQcm9taXNlPy4odGhpcy5fZXJyb3JGcm9tV1NFdmVudChldmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgb25jbG9zZSgpIC0gV1MgY29ubmVjdGlvbiBjbG9zZWQuIENhbGxpbmcgcmVjb25uZWN0IC4uLmAsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVjb25uZWN0IGlmIGl0cyBhbiBhYm5vcm1hbCBmYWlsdXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25lcnJvciA9ICh3c0lELCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMudG90YWxGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/Lih0aGlzLl9lcnJvckZyb21XU0V2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLl9sb2coYG9uZXJyb3IoKSAtIFdTIGNvbm5lY3Rpb24gcmVzdWx0ZWQgaW50byBlcnJvcmAsIHsgZXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9zZXRIZWFsdGggLSBTZXRzIHRoZSBjb25uZWN0aW9uIHRvIGhlYWx0aHkgb3IgdW5oZWFsdGh5LlxuICAgICAgICAgKiBCcm9hZGNhc3RzIGFuIGV2ZW50IGluIGNhc2UgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGVhbHRoeSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeSBvciBub3RcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXNwYXRjaEltbWVkaWF0ZWx5IGJvb2xlYW4gaW5kaWNhdGluZyB0byBkaXNwYXRjaCBldmVudCBpbW1lZGlhdGVseSBldmVuIGlmIHRoZSBjb25uZWN0aW9uIGlzIHVuaGVhbHRoeVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2V0SGVhbHRoID0gKGhlYWx0aHksIGRpc3BhdGNoSW1tZWRpYXRlbHkgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGhlYWx0aHkgPT09IHRoaXMuaXNIZWFsdGh5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gaGVhbHRoeTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhbHRoeSB8fCBkaXNwYXRjaEltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICBvbmxpbmU6IHRoaXMuaXNIZWFsdGh5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUsIHdhaXQgZmV3IHNlY29uZHMgYW5kIGZpcmUgYW5kIGV2ZW50IGlmIHN0aWxsIG9mZmxpbmVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhbHRoeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi5jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgb25saW5lOiB0aGlzLmlzSGVhbHRoeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX2Vycm9yRnJvbVdTRXZlbnQgLSBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCBmb3IgdGhlIFdTIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lcnJvckZyb21XU0V2ZW50ID0gKGV2ZW50LCBpc1dTRmFpbHVyZSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGV2ZW50LmNvZGU7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9ICd1bmtub3duJztcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3JFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gZXZlbnQuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gZXZlbnQuZXJyb3IuU3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXZlbnQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEtlZXBpbmcgdGhpcyBgd2FybmAgbGV2ZWwgbG9nLCB0byBhdm9pZCBjbHV0dGVyaW5nIG9mIGVycm9yIGxvZ3MgZnJvbSB3cyBmYWlsdXJlcy5cbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Vycm9yRnJvbVdTRXZlbnQoKSAtIFdTIGZhaWxlZCB3aXRoIGNvZGUgJHtjb2RlfWAsIHsgZXZlbnQgfSwgJ3dhcm4nKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBXUyBmYWlsZWQgd2l0aCBjb2RlICR7Y29kZX0gYW5kIHJlYXNvbiAtICR7bWVzc2FnZX1gKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGF0dXNDb2RlIGRvZXMgbm90IGV4aXN0IG9uIGFueSBldmVudCB0eXBlcyBidXQgaGFzIGJlZW4gbGVmdFxuICAgICAgICAgICAgICogYXMgaXMgdG8gcHJlc2VydmUgSlMgZnVuY3Rpb25hbGl0eSBkdXJpbmcgdGhlIFRTIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVycm9yLlN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICAgICAgZXJyb3IuaXNXU0ZhaWx1cmUgPSBpc1dTRmFpbHVyZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9zZXR1cFByb21pc2UgLSBzZXRzIHVwIHRoZSB0aGlzLmNvbm5lY3RPcGVuIHByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvblByb21pc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHdzLm9wZW4gaXMgY2FsbGVkICovXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcGVuID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGVzIGEgbmV4dCBoZWFsdGggY2hlY2sgcGluZyBmb3Igd2Vic29ja2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZU5leHRQaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMwIHNlY29uZHMgaXMgdGhlIHJlY29tbWVuZGVkIGludGVydmFsIChtZXNzZW5nZXIgdXNlcyB0aGlzKVxuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kIHRoZSBoZWFsdGhjaGVjay4uLiwgc2VydmVyIHJlcGxpZXMgd2l0aCBhIGhlYWx0aCBjaGVjayBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbeyB0eXBlOiAnaGVhbHRoLmNoZWNrJywgY2xpZW50X2lkOiB0aGlzLmNsaWVudC5jbGllbnRJRCB9XTtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gc2VuZCBvbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3M/LnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciB3aWxsIGFscmVhZHkgYmUgZGV0ZWN0ZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5waW5nSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgLSBzY2hlZHVsZXMgYSBjaGVjayBmb3IgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gbGFzdCByZWNlaXZlZCBldmVudCBhbmQgbm93LlxuICAgICAgICAgKiBJZiB0aGUgZGlmZmVyZW5jZSBpcyBtb3JlIHRoYW4gMzUgc2Vjb25kcywgaXQgbWVhbnMgb3VyIGhlYWx0aCBjaGVjayBsb2dpYyBoYXMgZmFpbGVkIGFuZCB3ZWJzb2NrZXQgbmVlZHNcbiAgICAgICAgICogdG8gYmUgcmVjb25uZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0RXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgbm93LmdldFRpbWUoKSAtIHRoaXMubGFzdEV2ZW50LmdldFRpbWUoKSA+IHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ3NjaGVkdWxlQ29ubmVjdGlvbkNoZWNrIC0gZ29pbmcgdG8gcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEhlYWx0aChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKiogY29uc2VjdXRpdmUgZmFpbHVyZXMgaW5mbHVlbmNlIHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZW91dCAqL1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICAvKioga2VlcCB0cmFjayBvZiB0aGUgdG90YWwgbnVtYmVyIG9mIGZhaWx1cmVzICovXG4gICAgICAgIHRoaXMudG90YWxGYWlsdXJlcyA9IDA7XG4gICAgICAgIC8qKiBXZSBvbmx5IG1ha2UgMSBhdHRlbXB0IHRvIHJlY29ubmVjdCBhdCB0aGUgc2FtZSB0aW1lLi4gKi9cbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRydWUgYWZ0ZXIgdGhlIGF1dGggcGF5bG9hZCBpcyBzZW50IHRvIHRoZSBzZXJ2ZXIgKi9cbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvblNlbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvIGF2b2lkIHJlY29ubmVjdCBpZiBjbGllbnQgaXMgZGlzY29ubmVjdGVkICovXG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbm5lY3Rpb24gcHJvbWlzZSBpcyByZXNvbHZlZCAqL1xuICAgICAgICB0aGlzLmlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgd2UgaGF2ZSBhIHdvcmtpbmcgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyICovXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBJbmNyZW1lbnRlZCB3aGVuIGEgbmV3IFdTIGNvbm5lY3Rpb24gaXMgbWFkZSAqL1xuICAgICAgICB0aGlzLndzSUQgPSAxO1xuICAgICAgICAvKiogU3RvcmUgdGhlIGxhc3QgZXZlbnQgdGltZSBmb3IgaGVhbHRoIGNoZWNrcyAqL1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKiBTZW5kIGEgaGVhbHRoIGNoZWNrIG1lc3NhZ2UgZXZlcnkgMjUgc2Vjb25kcyAqL1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IDI1ICogMTAwMDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0ID0gdGhpcy5waW5nSW50ZXJ2YWwgKyAxMCAqIDEwMDA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyh0aGlzLm9ubGluZVN0YXR1c0NoYW5nZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IC0gQ29ubmVjdCB0byB0aGUgV1MgVVJMXG4gICAgICogdGhlIGRlZmF1bHQgMTVzIHRpbWVvdXQgYWxsb3dzIGJldHdlZW4gMn4zIHRyaWVzXG4gICAgICogQHJldHVybiB7Q29ubmVjdEFQSVJlc3BvbnNlPENvbm5lY3RlZEV2ZW50Pn0gUHJvbWlzZSB0aGF0IGNvbXBsZXRlcyBvbmNlIHRoZSBmaXJzdCBoZWFsdGggY2hlY2sgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QodGltZW91dCA9IDE1MDAwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFlvdSd2ZSBjYWxsZWQgY29ubmVjdCB0d2ljZSwgY2FuIG9ubHkgYXR0ZW1wdCAxIGNvbm5lY3Rpb24gYXQgdGhlIHRpbWVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoZWFsdGhDaGVjayA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sb2coYGNvbm5lY3QoKSAtIEVzdGFibGlzaGVkIHdzIGNvbm5lY3Rpb24gd2l0aCBoZWFsdGhjaGVjazogJHtoZWFsdGhDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gV1MgZmFpbHVyZSBkdWUgdG8gZXhwaXJlZCB0b2tlbiwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlbG9hZCB0b2tlbiBhbmQgcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KHsgcmVmcmVzaFRva2VuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IuaXNXU0ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQVBJIHJlamVjdGVkIHRoZSBjb25uZWN0aW9uIGFuZCB3ZSBzaG91bGQgbm90IHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgU3RhdHVzQ29kZTogZXJyb3IuU3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1dTRmFpbHVyZTogZXJyb3IuaXNXU0ZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhaXRGb3JIZWFsdGh5KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfd2FpdEZvckhlYWx0aHkgcG9sbHMgdGhlIHByb21pc2UgY29ubmVjdGlvbiB0byBzZWUgaWYgaXRzIHJlc29sdmVkIHVudGlsIGl0IHRpbWVzIG91dFxuICAgICAqIHRoZSBkZWZhdWx0IDE1cyB0aW1lb3V0IGFsbG93cyBiZXR3ZWVuIDJ+MyB0cmllc1xuICAgICAqIEBwYXJhbSB0aW1lb3V0IGR1cmF0aW9uKG1zKVxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0Rm9ySGVhbHRoeSh0aW1lb3V0ID0gMTUwMDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gNTA7IC8vIG1zXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGltZW91dDsgaSArPSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdGlvbk9wZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXR1c0NvZGU6IGVycm9yLlN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlOiBlcnJvci5pc1dTRmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBTdGF0dXNDb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luaXRpYWwgV1MgY29ubmVjdGlvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICBpc1dTRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzY29ubmVjdCAtIERpc2Nvbm5lY3QgdGhlIGNvbm5lY3Rpb24gYW5kIGRvZXNuJ3QgcmVjb3Zlci4uLlxuICAgICAqXG4gICAgICovXG4gICAgZGlzY29ubmVjdCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gQ2xvc2luZyB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gZm9yIHdzSUQgJHt0aGlzLndzSUR9YCk7XG4gICAgICAgIHRoaXMud3NJRCArPSAxO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gc3RhcnQgYnkgcmVtb3ZpbmcgYWxsIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMub25saW5lU3RhdHVzQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgIC8vIHJlbW92ZSB3cyBoYW5kbGVycy4uLlxuICAgICAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlbW92ZUFsbExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy53cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNDbG9zZWRQcm9taXNlO1xuICAgICAgICAvLyBhbmQgZmluYWxseSBjbG9zZS4uLlxuICAgICAgICAvLyBBc3NpZ25pbmcgdG8gbG9jYWwgaGVyZSBiZWNhdXNlIHdlIHdpbGwgcmVtb3ZlIGl0IGZyb20gdGhpcyBiZWZvcmUgdGhlXG4gICAgICAgIC8vIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgICAgIGNvbnN0IHsgd3MgfSA9IHRoaXM7XG4gICAgICAgIGlmICh3cyAmJiB3cy5jbG9zZSAmJiB3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOKSB7XG4gICAgICAgICAgICBpc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSByZXNvbHZpbmcgaXNDbG9zZWRQcm9taXNlICR7ZXZlbnQgPyAnd2l0aCcgOiAnd2l0aG91dCd9IGNsb3NlIGZyYW1lYCwgeyBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3Mub25jbG9zZSA9IG9uY2xvc2U7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB3ZSBkb24ndCByZWNlaXZlIGNsb3NlIGZyYW1lIHdlYnNvY2tldCBzZXJ2ZXIgaW4gdGltZSxcbiAgICAgICAgICAgICAgICAvLyBsZXRzIG5vdCB3YWl0IGZvciBtb3JlIHRoYW4gMSBzZWNvbmQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChvbmNsb3NlLCB0aW1lb3V0ICE9IG51bGwgPyB0aW1lb3V0IDogMTAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpYCk7XG4gICAgICAgICAgICB3cy5jbG9zZShLbm93bkNvZGVzLldTX0NMT1NFRF9TVUNDRVNTLCAnTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIHdzIGNvbm5lY3Rpb24gZG9lc24ndCBleGlzdCBvciBpdCBpcyBhbHJlYWR5IGNsb3NlZC5gKTtcbiAgICAgICAgICAgIGlzQ2xvc2VkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLndzO1xuICAgICAgICByZXR1cm4gaXNDbG9zZWRQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfY29ubmVjdCAtIENvbm5lY3QgdG8gdGhlIFdTIGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDb25uZWN0QVBJUmVzcG9uc2U8Q29ubmVjdGVkRXZlbnQ+fSBQcm9taXNlIHRoYXQgY29tcGxldGVzIG9uY2UgdGhlIGZpcnN0IGhlYWx0aCBjaGVjayBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYXN5bmMgX2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fFxuICAgICAgICAgICAgKHRoaXMuaXNEaXNjb25uZWN0ZWQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5lbmFibGVXU0ZhbGxiYWNrKSlcbiAgICAgICAgICAgIHJldHVybjsgLy8gc2ltcGx5IGlnbm9yZSBfY29ubmVjdCBpZiBpdCdzIGN1cnJlbnRseSB0cnlpbmcgdG8gY29ubmVjdFxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdElEID0gcmFuZG9tSWQoKTtcbiAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3MuY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBpc1Rva2VuUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIHdhaXRpbmcgZm9yIHRva2VuYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIudG9rZW5SZWFkeSgpO1xuICAgICAgICAgICAgaXNUb2tlblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gdG9rZW4gcHJvdmlkZXIgaGFzIGZhaWxlZCBiZWZvcmUsIHNvIHRyeSBhZ2FpblxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzVG9rZW5SZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIHRva2VuUHJvdmlkZXIgZmFpbGVkIGJlZm9yZSwgc28gZ29pbmcgdG8gcmV0cnlgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXR1cENvbm5lY3Rpb25Qcm9taXNlKCk7XG4gICAgICAgICAgICBjb25zdCB3c1VSTCA9IHRoaXMuX2J1aWxkVXJsKCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coYF9jb25uZWN0KCkgLSBDb25uZWN0aW5nIHRvICR7d3NVUkx9YCwge1xuICAgICAgICAgICAgICAgIHdzVVJMLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJRDogdGhpcy5yZXF1ZXN0SUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHdzVVJMKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbm9wZW4uYmluZCh0aGlzLCB0aGlzLndzSUQpO1xuICAgICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbmNsb3NlLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMub25lcnJvci5iaW5kKHRoaXMsIHRoaXMud3NJRCk7XG4gICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25tZXNzYWdlLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uT3BlbjtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IHJlc3BvbnNlLmNvbm5lY3Rpb25faWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucmVzb2x2ZUNvbm5lY3Rpb25JZD8uKHRoaXMuY29ubmVjdGlvbklEKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RJbnNpZ2h0cygnd3Nfc3VjY2Vzc19hZnRlcl9mYWlsdXJlJywgYnVpbGRXc1N1Y2Nlc3NBZnRlckZhaWx1cmVJbnNpZ2h0KHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl9sb2coYF9jb25uZWN0KCkgLSBFcnJvciAtIGAsIGVycik7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzQ29uc2VjdXRpdmVGYWlsdXJlcysrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzVG90YWxGYWlsdXJlcysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2lnaHRzID0gYnVpbGRXc0ZhdGFsSW5zaWdodCh0aGlzLCBjb252ZXJ0RXJyb3JUb0pzb24oZXJyKSk7XG4gICAgICAgICAgICAgICAgcG9zdEluc2lnaHRzPy4oJ3dzX2ZhdGFsJywgaW5zaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnQucmVqZWN0Q29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBfcmVjb25uZWN0IC0gUmV0cnkgdGhlIGNvbm5lY3Rpb24gdG8gV1MgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7eyBpbnRlcnZhbD86IG51bWJlcjsgcmVmcmVzaFRva2VuPzogYm9vbGVhbiB9fSBvcHRpb25zIEZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqIC0gYGludGVydmFsYFx0e2ludH1cdFx0XHRudW1iZXIgb2YgbXMgdGhhdCBmdW5jdGlvbiBzaG91bGQgd2FpdCBiZWZvcmUgcmVjb25uZWN0aW5nXG4gICAgICogLSBgcmVmcmVzaFRva2VuYCB7Ym9vbGVhbn1cdHJlbG9hZC9yZWZyZXNoIHVzZXIgdG9rZW4gYmUgcmVmcmVzaGVkIGJlZm9yZSBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb25uZWN0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEluaXRpYXRpbmcgdGhlIHJlY29ubmVjdCcpO1xuICAgICAgICAvLyBvbmx5IGFsbG93IDEgY29ubmVjdGlvbiBhdCB0aGUgdGltZVxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcgfHwgdGhpcy5pc0hlYWx0aHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gQWJvcnQgKDEpIHNpbmNlIGFscmVhZHkgY29ubmVjdGluZyBvciBoZWFsdGh5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb25uZWN0IGluIGNhc2Ugb2Ygb24gZXJyb3Igb3Igb24gY2xvc2VcbiAgICAgICAgLy8gYWxzbyByZWNvbm5lY3QgaWYgdGhlIGhlYWx0aCBjaGVjayBjeWNsZSBmYWlsc1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvbm5lY3QsIG9yIHRyeSBhZ2FpbiBhZnRlciBhIGxpdHRsZSB3aGlsZS4uLlxuICAgICAgICBhd2FpdCBzbGVlcChpbnRlcnZhbCk7XG4gICAgICAgIC8vIENoZWNrIG9uY2UgYWdhaW4gaWYgYnkgc29tZSBvdGhlciBjYWxsIHRvIF9yZWNvbm5lY3QgaXMgYWN0aXZlIG9yIGNvbm5lY3Rpb24gaXNcbiAgICAgICAgLy8gYWxyZWFkeSByZXN0b3JlZCwgdGhlbiBubyBuZWVkIHRvIHByb2NlZWQuXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fCB0aGlzLmlzSGVhbHRoeSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBBYm9ydCAoMikgc2luY2UgYWxyZWFkeSBjb25uZWN0aW5nIG9yIGhlYWx0aHknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gQWJvcnQgKDMpIHNpbmNlIGRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIERlc3Ryb3lpbmcgY3VycmVudCBXUyBjb25uZWN0aW9uJyk7XG4gICAgICAgIC8vIGNsZWFudXAgdGhlIG9sZCBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmxvYWRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdhaXRpbmcgZm9yIHJlY292ZXJDYWxsQmFjaycpO1xuICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy5jbGllbnQucmVjb3ZlclN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEZpbmlzaGVkIHJlY292ZXJDYWxsQmFjaycpO1xuICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBLbm93bkNvZGVzLlRPS0VOX0VYUElSRUQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdTIGZhaWx1cmUgZHVlIHRvIGV4cGlyZWQgdG9rZW4sIHNvIGdvaW5nIHRvIHRyeSB0byByZWxvYWQgdG9rZW4gYW5kIHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3QoeyByZWZyZXNoVG9rZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvbm5lY3Qgb24gV1MgZmFpbHVyZXMsIGRvbid0IHJlY29ubmVjdCBpZiB0aGVyZSBpcyBhIGNvZGUgYnVnXG4gICAgICAgICAgICBpZiAoZXJyb3IuaXNXU0ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdTIGZhaWx1cmUsIHNvIGdvaW5nIHRvIHRyeSB0byByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtID09IEVORCA9PScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfZGVzdHJveUN1cnJlbnRXU0Nvbm5lY3Rpb24gLSBSZW1vdmVzIHRoZSBjdXJyZW50IFdTIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIF9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpIHtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBJRCwgbWVhbmluZyB3ZSB3aWxsIGlnbm9yZSBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgb2xkXG4gICAgICAgIC8vIHdzIGNvbm5lY3Rpb24gZnJvbSBub3cgb24uXG4gICAgICAgIHRoaXMud3NJRCArPSAxO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcz8ud3M/LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcz8ud3M/LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJyYXlPclN0cmluZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJyYXlPclN0cmluZyA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc01hcFN0cmluZ0NhbGxiYWNrKGFycmF5T3JTdHJpbmcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICEhY2FsbGJhY2sgJiYgaXNTdHJpbmcoYXJyYXlPclN0cmluZyk7XG59XG5mdW5jdGlvbiBtYXAoYXJyYXlPclN0cmluZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBpZiAoaXNTdHJpbmcoYXJyYXlPclN0cmluZykgJiYgaXNNYXBTdHJpbmdDYWxsYmFjayhhcnJheU9yU3RyaW5nLCBjYWxsYmFjaykpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGFycmF5T3JTdHJpbmcubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheU9yU3RyaW5nLmNoYXJBdChrKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtWYWx1ZSA9IGFycmF5T3JTdHJpbmcuY2hhckF0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gY2FsbGJhY2soa1ZhbHVlLCBrLCBhcnJheU9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXNba10gPSBtYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdHJpbmcoYXJyYXlPclN0cmluZykgJiZcbiAgICAgICAgIWlzTWFwU3RyaW5nQ2FsbGJhY2soYXJyYXlPclN0cmluZywgY2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBhcnJheU9yU3RyaW5nLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpZiAoayBpbiBhcnJheU9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga1ZhbHVlID0gYXJyYXlPclN0cmluZ1trXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IGNhbGxiYWNrKGtWYWx1ZSwgaywgYXJyYXlPclN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmVzW2tdID0gbWFwcGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGVuY29kZUJhc2U2NCA9IChkYXRhKSA9PiBmcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KG1hcChkYXRhLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApKSkpO1xuLy8gYmFzZS02NCBkZWNvZGVyIHRocm93cyBleGNlcHRpb24gaWYgZW5jb2RlZCBzdHJpbmcgaXMgbm90IHBhZGRlZCBieSAnPScgdG8gbWFrZSBzdHJpbmcgbGVuZ3RoXG4vLyBpbiBtdWx0aXBsZXMgb2YgNC4gU28gZ29ubmEgdXNlIG91ciBvd24gbWV0aG9kIGZvciB0aGlzIHB1cnBvc2UgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyNlxuY29uc3QgZGVjb2RlQmFzZTY0ID0gKHMpID0+IHtcbiAgICBjb25zdCBlID0ge30sIHcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLCBMID0gcy5sZW5ndGg7XG4gICAgbGV0IGksIGIgPSAwLCBjLCB4LCBsID0gMCwgYSwgciA9ICcnO1xuICAgIGNvbnN0IEEgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgZVtBLmNoYXJBdChpKV0gPSBpO1xuICAgIH1cbiAgICBmb3IgKHggPSAwOyB4IDwgTDsgeCsrKSB7XG4gICAgICAgIGMgPSBlW3MuY2hhckF0KHgpXTtcbiAgICAgICAgYiA9IChiIDw8IDYpICsgYztcbiAgICAgICAgbCArPSA2O1xuICAgICAgICB3aGlsZSAobCA+PSA4KSB7XG4gICAgICAgICAgICAoKGEgPSAoYiA+Pj4gKGwgLT0gOCkpICYgMHhmZikgfHwgeCA8IEwgLSAyKSAmJiAociArPSB3KGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgSldUIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgVXNlclNlc3Npb25cbiAqIEBtZXRob2QgSldUVXNlclRva2VuXG4gKiBAbWVtYmVyb2Ygc2lnbmluZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U2VjcmV0fSBhcGlTZWNyZXQgLSBBUEkgU2VjcmV0IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyX2lkIGtleSBpbiB0aGUgSldUIHBheWxvYWRcbiAqIEBwYXJhbSB7VVJ9IFtleHRyYURhdGFdIC0gRXh0cmEgdGhhdCBzaG91bGQgYmUgcGFydCBvZiB0aGUgSldUIHRva2VuXG4gKiBAcGFyYW0ge1NpZ25PcHRpb25zfSBband0T3B0aW9uc10gLSBPcHRpb25zIHRoYXQgY2FuIGJlIHBhc3QgdG8gand0LnNpZ25cbiAqIEByZXR1cm4ge3N0cmluZ30gSldUIFRva2VuXG4gKi9cbmZ1bmN0aW9uIEpXVFVzZXJUb2tlbihhcGlTZWNyZXQsIHVzZXJJZCwgZXh0cmFEYXRhID0ge30sIGp3dE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2VySWQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgLi4uZXh0cmFEYXRhLFxuICAgIH07XG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIGNsZWFyIGVycm9yIHdoZW4gand0IGlzIHNoaW1tZWQgKGllLiBicm93c2VyIGJ1aWxkKVxuICAgIGlmIChqd3QgPT0gbnVsbCB8fCBqd3Quc2lnbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBqd3QgY3J5cHRvLCBpZiB5b3UgYXJlIGdldHRpbmcgdGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIHRva2VucyBvbiBicm93c2VyIG9yIFJlYWN0IE5hdGl2ZSAob3Igb3RoZXIgZW52aXJvbm1lbnQgd2hlcmUgY3J5cHRvIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSkuIFBsZWFzZSBOb3RlOiB0b2tlbiBzaG91bGQgb25seSBiZSBnZW5lcmF0ZWQgc2VydmVyLXNpZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgYWxnb3JpdGhtOiAnSFMyNTYnLCBub1RpbWVzdGFtcDogdHJ1ZSB9LCBqd3RPcHRpb25zKTtcbiAgICBpZiAocGF5bG9hZC5pYXQpIHtcbiAgICAgICAgb3B0cy5ub1RpbWVzdGFtcCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgYXBpU2VjcmV0LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIEpXVFNlcnZlclRva2VuKGFwaVNlY3JldCwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuZnVuY3Rpb24gVXNlckZyb21Ub2tlbih0b2tlbikge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBiNjRQYXlsb2FkID0gZnJhZ21lbnRzWzFdO1xuICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVCYXNlNjQoYjY0UGF5bG9hZCk7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgcmV0dXJuIGRhdGEudXNlcl9pZDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIERldlRva2VuKHVzZXJJZCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjknLCAvL3tcImFsZ1wiOiBcIkhTMjU2XCIsIFwidHlwXCI6IFwiSldUXCJ9XG4gICAgICAgIGVuY29kZUJhc2U2NChKU09OLnN0cmluZ2lmeSh7IHVzZXJfaWQ6IHVzZXJJZCB9KSksXG4gICAgICAgICdkZXZ0b2tlbicsIC8vIGhhcmRjb2RlZCBzaWduYXR1cmVcbiAgICBdLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBUb2tlbk1hbmFnZXJcbiAqXG4gKiBIYW5kbGVzIGFsbCB0aGUgb3BlcmF0aW9ucyBhcm91bmQgdXNlciB0b2tlbi5cbiAqL1xuY2xhc3MgVG9rZW5NYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZWNyZXR9IHNlY3JldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlY3JldCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBzdGF0aWMgc3RyaW5nIHRva2VuIG9yIHRva2VuIHByb3ZpZGVyLlxuICAgICAgICAgKiBUb2tlbiBwcm92aWRlciBzaG91bGQgcmV0dXJuIGEgdG9rZW4gc3RyaW5nIG9yIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBzdHJpbmcgdG9rZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7VG9rZW5PclByb3ZpZGVyfSB0b2tlbk9yUHJvdmlkZXIgLSB0aGUgdG9rZW4gb3IgdG9rZW4gcHJvdmlkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7VXNlclJlc3BvbnNlfSB1c2VyIC0gdGhlIHVzZXIgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQW5vbnltb3VzIC0gd2hldGhlciB0aGUgdXNlciBpcyBhbm9ueW1vdXMgb3Igbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRUb2tlbk9yUHJvdmlkZXIgPSBhc3luYyAodG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cykgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVRva2VuKHRva2VuT3JQcm92aWRlciwgdXNlciwgaXNBbm9ueW1vdXMpO1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRva2VuT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuUHJvdmlkZXIgPSB0b2tlbk9yUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3Byb3ZpZGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5PclByb3ZpZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbk9yUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3N0YXRpYyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRva2VuT3JQcm92aWRlciAmJiB0aGlzLnVzZXIgJiYgdGhpcy5zZWNyZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gSldUVXNlclRva2VuKHRoaXMuc2VjcmV0LCB1c2VyLmlkLCB7fSwge30pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzdGF0aWMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkVG9rZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgdG9rZW4gbWFuYWdlci5cbiAgICAgICAgICogVXNlZnVsIGZvciBjbGllbnQgZGlzY29ubmVjdGlvbiBvciBzd2l0Y2hpbmcgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sb2FkVG9rZW5Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVmFsaWRhdGVzIHRoZSB1c2VyIHRva2VuLlxuICAgICAgICB0aGlzLnZhbGlkYXRlVG9rZW4gPSAodG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cykgPT4ge1xuICAgICAgICAgICAgLy8gYWxsb3cgZW1wdHkgdG9rZW4gZm9yIGFub24gdXNlclxuICAgICAgICAgICAgaWYgKHVzZXIgJiYgaXNBbm9ueW1vdXMgJiYgIXRva2VuT3JQcm92aWRlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBlbXB0eSB0b2tlbiBmb3Igbm9uLXNlcnZlciBzaWRlIGNsaWVudC5cbiAgICAgICAgICAgIGlmICghdGhpcy5zZWNyZXQgJiYgIXRva2VuT3JQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlcldpdGhJZCB0b2tlbiBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5PclByb3ZpZGVyICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRva2VuT3JQcm92aWRlciAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAhaXNGdW5jdGlvbih0b2tlbk9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyIHRva2VuIHNob3VsZCBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgZW1wdHkgdG9rZW4gZm9yIGFub255bW91cyB1c2Vyc1xuICAgICAgICAgICAgICAgIGlmIChpc0Fub255bW91cyAmJiB0b2tlbk9yUHJvdmlkZXIgPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Vc2VySWQgPSBVc2VyRnJvbVRva2VuKHRva2VuT3JQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuT3JQcm92aWRlciAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlblVzZXJJZCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVzZXJJZCA9PT0gJycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICghaXNBbm9ueW1vdXMgJiYgdG9rZW5Vc2VySWQgIT09IHVzZXIuaWQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJUb2tlbiBkb2VzIG5vdCBoYXZlIGEgdXNlcl9pZCBvciBpcyBub3QgbWF0Y2hpbmcgd2l0aCB1c2VyLmlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNvbHZlcyB3aGVuIHRva2VuIGlzIHJlYWR5LiBUaGlzIGZ1bmN0aW9uIGlzIHNpbXBseSB0byBjaGVjayBpZiBsb2FkVG9rZW4gaXMgaW4gcHJvZ3Jlc3MsIGluIHdoaWNoXG4gICAgICAgIC8vIGNhc2UgYSBmdW5jdGlvbiBzaG91bGQgd2FpdC5cbiAgICAgICAgdGhpcy50b2tlblJlYWR5ID0gKCkgPT4gdGhpcy5sb2FkVG9rZW5Qcm9taXNlO1xuICAgICAgICAvLyBGZXRjaGVzIGEgdG9rZW4gZnJvbSB0b2tlblByb3ZpZGVyIGZ1bmN0aW9uIGFuZCBzZXRzIGluIHRva2VuTWFuYWdlci5cbiAgICAgICAgLy8gSW4gY2FzZSBvZiBzdGF0aWMgdG9rZW4sIGl0IHdpbGwgc2ltcGx5IHJlc29sdmUgdG8gc3RhdGljIHRva2VuLlxuICAgICAgICB0aGlzLmxvYWRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgICAgICB0aGlzLmxvYWRUb2tlblByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcy50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRva2VuUHJvdmlkZXIgJiYgdHlwZW9mIHRoaXMudG9rZW5Qcm92aWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW4gPSBhd2FpdCB0aGlzLnRva2VuUHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYENhbGwgdG8gdG9rZW5Qcm92aWRlciBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2V9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkVG9rZW5Qcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXR1cm5zIGEgY3VycmVudCB0b2tlblxuICAgICAgICB0aGlzLmdldFRva2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIgJiYgIXRoaXMudG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3JldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKV1RTZXJ2ZXJUb2tlbih0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJvdGggc2VjcmV0IGFuZCB1c2VyIHRva2VucyBhcmUgbm90IHNldC4gRWl0aGVyIGNsaWVudC5jb25uZWN0VXNlciB3YXNuJ3QgY2FsbGVkIG9yIGNsaWVudC5kaXNjb25uZWN0IHdhcyBjYWxsZWRgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9ICgpID0+IHRoaXMudHlwZSA9PT0gJ3N0YXRpYyc7XG4gICAgICAgIHRoaXMubG9hZFRva2VuUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGlmIChzZWNyZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGF0aWMnO1xuICAgICAgICBpZiAodGhpcy5zZWNyZXQpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBKV1RTZXJ2ZXJUb2tlbih0aGlzLnNlY3JldCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IEFQSUVycm9yQ29kZXMgPSB7XG4gICAgJy0xJzogeyBuYW1lOiAnSW50ZXJuYWxTeXN0ZW1FcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICcyJzogeyBuYW1lOiAnQWNjZXNzS2V5RXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzMnOiB7IG5hbWU6ICdBdXRoZW50aWNhdGlvbkZhaWxlZEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzQnOiB7IG5hbWU6ICdJbnB1dEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc2JzogeyBuYW1lOiAnRHVwbGljYXRlVXNlcm5hbWVFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnOSc6IHsgbmFtZTogJ1JhdGVMaW1pdEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzE2JzogeyBuYW1lOiAnRG9lc05vdEV4aXN0RXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzE3JzogeyBuYW1lOiAnTm90QWxsb3dlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcxOCc6IHsgbmFtZTogJ0V2ZW50Tm90U3VwcG9ydGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzE5JzogeyBuYW1lOiAnQ2hhbm5lbEZlYXR1cmVOb3RTdXBwb3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMjAnOiB7IG5hbWU6ICdNZXNzYWdlVG9vTG9uZ0Vycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcyMSc6IHsgbmFtZTogJ011bHRpcGxlTmVzdGluZ0xldmVsRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzIyJzogeyBuYW1lOiAnUGF5bG9hZFRvb0JpZ0Vycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcyMyc6IHsgbmFtZTogJ1JlcXVlc3RUaW1lb3V0RXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnMjQnOiB7IG5hbWU6ICdNYXhIZWFkZXJTaXplRXhjZWVkZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDAnOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlbkV4cGlyZWQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQxJzogeyBuYW1lOiAnQXV0aEVycm9yVG9rZW5Ob3RWYWxpZFlldCcsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDInOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlblVzZWRCZWZvcmVJc3N1ZWRBdCcsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDMnOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlblNpZ25hdHVyZUludmFsaWQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQ0JzogeyBuYW1lOiAnQ3VzdG9tQ29tbWFuZEVuZHBvaW50TWlzc2luZ0Vycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0NSc6IHsgbmFtZTogJ0N1c3RvbUNvbW1hbmRFbmRwb2ludENhbGxFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICc0Nic6IHsgbmFtZTogJ0Nvbm5lY3Rpb25JRE5vdEZvdW5kRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzYwJzogeyBuYW1lOiAnQ29vbERvd25FcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICc2OSc6IHsgbmFtZTogJ0Vycldyb25nUmVnaW9uJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc3MCc6IHsgbmFtZTogJ0VyclF1ZXJ5Q2hhbm5lbFBlcm1pc3Npb25zJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc3MSc6IHsgbmFtZTogJ0VyclRvb01hbnlDb25uZWN0aW9ucycsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICc5OSc6IHsgbmFtZTogJ0FwcFN1c3BlbmRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxufTtcbmZ1bmN0aW9uIGlzQVBJRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNFcnJvclJldHJ5YWJsZShlcnJvcikge1xuICAgIGlmICghZXJyb3IuY29kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVyciA9IEFQSUVycm9yQ29kZXNbYCR7ZXJyb3IuY29kZX1gXTtcbiAgICBpZiAoIWVycilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBlcnIucmV0cnlhYmxlO1xufVxuZnVuY3Rpb24gaXNDb25uZWN0aW9uSURFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSA0NjsgLy8gQ29ubmVjdGlvbklETm90Rm91bmRFcnJvclxufVxuZnVuY3Rpb24gaXNXU0ZhaWx1cmUoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIuaXNXU0ZhaWx1cmUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZXJyLmlzV1NGYWlsdXJlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShlcnIubWVzc2FnZSkuaXNXU0ZhaWx1cmU7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuICFyZXMuc3RhdHVzIHx8IHJlcy5zdGF0dXMgPCAyMDAgfHwgMzAwIDw9IHJlcy5zdGF0dXM7XG59XG5cbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IFwiQ0xPU0VEXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGVkXCJdID0gXCJDT05ORUNURURcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0aW5nXCJdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gXCJESVNDT05ORUNURURcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbXCJJbml0XCJdID0gXCJJTklUXCI7XG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG5jbGFzcyBXU0Nvbm5lY3Rpb25GYWxsYmFjayB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9vbmxpbmVTdGF0dXNDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2coYF9vbmxpbmVTdGF0dXNDaGFuZ2VkKCkgLSAke2V2ZW50LnR5cGV9YCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ29mZmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNsb3NlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxUb2tlbj8uY2FuY2VsKCdkaXNjb25uZWN0KCkgaXMgY2FsbGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ29ubGluZScgJiYgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX3JlcSA9IGFzeW5jIChwYXJhbXMsIGNvbmZpZywgcmV0cnkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5jZWxUb2tlbiAmJiAhcGFyYW1zLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxUb2tlbiA9IGF4aW9zLkNhbmNlbFRva2VuLnNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNsaWVudC5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdGhpcy5jbGllbnQuYmFzZVVSTC5yZXBsYWNlKCc6MzAzMCcsICc6ODkwMCcpICsgJy9sb25ncG9sbCcsIC8vIHJlcGxhY2UgcG9ydCBpZiBwcmVzZW50IGZvciB0ZXN0aW5nIHdpdGggbG9jYWwgQVBJXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogeyAuLi5jb25maWcsIGNhbmNlbFRva2VuOiB0aGlzLmNhbmNlbFRva2VuPy50b2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY0VuZHBvaW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7IC8vIGFsd2F5cyByZXNldCBpbiBjYXNlIG9mIG5vIGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5ICYmIGlzRXJyb3JSZXRyeWFibGUoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coYF9yZXEoKSAtIFJldHJ5YWJsZSBlcnJvciwgcmV0cnlpbmcgcmVxdWVzdGApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxKHBhcmFtcywgY29uZmlnLCByZXRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX3BvbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9yZXEoe30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDAwLFxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTsgLy8gMzBzID0+IEFQSSByZXNwb25kcyBpbiAyMHMgaWYgdGhlcmUgaXMgbm8gZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXZlbnRzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KGRhdGEuZXZlbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlvcy5pc0NhbmNlbChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coYF9wb2xsKCkgLSBheGlvcyBjYW5jZWxlZCByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyoqIGNsaWVudC5kb0F4aW9zUmVxdWVzdCB3aWxsIHRha2UgY2FyZSBvZiBUT0tFTl9FWFBJUkVEIGVycm9yICovXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGlvbklERXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBfcG9sbCgpIC0gQ29ubmVjdGlvbklEIGVycm9yLCBjb25uZWN0aW5nIHdpdGhvdXQgSUQuLi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQVBJRXJyb3IoZXJyKSAmJiAhaXNFcnJvclJldHJ5YWJsZShlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbm5lY3QgdHJ5IHRvIG9wZW4gYSBsb25ncG9sbCByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSByZWNvbm5lY3Qgc2hvdWxkIGJlIGZhbHNlIGZvciBmaXJzdCBjYWxsIGFuZCB0cnVlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGtlZXAgdGhlIGNvbm5lY3Rpb24gYWxpdmUgYW5kIGNhbGwgcmVjb3ZlclN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBhc3luYyAocmVjb25uZWN0ID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gY29ubmVjdGluZyBhbHJlYWR5IGluIHByb2dyZXNzJywgeyByZWNvbm5lY3QgfSwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gYWxyZWFkeSBjb25uZWN0ZWQgYW5kIHBvbGxpbmcnLCB7IHJlY29ubmVjdCB9LCAnd2FybicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklEID0gdW5kZWZpbmVkOyAvLyBjb25uZWN0IHNob3VsZCBiZSBzZW50IHdpdGggZW1wdHkgY29ubmVjdGlvbl9pZCBzbyBBUEkgY3JlYXRlcyBvbmVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBldmVudCB9ID0gYXdhaXQgdGhpcy5fcmVxKHsganNvbjogdGhpcy5jbGllbnQuX2J1aWxkV1NQYXlsb2FkKCkgfSwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiA4MDAwLCAvLyA4c1xuICAgICAgICAgICAgICAgIH0sIHJlY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uSUQgPSBldmVudC5jb25uZWN0aW9uX2lkO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LnJlc29sdmVDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LnJlamVjdENvbm5lY3Rpb25JZD8uKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogaXNIZWFsdGh5IGNoZWNrcyBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb25JRCBhbmQgY29ubmVjdGlvbiBpcyBpbiBDb25uZWN0ZWQgc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jb25uZWN0aW9uSUQgJiYgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ID0gYXN5bmMgKHRpbWVvdXQgPSAyMDAwKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnModGhpcy5fb25saW5lU3RhdHVzQ2hhbmdlZCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsVG9rZW4/LmNhbmNlbCgnZGlzY29ubmVjdCgpIGlzIGNhbGxlZCcpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25faWQgPSB0aGlzLmNvbm5lY3Rpb25JRDtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklEID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZXEoeyBjbG9zZTogdHJ1ZSwgY29ubmVjdGlvbl9pZCB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gQ2xvc2VkIGNvbm5lY3Rpb25JRGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gRmFpbGVkYCwgeyBlcnIgfSwgJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkluaXQ7XG4gICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyh0aGlzLl9vbmxpbmVTdGF0dXNDaGFuZ2VkKTtcbiAgICB9XG4gICAgX2xvZyhtc2csIGV4dHJhID0ge30sIGxldmVsID0gJ2luZm8nKSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlcihsZXZlbCwgJ1dTQ29ubmVjdGlvbkZhbGxiYWNrOicgKyBtc2csIHtcbiAgICAgICAgICAgIC4uLmV4dHJhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2xvZyhgX3NldFN0YXRlKCkgLSAke3N0YXRlfWApO1xuICAgICAgICAvLyB0cmFuc2l0aW9uIGZyb20gY29ubmVjdGluZyA9PiBjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nICYmXG4gICAgICAgICAgICBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLCBvbmxpbmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkIHx8XG4gICAgICAgICAgICBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLCBvbmxpbmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG59XG5cbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2xvY2F0aW9uJ10pO1xuY29uc3QgSElOVF9VUkwgPSBgaHR0cHM6Ly9oaW50LnN0cmVhbS1pby12aWRlby5jb20vYDtcbmNvbnN0IGdldExvY2F0aW9uSGludCA9IGFzeW5jIChoaW50VXJsID0gSElOVF9VUkwsIHRpbWVvdXQgPSAyMDAwKSA9PiB7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaGludFVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhd3NQb3AgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1hbXotY2YtcG9wJykgfHwgJ0VSUic7XG4gICAgICAgIGxvZ2dlcignZGVidWcnLCBgTG9jYXRpb24gaGVhZGVyOiAke2F3c1BvcH1gKTtcbiAgICAgICAgcmV0dXJuIGF3c1BvcC5zdWJzdHJpbmcoMCwgMyk7IC8vIEFNUzEtUDIgLT4gQU1TXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlcignd2FybicsIGBGYWlsZWQgdG8gZ2V0IGxvY2F0aW9uIGhpbnQgZnJvbSAke2hpbnRVcmx9YCwgZSk7XG4gICAgICAgIHJldHVybiAnRVJSJztcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbn07XG5cbmNsYXNzIFN0cmVhbUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUgYXBpIGtleVxuICAgICAqIEBwYXJhbSB7U3RyZWFtQ2xpZW50T3B0aW9uc30gW29wdGlvbnNdIC0gYWRkaXRpb25hbCBvcHRpb25zLCBoZXJlIHlvdSBjYW4gcGFzcyBjdXN0b20gb3B0aW9ucyB0byBheGlvcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWNyZXRdIC0gdGhlIGFwaSBzZWNyZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJyb3dzZXJdIC0gZW5mb3JjZSB0aGUgY2xpZW50IHRvIGJlIGluIGJyb3dzZXIgbW9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2FybVVwXSAtIGRlZmF1bHQgdG8gZmFsc2UsIGlmIHRydWUsIGNsaWVudCB3aWxsIG9wZW4gYSBjb25uZWN0aW9uIGFzIHNvb24gYXMgcG9zc2libGUgdG8gc3BlZWQgdXAgZm9sbG93aW5nIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtMb2dnZXJ9IFtvcHRpb25zLkxvZ2dlcl0gLSBjdXN0b20gbG9nZ2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbWVvdXRdIC0gZGVmYXVsdCB0byAzMDAwXG4gICAgICogQHBhcmFtIHtodHRwc0FnZW50fSBbb3B0aW9ucy5odHRwc0FnZW50XSAtIGN1c3RvbSBodHRwc0FnZW50LCBpbiBub2RlIGl0J3MgZGVmYXVsdCB0byBodHRwcy5hZ2VudCgpXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRldlRva2VuID0gKHVzZXJJRCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERldlRva2VuKHVzZXJJRCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QXV0aFR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXMgPyAnYW5vbnltb3VzJyA6ICdqd3QnO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEJhc2VVUkwgPSAoYmFzZVVSTCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICAgICAgICAgIHRoaXMud3NCYXNlVVJMID0gdGhpcy5iYXNlVVJMXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ2h0dHAnLCAnd3MnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCc6MzAzMCcsICc6ODgwMCcpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uSGludCA9IGFzeW5jIChoaW50VXJsLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaW50ID0gYXdhaXQgdGhpcy5sb2NhdGlvbkhpbnQ7XG4gICAgICAgICAgICBpZiAoIWhpbnQgfHwgaGludCA9PT0gJ0VSUicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGludCA9IGdldExvY2F0aW9uSGludChoaW50VXJsID8/IHRoaXMub3B0aW9ucy5sb2NhdGlvbkhpbnRVcmwsIHRpbWVvdXQgPz8gdGhpcy5vcHRpb25zLmxvY2F0aW9uSGludFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uSGludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9nZXRDb25uZWN0aW9uSUQgPSAoKSA9PiB0aGlzLndzQ29ubmVjdGlvbj8uY29ubmVjdGlvbklEIHx8IHRoaXMud3NGYWxsYmFjaz8uY29ubmVjdGlvbklEO1xuICAgICAgICB0aGlzLl9oYXNDb25uZWN0aW9uSUQgPSAoKSA9PiBCb29sZWFuKHRoaXMuX2dldENvbm5lY3Rpb25JRCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbm5lY3RVc2VyIC0gU2V0IHRoZSBjdXJyZW50IHVzZXIgYW5kIG9wZW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlciBEYXRhIGFib3V0IHRoaXMgdXNlci4gSUUge25hbWU6IFwiam9oblwifVxuICAgICAgICAgKiBAcGFyYW0ge1Rva2VuT3JQcm92aWRlcn0gdXNlclRva2VuT3JQcm92aWRlciBUb2tlbiBvciBwcm92aWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDb25uZWN0QVBJUmVzcG9uc2V9IFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBzZXR1cFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0VXNlciA9IGFzeW5jICh1c2VyLCB1c2VyVG9rZW5PclByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImlkXCIgZmllbGQgb24gdGhlIHVzZXIgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsaW5nIGNvbm5lY3RVc2VyIG11bHRpcGxlIHRpbWVzIGlzIHBvdGVudGlhbGx5IHRoZSByZXN1bHQgb2YgYSAgYmFkIGludGVncmF0aW9uLCBob3dldmVyLFxuICAgICAgICAgICAgICogSWYgdGhlIHVzZXIgaWQgcmVtYWlucyB0aGUgc2FtZSB3ZSBkb24ndCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy51c2VySUQgPT09IHVzZXIuaWQgJiYgdGhpcy5zZXRVc2VyUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0NvbnNlY3V0aXZlIGNhbGxzIHRvIGNvbm5lY3RVc2VyIGlzIGRldGVjdGVkLCBpZGVhbGx5IHlvdSBzaG91bGQgb25seSBjYWxsIHRoaXMgZnVuY3Rpb24gb25jZSBpbiB5b3VyIGFwcC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRVc2VyUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGNsaWVudC5kaXNjb25uZWN0KCkgYmVmb3JlIHRyeWluZyB0byBjb25uZWN0IGFzIGEgZGlmZmVyZW50IHVzZXIuIGNvbm5lY3RVc2VyIHdhcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuX2lzVXNpbmdTZXJ2ZXJBdXRoKCkgfHwgdGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ1BsZWFzZSBkbyBub3QgdXNlIGNvbm5lY3RVc2VyIHNlcnZlciBzaWRlLiBjb25uZWN0VXNlciBpbXBhY3RzIE1BVSBhbmQgY29uY3VycmVudCBjb25uZWN0aW9uIHVzYWdlIGFuZCB0aHVzIHlvdXIgYmlsbC4gSWYgeW91IGhhdmUgYSB2YWxpZCB1c2UtY2FzZSwgYWRkIFwiYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdDogdHJ1ZVwiIHRvIHRoZSBjbGllbnQgb3B0aW9ucyB0byBkaXNhYmxlIHRoaXMgd2FybmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGdlbmVyYXRlIHRoZSBjbGllbnQgaWQgY2xpZW50IHNpZGVcbiAgICAgICAgICAgIHRoaXMudXNlcklEID0gdXNlci5pZDtcbiAgICAgICAgICAgIHRoaXMuYW5vbnltb3VzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzZXRUb2tlblByb21pc2UgPSB0aGlzLl9zZXRUb2tlbih1c2VyLCB1c2VyVG9rZW5PclByb3ZpZGVyLCB0aGlzLmFub255bW91cyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVc2VyKHVzZXIpO1xuICAgICAgICAgICAgY29uc3Qgd3NQcm9taXNlID0gdGhpcy5vcGVuQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRVc2VyUHJvbWlzZSA9IFByb21pc2UuYWxsKFtzZXRUb2tlblByb21pc2UsIHdzUHJvbWlzZV0pLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0WzFdKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0VXNlclByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgY2xpZW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIHJldHJ5IGNvbm5lY3RVc2VyIGFnYWluXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0VG9rZW4gPSAodXNlciwgdXNlclRva2VuT3JQcm92aWRlciwgaXNBbm9ueW1vdXMpID0+IHRoaXMudG9rZW5NYW5hZ2VyLnNldFRva2VuT3JQcm92aWRlcih1c2VyVG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cyk7XG4gICAgICAgIHRoaXMuX3NldFVzZXIgPSAodXNlcikgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG9uZSBpcyB1c2VkIGJ5IHRoZSBmcm9udGVuZC4gVGhpcyBpcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdXNlciBvYmplY3Qgc3RvcmVkIG9uIGJhY2tlbmQuXG4gICAgICAgICAgICAgKiBJdCBjb250YWlucyByZXNlcnZlZCBwcm9wZXJ0aWVzIGFuZCBvd24gdXNlciBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBub3QgcHJlc2VudCBpbiBgdGhpcy5fdXNlcmAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgICAgICB0aGlzLnVzZXJJRCA9IHVzZXIuaWQ7XG4gICAgICAgICAgICAvLyB0aGlzIG9uZSBpcyBhY3R1YWxseSB1c2VkIGZvciByZXF1ZXN0cy4gVGhpcyBpcyBhIGNvcHkgb2YgY3VycmVudCB1c2VyIHByb3ZpZGVkIHRvIGBjb25uZWN0VXNlcmAgZnVuY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl91c2VyID0geyAuLi51c2VyIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24sIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIHVzZXIgc2V0IG9uIGNsaWVudC5cbiAgICAgICAgICogY2xpZW50LmNsb3NlQ29ubmVjdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGRlZmF1bHQgYXV0by1yZXRyeSBtZWNoYW5pc20gZm9yIHJlY29ubmVjdGlvbi4gWW91IG5lZWRcbiAgICAgICAgICogdG8gY2FsbCBjbGllbnQub3BlbkNvbm5lY3Rpb24gdG8gcmVjb25uZWN0IHRvIHdlYnNvY2tldC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBtYWlubHkgdXNlZnVsIG9uIG1vYmlsZSBzaWRlLiBZb3UgY2FuIG9ubHkgcmVjZWl2ZSBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICogaWYgeW91IGRvbid0IGhhdmUgYWN0aXZlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgICAgKiBTbyB3aGVuIHlvdXIgYXBwIGdvZXMgdG8gYmFja2dyb3VuZCwgeW91IGNhbiBjYWxsIGBjbGllbnQuY2xvc2VDb25uZWN0aW9uYC5cbiAgICAgICAgICogQW5kIHdoZW4gYXBwIGNvbWVzIGJhY2sgdG8gZm9yZWdyb3VuZCwgY2FsbCBgY2xpZW50Lm9wZW5Db25uZWN0aW9uYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbmluZ0ludGVydmFsUmVmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24/LmRpc2Nvbm5lY3QodGltZW91dCksXG4gICAgICAgICAgICAgICAgdGhpcy53c0ZhbGxiYWNrPy5kaXNjb25uZWN0KHRpbWVvdXQpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFdlYlNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGN1cnJlbnQgdXNlci4gUmV0dXJucyBlbXB0eSBwcm9taXNlLCBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgY29ubmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VySUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVXNlcldpdGhJZCBpcyBub3Qgc2V0IG9uIGNsaWVudCwgdXNlIGNsaWVudC5jb25uZWN0VXNlciBvciBjbGllbnQuY29ubmVjdEFub255bW91c1VzZXIgaW5zdGVhZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMud3NDb25uZWN0aW9uPy5pc0Nvbm5lY3RpbmcgJiYgdGhpcy53c1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdjbGllbnQ6b3BlbkNvbm5lY3Rpb24oKSAtIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndzUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy53c0Nvbm5lY3Rpb24/LmlzSGVhbHRoeSB8fCB0aGlzLndzRmFsbGJhY2s/LmlzSGVhbHRoeSgpKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnY2xpZW50Om9wZW5Db25uZWN0aW9uKCkgLSBvcGVuQ29ubmVjdGlvbiBjYWxsZWQgdHdpY2UsIGhlYWx0aHkgY29ubmVjdGlvbiBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uSWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudElEID0gYCR7dGhpcy51c2VySUR9LS0ke3JhbmRvbUlkKCl9YDtcbiAgICAgICAgICAgIHRoaXMud3NQcm9taXNlID0gdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53c1Byb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZURhdGUgPSAoYmVmb3JlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYmVmb3JlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGJlZm9yZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZm9yZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBwYXNzIGJsYW5rIHN0cmluZyBmb3Igc2luY2UsIHVzZSBudWxsIGluc3RlYWQgaWYgcmVzZXR0aW5nIHRoZSB0b2tlbiByZXZva2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIHdlYnNvY2tldCBhbmQgcmVtb3ZlcyB0aGUgdXNlciBmcm9tIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNzZnVsIGRpc2Nvbm5lY3Rpb24uXG4gICAgICAgICAqICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ2NsaWVudDpkaXNjb25uZWN0KCkgLSBEaXNjb25uZWN0aW5nIHRoZSBjbGllbnQnKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdXNlciBzcGVjaWZpYyBmaWVsZHNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXNlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJJRDtcbiAgICAgICAgICAgIHRoaXMuYW5vbnltb3VzID0gZmFsc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlQ29ubmVjdGlvbih0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnJlamVjdENvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0R3Vlc3RVc2VyID0gYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHRoaXMuZG9BeGlvc1JlcXVlc3QoJ3Bvc3QnLCAnL2d1ZXN0Jywge1xuICAgICAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udXNlcixcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2d1ZXN0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgeyBwdWJsaWNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFVzZXIocmVzcG9uc2UudXNlciwgcmVzcG9uc2UuYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbm5lY3RBbm9ueW1vdXNVc2VyIC0gU2V0IGFuIGFub255bW91cyB1c2VyIGFuZCBvcGVuIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdEFub255bW91c1VzZXIgPSBhc3luYyAodXNlciwgdG9rZW5PclByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29ubmVjdGlvbklkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdENvbm5lY3Rpb25JZCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hbm9ueW1vdXMgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0VG9rZW4odXNlciwgdG9rZW5PclByb3ZpZGVyLCB0aGlzLmFub255bW91cyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVc2VyKHVzZXIpO1xuICAgICAgICAgICAgLy8gc29tZSBlbmRwb2ludHMgcmVxdWlyZSBhIGNvbm5lY3Rpb25faWQgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgICAvLyBhcyBhbm9ueW1vdXMgdXNlcnMgYXJlbid0IGFsbG93ZWQgdG8gb3BlbiBXUyBjb25uZWN0aW9ucywgd2UganVzdFxuICAgICAgICAgICAgLy8gcmVzb2x2ZSB0aGUgY29ubmVjdGlvbl9pZCBoZXJlLlxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9uIC0gTGlzdGVuIHRvIGV2ZW50cyBvbiBhbGwgY2hhbm5lbHMgYW5kIHVzZXJzIHlvdXIgd2F0Y2hpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogY2xpZW50Lm9uKCdtZXNzYWdlLm5ldycsIGV2ZW50ID0+IHtjb25zb2xlLmxvZyhcIm15IG5ldyBtZXNzYWdlXCIsIGV2ZW50LCBjaGFubmVsLnN0YXRlLm1lc3NhZ2VzKX0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvciAob3B0aW9uYWwpXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gY2FsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuICBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBBZGRpbmcgbGlzdGVuZXIgZm9yICR7ZXZlbnROYW1lfSBldmVudGApO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXT8ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9mZiAtIFJlbW92ZSB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmYgPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFJlbW92aW5nIGxpc3RlbmVyIGZvciAke2V2ZW50TmFtZX0gZXZlbnRgKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdPy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlSZXF1ZXN0ID0gKHR5cGUsIHVybCwgZGF0YSwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgY2xpZW50OiAke3R5cGV9IC0gUmVxdWVzdCAtICR7dXJsfWAsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlSZXNwb25zZSA9ICh0eXBlLCB1cmwsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgY2xpZW50OiR7dHlwZX0gLSBSZXNwb25zZSAtIHVybDogJHt1cmx9ID4gc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWAsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlFcnJvciA9ICh0eXBlLCB1cmwsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgY2xpZW50OiR7dHlwZX0gLSBFcnJvciAtIHVybDogJHt1cmx9YCwge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvQXhpb3NSZXF1ZXN0ID0gYXN5bmMgKHR5cGUsIHVybCwgZGF0YSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHVibGljRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5NYW5hZ2VyLnRva2VuUmVhZHkoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0gdGhpcy5fZW5yaWNoQXhpb3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpUmVxdWVzdCh0eXBlLCB1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UuZ2V0KHVybCwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLmRlbGV0ZSh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucG9zdCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wdXQodXJsLCBkYXRhLCByZXF1ZXN0Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wYXRjaCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2Uub3B0aW9ucyh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCB0eXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ0FwaVJlc3BvbnNlKHR5cGUsIHVybCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKipUT0RPOiBnZW5lcmFsaXplIGVycm9yIHR5cGVzICAqLykge1xuICAgICAgICAgICAgICAgIGUuY2xpZW50X3JlcXVlc3RfaWQgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnM/LlsneC1jbGllbnQtcmVxdWVzdC1pZCddO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ0FwaUVycm9yKHR5cGUsIHVybCwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBjb25uZWN0aW9uX2ZhbGxiYWNrIGRlcGVuZHMgb24gdGhpcyB0b2tlbiBleHBpcmF0aW9uIGxvZ2ljICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlLmRhdGEuY29kZSA9PT0gS25vd25Db2Rlcy5UT0tFTl9FWFBJUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kb0F4aW9zUmVxdWVzdCh0eXBlLCB1cmwsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpRXJyb3IodHlwZSwgdXJsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0ID0gKHVybCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdXJsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHV0ID0gKHVybCwgZGF0YSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgncHV0JywgdXJsLCBkYXRhLCB7IHBhcmFtcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3N0ID0gKHVybCwgZGF0YSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgncG9zdCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGF0Y2ggPSAodXJsLCBkYXRhLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdwYXRjaCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlID0gKHVybCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgnZGVsZXRlJywgdXJsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXJyb3JGcm9tUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3JGcm9tUmVzcG9uc2UoYFN0cmVhbSBlcnJvciBIVFRQIGNvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBTdHJlYW0gZXJyb3IgY29kZSAke3Jlc3BvbnNlLmRhdGEuY29kZX06ICR7cmVzcG9uc2UuZGF0YS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gcmVzcG9uc2UuZGF0YS5jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBlcnIuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBpZiAoaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5yZWNlaXZlZF9hdClcbiAgICAgICAgICAgICAgICBldmVudC5yZWNlaXZlZF9hdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgRGlzcGF0Y2hpbmcgZXZlbnQ6ICR7ZXZlbnQudHlwZX1gLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGNhbGwgZ2VuZXJpYyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMuYWxsIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbCB0eXBlIHNwZWNpZmljIGxpc3RlbmVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlcklEIHx8ICF0aGlzLl91c2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbGwgY29ubmVjdFVzZXIgb3IgY29ubmVjdEFub255bW91c1VzZXIgYmVmb3JlIHN0YXJ0aW5nIHRoZSBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud3NCYXNlVVJMKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1dlYnNvY2tldCBiYXNlIHVybCBub3Qgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50SUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignY2xpZW50SUQgaXMgbm90IHNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLndzQ29ubmVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMud2FybVVwIHx8IHRoaXMub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXlIaSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIFN0YWJsZVdTQ29ubmVjdGlvbiBoYW5kbGVzIGFsbCB0aGUgcmVjb25uZWN0aW9uIGxvZ2ljLlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53c0Nvbm5lY3Rpb24gJiYgdGhpcy5ub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBhdm9pZGluZyBhZGRpbmcgdHMgZ2VuZXJpY3Mgb24gd3NDb25uZWN0aW9uIGluIG9wdGlvbnMgc2luY2UgaXRzIG9ubHkgdXNlZnVsIGZvciB1bml0IHRlc3QgcHVycG9zZS5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMud3NDb25uZWN0aW9uLnNldENsaWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbiA9IHRoaXMub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAud3NDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24gPSBuZXcgU3RhYmxlV1NDb25uZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmYWxsYmFjayBpcyB1c2VkIGJlZm9yZSwgY29udGludWUgdXNpbmcgaXQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBXUyB0byBmYWlsXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud3NGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53c0ZhbGxiYWNrLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnU3RyZWFtQ2xpZW50LmNvbm5lY3Q6IHRoaXMud3NDb25uZWN0aW9uLmNvbm5lY3QoKScpO1xuICAgICAgICAgICAgICAgIC8vIGlmIFdTRmFsbGJhY2sgaXMgZW5hYmxlZCwgd3MgY29ubmVjdCBzaG91bGQgdGltZW91dCBmYXN0ZXIgc28gZmFsbGJhY2sgY2FuIHRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzQ29ubmVjdGlvbi5jb25uZWN0KHRoaXMub3B0aW9ucy5lbmFibGVXU0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5kZWZhdWx0V1NUaW1lb3V0V2l0aEZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5kZWZhdWx0V1NUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBydW4gZmFsbGJhY2sgb25seSBpZiBpdCdzIFdTL05ldHdvcmsgZXJyb3IgYW5kIG5vdCBhIG5vcm1hbCBBUEkgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYnJvd3NlciBpcyBvbmxpbmUgYmVmb3JlIGV2ZW4gdHJ5aW5nIHRoZSBsb25ncG9sbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlV1NGYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlKGVycikgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPbmxpbmUodGhpcy5sb2dnZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ2NsaWVudDpjb25uZWN0KCkgLSBXUyBmYWlsZWQsIGZhbGxiYWNrIHRvIGxvbmdwb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICd0cmFuc3BvcnQuY2hhbmdlZCcsIG1vZGU6ICdsb25ncG9sbCcgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3NDb25uZWN0aW9uLl9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbi5kaXNjb25uZWN0KCkudGhlbigpOyAvLyBjbG9zZSBXUyBzbyBubyByZXRyeVxuICAgICAgICAgICAgICAgICAgICB0aGlzLndzRmFsbGJhY2sgPSBuZXcgV1NDb25uZWN0aW9uRmFsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzRmFsbGJhY2suY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB0aGUgY29ubmVjdGl2aXR5IHdpdGggc2VydmVyIGZvciB3YXJtdXAgcHVycG9zZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NheUhpID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50X3JlcXVlc3RfaWQgPSByYW5kb21JZCgpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBBeGlvc0hlYWRlcnMuZnJvbSh7XG4gICAgICAgICAgICAgICAgICAgICd4LWNsaWVudC1yZXF1ZXN0LWlkJzogY2xpZW50X3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdGhpcy5iYXNlVVJMICsgJy9oaScsIG51bGwsIG9wdHMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykge1xuICAgICAgICAgICAgICAgICAgICBwb3N0SW5zaWdodHMoJ2h0dHBfaGlfZmFpbGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnI6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VXNlckFnZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IFwiMC42LjEwXCIgO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnVzZXJBZ2VudCB8fFxuICAgICAgICAgICAgICAgIGBzdHJlYW0tdmlkZW8tamF2YXNjcmlwdC1jbGllbnQtJHt0aGlzLm5vZGUgPyAnbm9kZScgOiAnYnJvd3Nlcid9LSR7dmVyc2lvbn1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRVc2VyQWdlbnQgPSAodXNlckFnZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9pc1VzaW5nU2VydmVyQXV0aCAtIFJldHVybnMgdHJ1ZSBpZiB3ZSdyZSB1c2luZyBzZXJ2ZXIgc2lkZSBhdXRoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc1VzaW5nU2VydmVyQXV0aCA9ICgpID0+ICEhdGhpcy5zZWNyZXQ7XG4gICAgICAgIHRoaXMuX2VucmljaEF4aW9zT3B0aW9ucyA9IChvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBvcHRpb25zLnB1YmxpY0VuZHBvaW50ICYmICF0aGlzLnVzZXIgPyB1bmRlZmluZWQgOiB0aGlzLl9nZXRUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IHRva2VuID8geyBBdXRob3JpemF0aW9uOiB0b2tlbiB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHNpZ25hbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNpZ25hbCA9IHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnM/LlsneC1jbGllbnQtcmVxdWVzdC1pZCddKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICd4LWNsaWVudC1yZXF1ZXN0LWlkJzogcmFuZG9tSWQoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcl9pZDogdGhpcy51c2VySUQsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25faWQ6IHRoaXMuX2dldENvbm5lY3Rpb25JRCgpLFxuICAgICAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0tYXV0aC10eXBlJzogb3B0aW9ucy5wdWJsaWNFbmRwb2ludCAmJiAhdGhpcy51c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdhbm9ueW1vdXMnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0QXV0aFR5cGUoKSxcbiAgICAgICAgICAgICAgICAgICAgJ1gtU3RyZWFtLUNsaWVudCc6IHRoaXMuZ2V0VXNlckFnZW50KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLihzaWduYWwgPyB7IHNpZ25hbCB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuY29uZmlnLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5heGlvc1JlcXVlc3RDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9nZXRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50b2tlbk1hbmFnZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVuY29kZSB3cyB1cmwgcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBqc29uIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYnVpbGRXU1BheWxvYWQgPSAoY2xpZW50X3JlcXVlc3RfaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdXNlcl9pZDogdGhpcy51c2VySUQsXG4gICAgICAgICAgICAgICAgdXNlcl9kZXRhaWxzOiB0aGlzLl91c2VyLFxuICAgICAgICAgICAgICAgIGNsaWVudF9yZXF1ZXN0X2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjcmVhdGVzIGFuIGFib3J0IGNvbnRyb2xsZXIgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIG5leHQgSFRUUCBSZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVBYm9ydENvbnRyb2xsZXJGb3JOZXh0UmVxdWVzdCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjcmVhdGVUb2tlbiAtIENyZWF0ZXMgYSB0b2tlbiB0byBhdXRoZW50aWNhdGUgdGhpcyB1c2VyLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgc2VydmVyIHNpZGUuXG4gICAgICAgICAqIFRoZSByZXN1bHRpbmcgdG9rZW4gc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY2xpZW50IHNpZGUgd2hlbiB0aGUgdXNlcnMgcmVnaXN0ZXJzIG9yIGxvZ3MgaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySUQgVGhlIFVzZXJXaXRoSWQgSURcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtleHBdIFRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b2tlbiBleHByZXNzZWQgaW4gdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFxuICAgICAgICAgKiBAcGFyYW0gY2FsbF9jaWRzIGZvciBhbm9ueW1vdXMgdG9rZW5zIHlvdSBoYXZlIHRvIHByb3ZpZGUgdGhlIGNhbGwgY2lkcyB0aGUgdXNlIGNhbiBqb2luXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyBhIHRva2VuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuID0gKHVzZXJJRCwgZXhwLCBpYXQsIGNhbGxfY2lkcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgdG9rZW5zIGNhbiBvbmx5IGJlIGNyZWF0ZWQgc2VydmVyLXNpZGUgdXNpbmcgdGhlIEFQSSBTZWNyZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge307XG4gICAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuZXhwID0gZXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlhdCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmlhdCA9IGlhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsX2NpZHMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5jYWxsX2NpZHMgPSBjYWxsX2NpZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSldUVXNlclRva2VuKHRoaXMuc2VjcmV0LCB1c2VySUQsIGV4dHJhLCB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHNldCB0aGUga2V5XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAvLyBzZXQgdGhlIHNlY3JldFxuICAgICAgICB0aGlzLnNlY3JldCA9IG9wdGlvbnM/LnNlY3JldDtcbiAgICAgICAgLy8gc2V0IHRoZSBvcHRpb25zLi4uIGFuZCBmaWd1cmUgb3V0IGRlZmF1bHRzLi4uXG4gICAgICAgIGNvbnN0IGlucHV0T3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgYnJvd3NlcjogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLmJyb3dzZXIgPSBpbnB1dE9wdGlvbnMuYnJvd3NlciB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgdGhpcy5ub2RlID0gIXRoaXMuYnJvd3NlcjtcbiAgICAgICAgaWYgKHRoaXMuYnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbkhpbnQgPSBnZXRMb2NhdGlvbkhpbnQob3B0aW9ucz8ubG9jYXRpb25IaW50VXJsLCBvcHRpb25zPy5sb2NhdGlvbkhpbnRUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSwgLy8gbWFraW5nIHN1cmUgY29va2llcyBhcmUgbm90IHNlbnRcbiAgICAgICAgICAgIHdhcm1VcDogZmFsc2UsXG4gICAgICAgICAgICAuLi5pbnB1dE9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUgJiYgIXRoaXMub3B0aW9ucy5odHRwc0FnZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7XG4gICAgICAgICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtlZXBBbGl2ZU1zZWNzOiAzMDAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRCYXNlVVJMKHRoaXMub3B0aW9ucy5iYXNlVVJMIHx8ICdodHRwczovL3ZpZGVvLnN0cmVhbS1pby1hcGkuY29tL3ZpZGVvJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuU1RSRUFNX0xPQ0FMX1RFU1RfUlVOKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJhc2VVUkwoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAzMC92aWRlbycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuU1RSRUFNX0xPQ0FMX1RFU1RfSE9TVCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCYXNlVVJMKGBodHRwOi8vJHtwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9IT1NUfS92aWRlb2ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXhpb3NJbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBiYXNlVVJMOiB0aGlzLmJhc2VVUkwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXUyBjb25uZWN0aW9uIGlzIGluaXRpYWxpemVkIHdoZW4gc2V0VXNlciBpcyBjYWxsZWRcbiAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLndzUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0VXNlclByb21pc2UgPSBudWxsO1xuICAgICAgICAvLyBtYXBwaW5nIGJldHdlZW4gY2hhbm5lbCBncm91cHMgYW5kIGNvbmZpZ3NcbiAgICAgICAgdGhpcy5hbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmUgPVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zPy5wZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmU7XG4gICAgICAgIC8vIElmIGl0IGlzIGEgc2VydmVyLXNpZGUgY2xpZW50LCB0aGVuIGxldHMgaW5pdGlhbGl6ZSB0aGUgdG9rZW5NYW5hZ2VyLCBzaW5jZSB0b2tlbiB3aWxsIGJlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmcm9tIHNlY3JldC5cbiAgICAgICAgdGhpcy50b2tlbk1hbmFnZXIgPSBuZXcgVG9rZW5NYW5hZ2VyKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgdGhpcy5pbnNpZ2h0TWV0cmljcyA9IG5ldyBJbnNpZ2h0TWV0cmljcygpO1xuICAgICAgICB0aGlzLmRlZmF1bHRXU1RpbWVvdXRXaXRoRmFsbGJhY2sgPSA2MDAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRXU1RpbWVvdXQgPSAxNTAwMDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBpc0Z1bmN0aW9uKGlucHV0T3B0aW9ucy5sb2dnZXIpXG4gICAgICAgICAgICA/IGlucHV0T3B0aW9ucy5sb2dnZXJcbiAgICAgICAgICAgIDogKCkgPT4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQSBgU3RyZWFtVmlkZW9DbGllbnRgIGluc3RhbmNlIGxldHMgeW91IGNvbW11bmljYXRlIHdpdGggb3VyIEFQSSwgYW5kIGF1dGhlbnRpY2F0ZSB1c2Vycy5cbiAqL1xuY2xhc3MgU3RyZWFtVmlkZW9DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleU9yQXJncywgb3B0cykge1xuICAgICAgICB0aGlzLmxvZ0xldmVsID0gJ3dhcm4nO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2Nvbm5lY3RzIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIHVzZXIgZnJvbSB0aGUgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkLCB0aGUgY29ubmVjdGVkIHVzZXIgW3N0YXRlIHZhcmlhYmxlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKSB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNzZnVsIGRpc2Nvbm5lY3Rpb24uXG4gICAgICAgICAqICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJlYW1DbGllbnQudXNlciAmJiAhdGhpcy5jb25uZWN0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RVc2VyID0gKCkgPT4gdGhpcy5zdHJlYW1DbGllbnQuZGlzY29ubmVjdFVzZXIodGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5jb25uZWN0aW9uUHJvbWlzZVxuICAgICAgICAgICAgICAgID8gdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IGRpc2Nvbm5lY3RVc2VyKCkpXG4gICAgICAgICAgICAgICAgOiBkaXNjb25uZWN0VXNlcigpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZS5maW5hbGx5KCgpID0+ICh0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLmZvckVhY2goKHVucmVnaXN0ZXIpID0+IHVucmVnaXN0ZXIoKSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5zZXRDb25uZWN0ZWRVc2VyKHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIHN1YnNjcmliZSB0byBXZWJTb2NrZXQgZXZlbnRzIHByb3ZpZGVkIGJ5IHRoZSBBUEkuXG4gICAgICAgICAqIFRvIHJlbW92ZSBhIHN1YnNjcmlwdGlvbiwgY2FsbCB0aGUgYG9mZmAgbWV0aG9kIG9yLCBleGVjdXRlIHRoZSByZXR1cm5lZCB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCBzdWJzY3JpYmluZyB0byBXZWJTb2NrZXQgZXZlbnRzIGlzIGFuIGFkdmFuY2VkIHVzZS1jYXNlLCBmb3IgbW9zdCB1c2UtY2FzZXMgaXQgc2hvdWxkIGJlIGVub3VnaCB0byB3YXRjaCBmb3IgY2hhbmdlcyBpbiB0aGUgcmVhY3RpdmUgW3N0YXRlIHN0b3JlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZSBvciAnYWxsJy5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAgICAgKiBAcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50Lm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBmb3IgV2ViU29ja2V0IGV2ZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBieSB0aGUgYG9uYCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgdGhlIGV2ZW50IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgd2hpY2ggd2FzIHBhc3NlZCB0byB0aGUgYG9uYCBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZiA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgY2FsbC5cbiAgICAgICAgICogQHBhcmFtIGlkIHRoZSBpZCBvZiB0aGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FsbCA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgZ3Vlc3QgdXNlciB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGd1ZXN0IHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUd1ZXN0VXNlciA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZG9BeGlvc1JlcXVlc3QoJ3Bvc3QnLCAnL2d1ZXN0JywgZGF0YSwgeyBwdWJsaWNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgcXVlcnkgdGhlIEFQSSBmb3IgY2FsbHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSBxdWVyeSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeUNhbGxzID0gYXN5bmMgKGRhdGEgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvY2FsbHMnLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxzID0gcmVzcG9uc2UuY2FsbHMubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGMuY2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYy5jYWxsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnM6IGMubWVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgb3duQ2FwYWJpbGl0aWVzOiBjLm93bl9jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoaW5nOiBkYXRhLndhdGNoLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjLmNhbGwpO1xuICAgICAgICAgICAgICAgIGNhbGwuYXBwbHlEZXZpY2VDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS53YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUucmVnaXN0ZXJDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBjYWxsczogY2FsbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNhbGwgc3RhdGlzdGljcyByZXBvcnRzIG1hdGNoaW5nIGEgcGFydGljdWxhciBjb25kaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIEZpbHRlciBhbmQgc29ydCBjb25kaXRpb25zIGZvciByZXRyaWV2aW5nIGF2YWlsYWJsZSBjYWxsIHJlcG9ydCBzdW1tYXJpZXMuXG4gICAgICAgICAqIEByZXR1cm5zIExpc3Qgd2l0aCBzdW1tYXJ5IG9mIGF2YWlsYWJsZSBjYWxsIHJlcG9ydHMgbWF0Y2hpbmcgdGhlIGNvbmRpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVlcnlDYWxsU3RhdHMgPSBhc3luYyAoZGF0YSA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgL2NhbGwvc3RhdHNgLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBkYXRhIGNlbnRlcnMgYXZhaWxhYmxlIGZvciBob3N0aW5nIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGdlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoYC9lZGdlc2ApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogYWRkRGV2aWNlIC0gQWRkcyBhIHB1c2ggZGV2aWNlIGZvciBhIHVzZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgZGV2aWNlIGlkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyIHRoZSBwdXNoIHByb3ZpZGVyIG5hbWUgKGVnLiBhcG4sIGZpcmViYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlcl9uYW1lIHVzZXIgcHJvdmlkZWQgcHVzaCBwcm92aWRlciBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcklEXSB0aGUgdXNlciBpZCAoZGVmYXVsdHMgdG8gY3VycmVudCB1c2VyKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2b2lwX3Rva2VuXSBlbmFibGVzIHVzZSBvZiBWb0lQIHRva2VuIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMgb24gaU9TIHBsYXRmb3JtXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZERldmljZSA9IGFzeW5jIChpZCwgcHVzaF9wcm92aWRlciwgcHVzaF9wcm92aWRlcl9uYW1lLCB1c2VySUQsIHZvaXBfdG9rZW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvZGV2aWNlcycsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBwdXNoX3Byb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHZvaXBfdG9rZW4sXG4gICAgICAgICAgICAgICAgLi4uKHVzZXJJRCAhPSBudWxsID8geyB1c2VyX2lkOiB1c2VySUQgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi4ocHVzaF9wcm92aWRlcl9uYW1lICE9IG51bGwgPyB7IHB1c2hfcHJvdmlkZXJfbmFtZSB9IDoge30pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXREZXZpY2VzIC0gUmV0dXJucyB0aGUgZGV2aWNlcyBhc3NvY2lhdGVkIHdpdGggYSBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIFVzZXIgSUQuIE9ubHkgd29ya3Mgb24gc2VydmVyc2lkZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXREZXZpY2VzID0gYXN5bmMgKHVzZXJJRCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LmdldCgnL2RldmljZXMnLCB1c2VySUQgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogcmVtb3ZlRGV2aWNlIC0gUmVtb3ZlcyB0aGUgZGV2aWNlIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGRldmljZSBpZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gVGhlIHVzZXIgaWQuIE9ubHkgc3BlY2lmeSB0aGlzIGZvciBzZXJ2ZXJzaWRlIHJlcXVlc3RzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZURldmljZSA9IGFzeW5jIChpZCwgdXNlcklEKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQuZGVsZXRlKCcvZGV2aWNlcycsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAuLi4odXNlcklEID8geyB1c2VyX2lkOiB1c2VySUQgfSA6IHt9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSByaW5naW5nIGNhbGxzIGZyb20gcHVzaCBub3RpZmljYXRpb25zLiBJZiB0aGUgY2FsbCBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBkbyBub3RoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbF9jaWRcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25SaW5naW5nQ2FsbCA9IGFzeW5jIChjYWxsX2NpZCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgd2UgZmluZCB0aGUgY2FsbCBhbmQgaXMgYWxyZWFkeSByaW5naW5nLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBjYWxsXG4gICAgICAgICAgICAvLyBhcyBjbGllbnQgd291bGQgaGF2ZSByZWNlaXZlZCB0aGUgY2FsbC5yaW5nIHN0YXRlIGJlY2F1c2UgdGhlIGFwcCBoYWQgV1MgYWxpdmUgd2hlbiByZWNlaXZpbmcgcHVzaCBub3RpZmljYXRpb25zXG4gICAgICAgICAgICBsZXQgY2FsbCA9IHRoaXMucmVhZE9ubHlTdGF0ZVN0b3JlLmNhbGxzLmZpbmQoKGMpID0+IGMuY2lkID09PSBjYWxsX2NpZCAmJiBjLnJpbmdpbmcpO1xuICAgICAgICAgICAgaWYgKCFjYWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGl0IG1lYW5zIHRoYXQgV1MgaXMgbm90IGFsaXZlIHdoZW4gcmVjZWl2aW5nIHRoZSBwdXNoIG5vdGlmaWNhdGlvbnMgYW5kIHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGNhbGxcbiAgICAgICAgICAgICAgICBjb25zdCBbY2FsbFR5cGUsIGNhbGxJZF0gPSBjYWxsX2NpZC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGNhbGwgPSBuZXcgQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGNhbGxUeXBlLFxuICAgICAgICAgICAgICAgICAgICBpZDogY2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgICAgICAgICAgICByaW5naW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuZ2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbm5lY3RzIHRoZSBnaXZlbiBhbm9ueW1vdXMgdXNlciB0byB0aGUgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlciB0aGUgdXNlciB0byBjb25uZWN0LlxuICAgICAgICAgKiBAcGFyYW0gdG9rZW5PclByb3ZpZGVyIGEgdG9rZW4gb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdEFub255bW91c1VzZXIgPSBhc3luYyAodXNlciwgdG9rZW5PclByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0QW5vbnltb3VzVXNlciA9ICgpID0+IHRoaXMuc3RyZWFtQ2xpZW50LmNvbm5lY3RBbm9ueW1vdXNVc2VyKHVzZXIsIHRva2VuT3JQcm92aWRlcik7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZVxuICAgICAgICAgICAgICAgID8gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IGNvbm5lY3RBbm9ueW1vdXNVc2VyKCkpXG4gICAgICAgICAgICAgICAgOiBjb25uZWN0QW5vbnltb3VzVXNlcigpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZS5maW5hbGx5KCgpID0+ICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxvZ2dlciA9IGxvZ1RvQ29uc29sZTtcbiAgICAgICAgbGV0IGxvZ0xldmVsID0gJ3dhcm4nO1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleU9yQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gb3B0cz8ubG9nTGV2ZWwgfHwgbG9nTGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIgPSBvcHRzPy5sb2dnZXIgfHwgbG9nZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTGV2ZWwgPSBhcGlLZXlPckFyZ3Mub3B0aW9ucz8ubG9nTGV2ZWwgfHwgbG9nTGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIgPSBhcGlLZXlPckFyZ3Mub3B0aW9ucz8ubG9nZ2VyIHx8IGxvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBzZXRMb2dnZXIobG9nZ2VyLCBsb2dMZXZlbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnY2xpZW50J10pO1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleU9yQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gbmV3IFN0cmVhbUNsaWVudChhcGlLZXlPckFyZ3MsIHtcbiAgICAgICAgICAgICAgICBwZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IG5ldyBTdHJlYW1DbGllbnQoYXBpS2V5T3JBcmdzLmFwaUtleSwge1xuICAgICAgICAgICAgICAgIHBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5hcGlLZXlPckFyZ3Mub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZGtJbmZvID0gZ2V0U2RrSW5mbygpO1xuICAgICAgICAgICAgaWYgKHNka0luZm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNsaWVudC5zZXRVc2VyQWdlbnQodGhpcy5zdHJlYW1DbGllbnQuZ2V0VXNlckFnZW50KCkgK1xuICAgICAgICAgICAgICAgICAgICBgLXZpZGVvLSR7U2RrVHlwZVtzZGtJbmZvLnR5cGVdLnRvTG93ZXJDYXNlKCl9LXNkay0ke3Nka0luZm8ubWFqb3J9LiR7c2RrSW5mby5taW5vcn0uJHtzZGtJbmZvLnBhdGNofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZSA9IG5ldyBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUoKTtcbiAgICAgICAgdGhpcy5yZWFkT25seVN0YXRlU3RvcmUgPSBuZXcgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUodGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXlPckFyZ3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXBpS2V5T3JBcmdzLnVzZXI7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGFwaUtleU9yQXJncy50b2tlbiB8fCBhcGlLZXlPckFyZ3MudG9rZW5Qcm92aWRlcjtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VXNlcih1c2VyLCB0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZWFjdGl2ZSBzdGF0ZSBzdG9yZSwgdXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0byB0aGUgY2xpZW50IHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkT25seVN0YXRlU3RvcmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIHRoZSBnaXZlbiB1c2VyIHRvIHRoZSBjbGllbnQuXG4gICAgICogT25seSBvbmUgdXNlciBjYW4gY29ubmVjdCBhdCBhIHRpbWUsIGlmIHlvdSB3YW50IHRvIGNoYW5nZSB1c2VycywgY2FsbCBgZGlzY29ubmVjdFVzZXJgIGJlZm9yZSBjb25uZWN0aW5nIGEgbmV3IHVzZXIuXG4gICAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bCwgdGhlIGNvbm5lY3RlZCB1c2VyIFtzdGF0ZSB2YXJpYWJsZV0oI3JlYWRvbmx5c3RhdGVzdG9yZSkgd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXIgdGhlIHVzZXIgdG8gY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW4gYSB0b2tlbiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3RVc2VyKHVzZXIsIHRva2VuKSB7XG4gICAgICAgIGlmICh1c2VyLnR5cGUgPT09ICdhbm9ueW1vdXMnKSB7XG4gICAgICAgICAgICB1c2VyLmlkID0gJyFhbm9uJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RBbm9ueW1vdXNVc2VyKHVzZXIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29ubmVjdFVzZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdFVzZXIodXNlciwgdG9rZW4pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXNlci50eXBlID09PSAnZ3Vlc3QnKSB7XG4gICAgICAgICAgICBjb25uZWN0VXNlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdEd1ZXN0VXNlcih1c2VyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuZGlzY29ubmVjdGlvblByb21pc2VcbiAgICAgICAgICAgID8gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IGNvbm5lY3RVc2VyKCkpXG4gICAgICAgICAgICA6IGNvbm5lY3RVc2VyKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2U/LmZpbmFsbHkoKCkgPT4gKHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICAgICAgY29uc3QgY29ubmVjdFVzZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgICAgIC8vIGNvbm5lY3RVc2VyUmVzcG9uc2Ugd2lsbCBiZSB2b2lkIGlmIGNvbm5lY3RVc2VyIGNhbGxlZCB0d2ljZSBmb3IgdGhlIHNhbWUgdXNlclxuICAgICAgICBpZiAoY29ubmVjdFVzZXJSZXNwb25zZT8ubWUpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5zZXRDb25uZWN0ZWRVc2VyKGNvbm5lY3RVc2VyUmVzcG9uc2UubWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3Rlci5wdXNoKHRoaXMub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm9ubGluZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxzVG9SZVdhdGNoID0gdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLmNhbGxzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNhbGwpID0+IGNhbGwud2F0Y2hpbmcpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGNhbGwpID0+IGNhbGwuY2lkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBSZXdhdGNoaW5nIGNhbGxzIGFmdGVyIGNvbm5lY3Rpb24gY2hhbmdlZCAke2NhbGxzVG9SZVdhdGNoLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxzVG9SZVdhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeUNhbGxzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyX2NvbmRpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ6IHsgJGluOiBjYWxsc1RvUmVXYXRjaCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQ6IFt7IGZpZWxkOiAnY2lkJywgZGlyZWN0aW9uOiAxIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnRmFpbGVkIHRvIHJlLXdhdGNoIGNhbGxzJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3Rlci5wdXNoKHRoaXMub24oJ2NhbGwuY3JlYXRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYWxsLCBtZW1iZXJzIH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmICh1c2VyLmlkID09PSBjYWxsLmNyZWF0ZWRfYnkuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdSZWNlaXZlZCBgY2FsbC5jcmVhdGVkYCBzZW50IGJ5IHRoZSBjdXJyZW50IHVzZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBOZXcgY2FsbCBjcmVhdGVkIGFuZCByZWdpc3RlcmVkOiAke2NhbGwuY2lkfWApO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICAgICAgICAgIHR5cGU6IGNhbGwudHlwZSxcbiAgICAgICAgICAgICAgICBpZDogY2FsbC5pZCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzLFxuICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5ld0NhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5yZWdpc3RlckNhbGwobmV3Q2FsbCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2godGhpcy5vbignY2FsbC5yaW5nJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHVzZXIuaWQgPT09IGNhbGwuY3JlYXRlZF9ieS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsICdSZWNlaXZlZCBgY2FsbC5yaW5nYCBzZW50IGJ5IHRoZSBjdXJyZW50IHVzZXIgc28gaWdub3JpbmcgdGhlIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGNhbGwgbWlnaHQgYWxyZWFkeSBiZSB0cmFja2VkIGJ5IHRoZSBjbGllbnQsXG4gICAgICAgICAgICAvLyBpZiBgY2FsbC5jcmVhdGVkYCB3YXMgcmVjZWl2ZWQgYmVmb3JlIGBjYWxsLnJpbmdgLlxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBjbGVhbnVwIHRoZSBhbHJlYWR5IHRyYWNrZWQgY2FsbC5cbiAgICAgICAgICAgIGNvbnN0IHByZXZDYWxsID0gdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLmZpbmRDYWxsKGNhbGwudHlwZSwgY2FsbC5pZCk7XG4gICAgICAgICAgICBhd2FpdCBwcmV2Q2FsbD8ubGVhdmUoeyByZWFzb246ICdjbGVhbmluZy11cCBpbiBjYWxsLnJpbmcnIH0pO1xuICAgICAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHRoZUNhbGwgPSBuZXcgQ2FsbCh7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICB0eXBlOiBjYWxsLnR5cGUsXG4gICAgICAgICAgICAgICAgaWQ6IGNhbGwuaWQsXG4gICAgICAgICAgICAgICAgbWVtYmVycyxcbiAgICAgICAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgICAgICAgIHJpbmdpbmc6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoZUNhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsKTtcbiAgICAgICAgICAgIC8vIHdlIGZldGNoIHRoZSBsYXRlc3QgbWV0YWRhdGEgZm9yIHRoZSBjYWxsIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgYXdhaXQgdGhlQ2FsbC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5yZWdpc3RlckNhbGwodGhlQ2FsbCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RVc2VyUmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZERldmljZSAtIEFkZHMgYSBwdXNoIGRldmljZSBmb3IgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlciB0aGUgcHVzaCBwcm92aWRlciBuYW1lIChlZy4gYXBuLCBmaXJlYmFzZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlcl9uYW1lIHVzZXIgcHJvdmlkZWQgcHVzaCBwcm92aWRlciBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIHRoZSB1c2VyIGlkIChkZWZhdWx0cyB0byBjdXJyZW50IHVzZXIpXG4gICAgICovXG4gICAgYXN5bmMgYWRkVm9pcERldmljZShpZCwgcHVzaF9wcm92aWRlciwgcHVzaF9wcm92aWRlcl9uYW1lLCB1c2VySUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRkRGV2aWNlKGlkLCBwdXNoX3Byb3ZpZGVyLCBwdXNoX3Byb3ZpZGVyX25hbWUsIHVzZXJJRCwgdHJ1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgdGhlIGBAc3RyZWFtLWlvL25vZGUtc2RrYCBwYWNrYWdlIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL2FwaS9cbiAqL1xuY2xhc3MgU3RyZWFtVmlkZW9TZXJ2ZXJDbGllbnQgZXh0ZW5kcyBTdHJlYW1WaWRlb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHsgYXBpS2V5LCBvcHRpb25zIH0pO1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoJy9jYWxsdHlwZXMnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDYWxsVHlwZSA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KGAvY2FsbHR5cGVzLyR7bmFtZX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDYWxsVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdCgnL2NhbGx0eXBlcycsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUNhbGxUeXBlID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5kZWxldGUoYC9jYWxsdHlwZXMvJHtuYW1lfWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxUeXBlID0gKG5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wdXQoYC9jYWxsdHlwZXMvJHtuYW1lfWAsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RFeHRlcm5hbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KCcvZXh0ZXJuYWxfc3RvcmFnZScpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUV4dGVybmFsU3RvcmFnZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdCgnL2V4dGVybmFsX3N0b3JhZ2UnLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2UgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmRlbGV0ZShgL2V4dGVybmFsX3N0b3JhZ2UvJHtuYW1lfWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucHV0KGAvZXh0ZXJuYWxfc3RvcmFnZS8ke25hbWV9YCwgcmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlcm5hbFN0b3JhZ2UgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgL2V4dGVybmFsX3N0b3JhZ2UvJHtuYW1lfS9jaGVja2ApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGVUb2tlbiAtIENyZWF0ZXMgYSB0b2tlbiB0byBhdXRoZW50aWNhdGUgdGhpcyB1c2VyLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgc2VydmVyIHNpZGUuXG4gICAgICogVGhlIHJlc3VsdGluZyB0b2tlbiBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgc2lkZSB3aGVuIHRoZSB1c2VycyByZWdpc3RlciBvciBsb2dzIGluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCBUaGUgVXNlciBJRFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZXhwXSBUaGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdG9rZW4gZXhwcmVzc2VkIGluIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2lhdF0gVGhlIHRpbWVzdGFtcCB3aGVuIGEgdG9rZW4gaGFzIGJlZW4gaXNzdWVkXG4gICAgICogQHBhcmFtIGNhbGxfY2lkcyBmb3IgYW5vbnltb3VzIHRva2VucyB5b3UgaGF2ZSB0byBwcm92aWRlIHRoZSBjYWxsIGNpZHMgdGhlIHVzZSBjYW4gam9pblxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIGEgdG9rZW5cbiAgICAgKi9cbiAgICBjcmVhdGVUb2tlbih1c2VySUQsIGV4cCwgaWF0LCBjYWxsX2NpZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwLCBpYXQsIGNhbGxfY2lkcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0sIGJyb3dzZXJzIGFzIEJyb3dzZXJzLCBDYWxsLCBDYWxsU3RhdGUsIENhbGxUeXBlLCBDYWxsVHlwZXMsIENhbGxpbmdTdGF0ZSwgQ2FtZXJhTWFuYWdlciwgQ2FtZXJhTWFuYWdlclN0YXRlLCBDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgRGVib3VuY2VUeXBlLCBEeW5hc2NhbGVNYW5hZ2VyLCBFcnJvckZyb21SZXNwb25zZSwgSW5wdXRNZWRpYURldmljZU1hbmFnZXIsIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUsIExheW91dFNldHRpbmdzTmFtZUVudW0sIExheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtLCBNaWNyb3Bob25lTWFuYWdlciwgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSwgT3duQ2FwYWJpbGl0eSwgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtLCByeFV0aWxzIGFzIFJ4VXRpbHMsIFNjcmVlblNoYXJlTWFuYWdlciwgU2NyZWVuU2hhcmVTdGF0ZSwgZXZlbnRzIGFzIFNmdUV2ZW50cywgbW9kZWxzIGFzIFNmdU1vZGVscywgU3BlYWtlck1hbmFnZXIsIFNwZWFrZXJTdGF0ZSwgU3RyZWFtU2Z1Q2xpZW50LCBTdHJlYW1WaWRlb0NsaWVudCwgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUsIFN0cmVhbVZpZGVvU2VydmVyQ2xpZW50LCBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUsIFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtLCBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0sIFZpZXdwb3J0VHJhY2tlciwgVmlzaWJpbGl0eVN0YXRlLCBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQsIGNvbWJpbmVDb21wYXJhdG9ycywgY29uZGl0aW9uYWwsIGNyZWF0ZVNvdW5kRGV0ZWN0b3IsIGRlZmF1bHRTb3J0UHJlc2V0LCBkZXNjZW5kaW5nLCBkZXZpY2VJZHMkLCBkaXNwb3NlT2ZNZWRpYVN0cmVhbSwgZG9taW5hbnRTcGVha2VyLCBnZXRBdWRpb0RldmljZXMsIGdldEF1ZGlvT3V0cHV0RGV2aWNlcywgZ2V0QXVkaW9TdHJlYW0sIGdldENsaWVudERldGFpbHMsIGdldERldmljZUluZm8sIGdldExvZ2dlciwgZ2V0T1NJbmZvLCBnZXRTY3JlZW5TaGFyZVN0cmVhbSwgZ2V0U2RrSW5mbywgZ2V0VmlkZW9EZXZpY2VzLCBnZXRWaWRlb1N0cmVhbSwgZ2V0V2ViUlRDSW5mbywgbGl2ZXN0cmVhbU9yQXVkaW9Sb29tU29ydFByZXNldCwgbG9nTGV2ZWxzLCBsb2dUb0NvbnNvbGUsIG5hbWUsIG5vb3BDb21wYXJhdG9yLCBwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0LCBwaW5uZWQsIHB1Ymxpc2hpbmdBdWRpbywgcHVibGlzaGluZ1ZpZGVvLCByZWFjdGlvblR5cGUsIHJvbGUsIHNjcmVlblNoYXJpbmcsIHNldERldmljZUluZm8sIHNldExvZ0xldmVsLCBzZXRMb2dnZXIsIHNldE9TSW5mbywgc2V0U2RrSW5mbywgc2V0V2ViUlRDSW5mbywgc3BlYWtlckxheW91dFNvcnRQcmVzZXQsIHNwZWFraW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNZXNzYWdlVHlwZSIsImlzSnNvbk9iamVjdCIsInR5cGVvZkpzb25WYWx1ZSIsInJlZmxlY3Rpb25NZXJnZVBhcnRpYWwiLCJVbmtub3duRmllbGRIYW5kbGVyIiwiV2lyZVR5cGUiLCJQYkxvbmciLCJTZXJ2aWNlVHlwZSIsInN0YWNrSW50ZXJjZXB0IiwiYXhpb3MiLCJBeGlvc0hlYWRlcnMiLCJBeGlvc0Vycm9yIiwiVHdpcnBGZXRjaFRyYW5zcG9ydCIsIlJlcGxheVN1YmplY3QiLCJjb21iaW5lTGF0ZXN0IiwiQmVoYXZpb3JTdWJqZWN0IiwibWFwIiwibWFwJDEiLCJzaGFyZVJlcGxheSIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwidGFrZVdoaWxlIiwiZGlzdGluY3RVbnRpbEtleUNoYW5nZWQiLCJtZXJnZSIsImZyb20iLCJPYnNlcnZhYmxlIiwiZGVib3VuY2VUaW1lIiwiY29uY2F0TWFwIiwicGFpcndpc2UiLCJvZiIsImZpbHRlciIsImRlYm91bmNlIiwidGltZXIiLCJTRFAiLCJVQVBhcnNlciIsIldlYlNvY2tldCIsImh0dHBzIiwiand0IiwiZnJvbUJ5dGVBcnJheSIsIkF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSIsIlNQRUFLRVIiLCJFQVJQSUVDRSIsIkF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0iLCJDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSIsIkZJUkVCQVNFIiwiQVBOIiwiSFVBV0VJIiwiWElBT01JIiwiTGF5b3V0U2V0dGluZ3NOYW1lRW51bSIsIlNQT1RMSUdIVCIsIkdSSUQiLCJTSU5HTEVfUEFSVElDSVBBTlQiLCJNT0JJTEUiLCJDVVNUT00iLCJMYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSIsIk93bkNhcGFiaWxpdHkiLCJCTE9DS19VU0VSUyIsIkNSRUFURV9DQUxMIiwiQ1JFQVRFX1JFQUNUSU9OIiwiRU5EX0NBTEwiLCJKT0lOX0JBQ0tTVEFHRSIsIkpPSU5fQ0FMTCIsIkpPSU5fRU5ERURfQ0FMTCIsIk1VVEVfVVNFUlMiLCJQSU5fRk9SX0VWRVJZT05FIiwiUkVBRF9DQUxMIiwiUkVNT1ZFX0NBTExfTUVNQkVSIiwiU0NSRUVOU0hBUkUiLCJTRU5EX0FVRElPIiwiU0VORF9WSURFTyIsIlNUQVJUX0JST0FEQ0FTVF9DQUxMIiwiU1RBUlRfUkVDT1JEX0NBTEwiLCJTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEwiLCJTVE9QX0JST0FEQ0FTVF9DQUxMIiwiU1RPUF9SRUNPUkRfQ0FMTCIsIlNUT1BfVFJBTlNDUklQVElPTl9DQUxMIiwiVVBEQVRFX0NBTEwiLCJVUERBVEVfQ0FMTF9NRU1CRVIiLCJVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUyIsIlVQREFURV9DQUxMX1NFVFRJTkdTIiwiUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0iLCJBVkFJTEFCTEUiLCJESVNBQkxFRCIsIkFVVE9fT04iLCJSZWNvcmRTZXR0aW5nc1JlcXVlc3RRdWFsaXR5RW51bSIsIl8zNjBQIiwiXzQ4MFAiLCJfNzIwUCIsIl8xMDgwUCIsIl8xNDQwUCIsIlRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtIiwiVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtIiwiVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0iLCJGUk9OVCIsIkJBQ0siLCJFWFRFUk5BTCIsIlZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSIsIkVycm9yRnJvbVJlc3BvbnNlIiwiRXJyb3IiLCJOdWxsVmFsdWUiLCJTdHJ1Y3QkVHlwZSIsImNvbnN0cnVjdG9yIiwibm8iLCJuYW1lIiwia2luZCIsIksiLCJWIiwiVCIsIlZhbHVlIiwiaW50ZXJuYWxKc29uV3JpdGUiLCJtZXNzYWdlIiwib3B0aW9ucyIsImpzb24iLCJrIiwidiIsIk9iamVjdCIsImVudHJpZXMiLCJmaWVsZHMiLCJ0b0pzb24iLCJpbnRlcm5hbEpzb25SZWFkIiwidGFyZ2V0IiwiZ2xvYmFsVGhpcyIsInR5cGVOYW1lIiwiY3JlYXRlIiwiZnJvbUpzb24iLCJ2YWx1ZSIsIm1lc3NhZ2VQcm90b3R5cGUiLCJ1bmRlZmluZWQiLCJpbnRlcm5hbEJpbmFyeVJlYWQiLCJyZWFkZXIiLCJsZW5ndGgiLCJlbmQiLCJwb3MiLCJmaWVsZE5vIiwid2lyZVR5cGUiLCJ0YWciLCJiaW5hcnlSZWFkTWFwMSIsInUiLCJyZWFkVW5rbm93bkZpZWxkIiwiZCIsInNraXAiLCJvblJlYWQiLCJsZW4iLCJ1aW50MzIiLCJrZXkiLCJ2YWwiLCJzdHJpbmciLCJpbnRlcm5hbEJpbmFyeVdyaXRlIiwid3JpdGVyIiwia2V5cyIsIkxlbmd0aERlbGltaXRlZCIsImZvcmsiLCJqb2luIiwid3JpdGVVbmtub3duRmllbGRzIiwib25Xcml0ZSIsIlN0cnVjdCIsIlZhbHVlJFR5cGUiLCJvbmVvZiIsIkxpc3RWYWx1ZSIsIm9uZW9mS2luZCIsImJvb2xWYWx1ZSIsIm51bWJlclZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdHJpbmdWYWx1ZSIsImxpc3RWYWx1ZUZpZWxkIiwiZmluZCIsImYiLCJsaXN0VmFsdWUiLCJzdHJ1Y3RWYWx1ZUZpZWxkIiwic3RydWN0VmFsdWUiLCJudWxsVmFsdWUiLCJOVUxMX1ZBTFVFIiwiQXJyYXkiLCJpc0FycmF5IiwiaW50MzIiLCJkb3VibGUiLCJib29sIiwiVmFyaW50IiwiQml0NjQiLCJMaXN0VmFsdWUkVHlwZSIsInJlcGVhdCIsInZhbHVlcyIsInB1c2giLCJpIiwiVGltZXN0YW1wJFR5cGUiLCJub3ciLCJtc2ciLCJtcyIsIkRhdGUiLCJzZWNvbmRzIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJuYW5vcyIsInRvRGF0ZSIsInRvTnVtYmVyIiwiY2VpbCIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJwYXJzZSIsInoiLCJuYW5vc1N0ciIsInN1YnN0cmluZyIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsIm1hdGNoZXMiLCJtYXRjaCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnQ2NCIsIlRpbWVzdGFtcCIsIlBlZXJUeXBlIiwiQ29ubmVjdGlvblF1YWxpdHkiLCJWaWRlb1F1YWxpdHkiLCJUcmFja1R5cGUiLCJFcnJvckNvZGUiLCJTZGtUeXBlIiwiVHJhY2tVbnB1Ymxpc2hSZWFzb24iLCJHb0F3YXlSZWFzb24iLCJDYWxsU3RhdGUkVHlwZSIsIlBhcnRpY2lwYW50IiwiUGFydGljaXBhbnRDb3VudCIsIlBpbiIsInBhcnRpY2lwYW50cyIsInBpbnMiLCJzdGFydGVkQXQiLCJwYXJ0aWNpcGFudENvdW50IiwiQ2FsbFN0YXRlJDEiLCJQYXJ0aWNpcGFudENvdW50JFR5cGUiLCJ0b3RhbCIsImFub255bW91cyIsIlBpbiRUeXBlIiwidXNlcklkIiwic2Vzc2lvbklkIiwiUGFydGljaXBhbnQkVHlwZSIsInB1Ymxpc2hlZFRyYWNrcyIsInRyYWNrTG9va3VwUHJlZml4IiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc1NwZWFraW5nIiwiaXNEb21pbmFudFNwZWFrZXIiLCJhdWRpb0xldmVsIiwiaW1hZ2UiLCJyb2xlcyIsImUiLCJqb2luZWRBdCIsImZsb2F0IiwiY3VzdG9tIiwiQml0MzIiLCJTdHJlYW1RdWFsaXR5JFR5cGUiLCJ2aWRlb1F1YWxpdHkiLCJTdHJlYW1RdWFsaXR5IiwiVmlkZW9EaW1lbnNpb24kVHlwZSIsIndpZHRoIiwiaGVpZ2h0IiwiVmlkZW9EaW1lbnNpb24iLCJWaWRlb0xheWVyJFR5cGUiLCJyaWQiLCJiaXRyYXRlIiwiZnBzIiwicXVhbGl0eSIsInZpZGVvRGltZW5zaW9uIiwiVmlkZW9MYXllciIsIkNvZGVjJFR5cGUiLCJwYXlsb2FkVHlwZSIsImZtdHBMaW5lIiwiY2xvY2tSYXRlIiwiZW5jb2RpbmdQYXJhbWV0ZXJzIiwiZmVlZGJhY2tzIiwiQ29kZWMiLCJJQ0VUcmlja2xlJFR5cGUkMSIsIklDRVRyaWNrbGUkVHlwZSIsInBlZXJUeXBlIiwiaWNlQ2FuZGlkYXRlIiwiSUNFVHJpY2tsZSQxIiwiVHJhY2tJbmZvJFR5cGUiLCJ0cmFja0lkIiwidHJhY2tUeXBlIiwibGF5ZXJzIiwibWlkIiwiZHR4Iiwic3RlcmVvIiwicmVkIiwiVHJhY2tJbmZvIiwiQ2FsbCRUeXBlIiwidHlwZSIsImlkIiwiY3JlYXRlZEJ5VXNlcklkIiwiaG9zdFVzZXJJZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIkNhbGwkMSIsIkVycm9yJFR5cGUkMSIsIkVycm9yJFR5cGUiLCJjb2RlIiwic2hvdWxkUmV0cnkiLCJFcnJvciQyIiwiQ2xpZW50RGV0YWlscyRUeXBlIiwiU2RrIiwiT1MiLCJCcm93c2VyIiwiRGV2aWNlIiwic2RrIiwib3MiLCJicm93c2VyIiwiZGV2aWNlIiwiQ2xpZW50RGV0YWlscyIsIlNkayRUeXBlIiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwiT1MkVHlwZSIsInZlcnNpb24iLCJhcmNoaXRlY3R1cmUiLCJCcm93c2VyJFR5cGUiLCJEZXZpY2UkVHlwZSIsIkNhbGxHcmFudHMkVHlwZSIsImNhblB1Ymxpc2hBdWRpbyIsImNhblB1Ymxpc2hWaWRlbyIsImNhblNjcmVlbnNoYXJlIiwiQ2FsbEdyYW50cyIsIm1vZGVscyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkNhbGwiLCJDYWxsU3RhdGUiLCJJQ0VUcmlja2xlIiwiU2VuZFN0YXRzUmVxdWVzdCRUeXBlIiwic3Vic2NyaWJlclN0YXRzIiwicHVibGlzaGVyU3RhdHMiLCJ3ZWJydGNWZXJzaW9uIiwic2RrVmVyc2lvbiIsIlNlbmRTdGF0c1JlcXVlc3QiLCJTZW5kU3RhdHNSZXNwb25zZSRUeXBlIiwiZXJyb3IiLCJTZW5kU3RhdHNSZXNwb25zZSIsIklDRVJlc3RhcnRSZXF1ZXN0JFR5cGUiLCJJQ0VSZXN0YXJ0UmVxdWVzdCIsIklDRVJlc3RhcnRSZXNwb25zZSRUeXBlIiwiSUNFUmVzdGFydFJlc3BvbnNlIiwiVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QkVHlwZSIsIlRyYWNrTXV0ZVN0YXRlIiwibXV0ZVN0YXRlcyIsIlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0IiwiVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJFR5cGUiLCJVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UiLCJUcmFja011dGVTdGF0ZSRUeXBlIiwibXV0ZWQiLCJBdWRpb011dGVDaGFuZ2VkJFR5cGUiLCJWaWRlb011dGVDaGFuZ2VkJFR5cGUiLCJVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCRUeXBlIiwiVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIiwidHJhY2tzIiwiVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QiLCJVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UkVHlwZSIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSIsIlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyRUeXBlIiwiZGltZW5zaW9uIiwiU2VuZEFuc3dlclJlcXVlc3QkVHlwZSIsInNkcCIsIlNlbmRBbnN3ZXJSZXF1ZXN0IiwiU2VuZEFuc3dlclJlc3BvbnNlJFR5cGUiLCJTZW5kQW5zd2VyUmVzcG9uc2UiLCJJQ0VUcmlja2xlUmVzcG9uc2UkVHlwZSIsIklDRVRyaWNrbGVSZXNwb25zZSIsIlNldFB1Ymxpc2hlclJlcXVlc3QkVHlwZSIsIlNldFB1Ymxpc2hlclJlcXVlc3QiLCJTZXRQdWJsaXNoZXJSZXNwb25zZSRUeXBlIiwiaWNlUmVzdGFydCIsIlNldFB1Ymxpc2hlclJlc3BvbnNlIiwiU2lnbmFsU2VydmVyIiwiSSIsIk8iLCJWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSIsIlNmdUV2ZW50JFR5cGUiLCJTdWJzY3JpYmVyT2ZmZXIiLCJQdWJsaXNoZXJBbnN3ZXIiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJBdWRpb0xldmVsQ2hhbmdlZCIsIkNoYW5nZVB1Ymxpc2hRdWFsaXR5IiwiUGFydGljaXBhbnRKb2luZWQiLCJQYXJ0aWNpcGFudExlZnQiLCJEb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwiSm9pblJlc3BvbnNlIiwiSGVhbHRoQ2hlY2tSZXNwb25zZSIsIlRyYWNrUHVibGlzaGVkIiwiVHJhY2tVbnB1Ymxpc2hlZCIsIkVycm9yJDEiLCJDYWxsR3JhbnRzVXBkYXRlZCIsIkdvQXdheSIsIklDRVJlc3RhcnQiLCJQaW5zQ2hhbmdlZCIsImV2ZW50UGF5bG9hZCIsInN1YnNjcmliZXJPZmZlciIsInB1Ymxpc2hlckFuc3dlciIsImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsImF1ZGlvTGV2ZWxDaGFuZ2VkIiwiaWNlVHJpY2tsZSIsImNoYW5nZVB1Ymxpc2hRdWFsaXR5IiwicGFydGljaXBhbnRKb2luZWQiLCJwYXJ0aWNpcGFudExlZnQiLCJkb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwiam9pblJlc3BvbnNlIiwiaGVhbHRoQ2hlY2tSZXNwb25zZSIsInRyYWNrUHVibGlzaGVkIiwidHJhY2tVbnB1Ymxpc2hlZCIsImNhbGxHcmFudHNVcGRhdGVkIiwiZ29Bd2F5IiwicGluc1VwZGF0ZWQiLCJTZnVFdmVudCIsIlBpbnNDaGFuZ2VkJFR5cGUiLCJJQ0VSZXN0YXJ0JFR5cGUiLCJTZnVSZXF1ZXN0JFR5cGUiLCJKb2luUmVxdWVzdCIsIkhlYWx0aENoZWNrUmVxdWVzdCIsInJlcXVlc3RQYXlsb2FkIiwiam9pblJlcXVlc3QiLCJoZWFsdGhDaGVja1JlcXVlc3QiLCJTZnVSZXF1ZXN0IiwiSGVhbHRoQ2hlY2tSZXF1ZXN0JFR5cGUiLCJIZWFsdGhDaGVja1Jlc3BvbnNlJFR5cGUiLCJUcmFja1B1Ymxpc2hlZCRUeXBlIiwicGFydGljaXBhbnQiLCJUcmFja1VucHVibGlzaGVkJFR5cGUiLCJjYXVzZSIsIkpvaW5SZXF1ZXN0JFR5cGUiLCJNaWdyYXRpb24iLCJ0b2tlbiIsInN1YnNjcmliZXJTZHAiLCJmYXN0UmVjb25uZWN0IiwiY2xpZW50RGV0YWlscyIsIm1pZ3JhdGlvbiIsIk1pZ3JhdGlvbiRUeXBlIiwiZnJvbVNmdUlkIiwiYW5ub3VuY2VkVHJhY2tzIiwic3Vic2NyaXB0aW9ucyIsIkpvaW5SZXNwb25zZSRUeXBlIiwicmVjb25uZWN0ZWQiLCJjYWxsU3RhdGUiLCJQYXJ0aWNpcGFudEpvaW5lZCRUeXBlIiwiY2FsbENpZCIsIlBhcnRpY2lwYW50TGVmdCRUeXBlIiwiU3Vic2NyaWJlck9mZmVyJFR5cGUiLCJQdWJsaXNoZXJBbnN3ZXIkVHlwZSIsIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCRUeXBlIiwiQ29ubmVjdGlvblF1YWxpdHlJbmZvIiwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzIiwiQ29ubmVjdGlvblF1YWxpdHlJbmZvJFR5cGUiLCJEb21pbmFudFNwZWFrZXJDaGFuZ2VkJFR5cGUiLCJBdWRpb0xldmVsJFR5cGUiLCJsZXZlbCIsIkF1ZGlvTGV2ZWwiLCJBdWRpb0xldmVsQ2hhbmdlZCRUeXBlIiwiYXVkaW9MZXZlbHMiLCJBdWRpb01lZGlhUmVxdWVzdCRUeXBlIiwiY2hhbm5lbENvdW50IiwiQXVkaW9NZWRpYVJlcXVlc3QiLCJBdWRpb1NlbmRlciRUeXBlIiwibWVkaWFSZXF1ZXN0IiwiY29kZWMiLCJBdWRpb1NlbmRlciIsIlZpZGVvTWVkaWFSZXF1ZXN0JFR5cGUiLCJpZGVhbEhlaWdodCIsImlkZWFsV2lkdGgiLCJpZGVhbEZyYW1lUmF0ZSIsIlZpZGVvTWVkaWFSZXF1ZXN0IiwiVmlkZW9MYXllclNldHRpbmckVHlwZSIsImFjdGl2ZSIsIm1heEJpdHJhdGUiLCJzY2FsZVJlc29sdXRpb25Eb3duQnkiLCJwcmlvcml0eSIsIm1heEZyYW1lcmF0ZSIsIlZpZGVvTGF5ZXJTZXR0aW5nIiwiVmlkZW9TZW5kZXIkVHlwZSIsIlZpZGVvU2VuZGVyIiwiQ2hhbmdlUHVibGlzaFF1YWxpdHkkVHlwZSIsImF1ZGlvU2VuZGVycyIsInZpZGVvU2VuZGVycyIsIkNhbGxHcmFudHNVcGRhdGVkJFR5cGUiLCJjdXJyZW50R3JhbnRzIiwiR29Bd2F5JFR5cGUiLCJyZWFzb24iLCJldmVudHMiLCJWaXNpYmlsaXR5U3RhdGUiLCJEZWJvdW5jZVR5cGUiLCJTaWduYWxTZXJ2ZXJDbGllbnQiLCJfdHJhbnNwb3J0IiwibWV0aG9kcyIsInNldFB1Ymxpc2hlciIsImlucHV0IiwibWV0aG9kIiwib3B0IiwibWVyZ2VPcHRpb25zIiwic2VuZEFuc3dlciIsInVwZGF0ZVN1YnNjcmlwdGlvbnMiLCJ1cGRhdGVNdXRlU3RhdGVzIiwic2VuZFN0YXRzIiwiZGVmYXVsdE9wdGlvbnMiLCJiYXNlVXJsIiwic2VuZEpzb24iLCJ0aW1lb3V0IiwianNvbk9wdGlvbnMiLCJpZ25vcmVVbmtub3duRmllbGRzIiwid2l0aEhlYWRlcnMiLCJoZWFkZXJzIiwiaW50ZXJjZXB0VW5hcnkiLCJuZXh0IiwibWV0YSIsImNyZWF0ZVNpZ25hbENsaWVudCIsInRyYW5zcG9ydCIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwidG9Mb3dlckNhc2UiLCJsb2dMZXZlbHMiLCJ0cmFjZSIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJsb2dnZXIkNCIsImxvZ1RvQ29uc29sZSIsImxvZ0xldmVsIiwiYXJncyIsImxvZ01ldGhvZCIsImNvbnNvbGUiLCJsb2ciLCJzZXRMb2dnZXIiLCJsIiwibHZsIiwic2V0TG9nTGV2ZWwiLCJnZXRMb2dnZXIiLCJ3aXRoVGFncyIsImxvZ2dlck1ldGhvZCIsInRhZ3MiLCJyZXN1bHQiLCJnZXRQcmVmZXJyZWRDb2RlY3MiLCJwcmVmZXJyZWRDb2RlYyIsImNvZGVjVG9SZW1vdmUiLCJsb2dnZXIiLCJSVENSdHBTZW5kZXIiLCJjYXAiLCJnZXRDYXBhYmlsaXRpZXMiLCJtYXRjaGVkIiwicGFydGlhbE1hdGNoZWQiLCJ1bm1hdGNoZWQiLCJjb2RlY3MiLCJmb3JFYWNoIiwiYyIsIm1pbWVUeXBlIiwic2hvdWxkUmVtb3ZlQ29kZWMiLCJtYXRjaGVzQ29kZWMiLCJzZHBGbXRwTGluZSIsImluY2x1ZGVzIiwiZ2V0R2VuZXJpY1NkcCIsImRpcmVjdGlvbiIsInRlbXBQYyIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiYWRkVHJhbnNjZWl2ZXIiLCJvZmZlciIsImNyZWF0ZU9mZmVyIiwiZ2V0VHJhbnNjZWl2ZXJzIiwidCIsInN0b3AiLCJjbG9zZSIsInNmdUV2ZW50S2luZHMiLCJpc1NmdUV2ZW50IiwiZXZlbnROYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRGlzcGF0Y2hlciIsInN1YnNjcmliZXJzIiwiZGlzcGF0Y2giLCJldmVudEtpbmQiLCJwYXlsb2FkIiwibGlzdGVuZXJzIiwiZm4iLCJvbiIsIl9hIiwib2ZmIiwib2ZmQWxsIiwiSWNlVHJpY2tsZUJ1ZmZlciIsInN1YnNjcmliZXJDYW5kaWRhdGVzIiwicHVibGlzaGVyQ2FuZGlkYXRlcyIsIlNVQlNDUklCRVIiLCJQVUJMSVNIRVJfVU5TUEVDSUZJRUQiLCJnZXRJY2VDYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJ1c2VybmFtZUZyYWdtZW50Iiwic3BsaXR0ZWRDYW5kaWRhdGUiLCJzcGxpdCIsInVmcmFnSW5kZXgiLCJmaW5kSW5kZXgiLCJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvSlNPTiIsInNka0luZm8iLCJvc0luZm8iLCJkZXZpY2VJbmZvIiwid2ViUnRjSW5mbyIsInNldFNka0luZm8iLCJnZXRTZGtJbmZvIiwic2V0T1NJbmZvIiwiZ2V0T1NJbmZvIiwic2V0RGV2aWNlSW5mbyIsImdldERldmljZUluZm8iLCJnZXRXZWJSVENJbmZvIiwic2V0V2ViUlRDSW5mbyIsImdldENsaWVudERldGFpbHMiLCJ1c2VyQWdlbnQiLCJjcHUiLCJnZXRSZXN1bHQiLCJ2ZW5kb3IiLCJtb2RlbCIsIkJvb2xlYW4iLCJERUZBVUxUX0JJVFJBVEUiLCJkZWZhdWx0VGFyZ2V0UmVzb2x1dGlvbiIsImZpbmRPcHRpbWFsVmlkZW9MYXllcnMiLCJ2aWRlb1RyYWNrIiwidGFyZ2V0UmVzb2x1dGlvbiIsIm9wdGltYWxWaWRlb0xheWVycyIsInNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJ3IiwiaCIsImlzUk5Jb3MiLCJnZXRDb21wdXRlZE1heEJpdHJhdGUiLCJkb3duc2NhbGVGYWN0b3IiLCJ1bnNoaWZ0Iiwicm91bmQiLCJxIiwid2l0aFNpbXVsY2FzdENvbnN0cmFpbnRzIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwiY3VycmVudFBpeGVscyIsInRhcmdldFBpeGVscyIsInJlZHVjdGlvbkZhY3RvciIsInNpemUiLCJtYXgiLCJsYXllciIsInJpZE1hcHBpbmciLCJpbmRleCIsImZpbmRPcHRpbWFsU2NyZWVuU2hhcmluZ0xheWVycyIsInByZWZlcmVuY2VzIiwidHJhY2tUeXBlVG9QYXJ0aWNpcGFudFN0cmVhbUtleSIsIlNDUkVFTl9TSEFSRSIsIlNDUkVFTl9TSEFSRV9BVURJTyIsIlZJREVPIiwiQVVESU8iLCJVTlNQRUNJRklFRCIsImV4aGF1c3RpdmVUcmFja1R5cGVDaGVjayIsIm11dGVUeXBlVG9UcmFja1R5cGUiLCJtdXRlVHlwZSIsImV4aGF1c3RpdmVNdXRlVHlwZUNoZWNrIiwiaXNGdW5jdGlvblBhdGNoIiwidXBkYXRlIiwiZ2V0Q3VycmVudFZhbHVlIiwib2JzZXJ2YWJsZSQiLCJlcnIiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInNldEN1cnJlbnRWYWx1ZSIsInN1YmplY3QiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJvYnNlcnZhYmxlIiwiaGFuZGxlciIsInN1YnNjcmlwdGlvbiIsInJ4VXRpbHMiLCJjb21iaW5lQ29tcGFyYXRvcnMiLCJjb21wYXJhdG9ycyIsImEiLCJiIiwiY29tcGFyYXRvciIsImRlc2NlbmRpbmciLCJjb25kaXRpb25hbCIsInByZWRpY2F0ZSIsIm5vb3BDb21wYXJhdG9yIiwiZG9taW5hbnRTcGVha2VyIiwic3BlYWtpbmciLCJzY3JlZW5TaGFyaW5nIiwiaGFzU2NyZWVuU2hhcmUiLCJwdWJsaXNoaW5nVmlkZW8iLCJoYXNWaWRlbyIsInB1Ymxpc2hpbmdBdWRpbyIsImhhc0F1ZGlvIiwicGlubmVkIiwicGluIiwiaXNMb2NhbFBpbiIsInBpbm5lZEF0IiwicmVhY3Rpb25UeXBlIiwicmVhY3Rpb24iLCJyb2xlIiwiaGFzQW55Um9sZSIsInAiLCJzb21lIiwiciIsImlmSW52aXNpYmxlQnkiLCJ2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSIsIklOVklTSUJMRSIsImlmSW52aXNpYmxlT3JVbmtub3duQnkiLCJVTktOT1dOIiwiZGVmYXVsdFNvcnRQcmVzZXQiLCJzcGVha2VyTGF5b3V0U29ydFByZXNldCIsInBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQiLCJsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0IiwiQ2FsbGluZ1N0YXRlIiwiZGVmYXVsdEVncmVzcyIsImJyb2FkY2FzdGluZyIsImhscyIsInBsYXlsaXN0X3VybCIsInJ0bXBzIiwiYmFja3N0YWdlU3ViamVjdCIsImJsb2NrZWRVc2VySWRzU3ViamVjdCIsImNyZWF0ZWRBdFN1YmplY3QiLCJlbmRlZEF0U3ViamVjdCIsInN0YXJ0c0F0U3ViamVjdCIsInVwZGF0ZWRBdFN1YmplY3QiLCJjcmVhdGVkQnlTdWJqZWN0IiwiY3VzdG9tU3ViamVjdCIsImVncmVzc1N1YmplY3QiLCJpbmdyZXNzU3ViamVjdCIsInJlY29yZGluZ1N1YmplY3QiLCJzZXNzaW9uU3ViamVjdCIsInNldHRpbmdzU3ViamVjdCIsInRyYW5zY3JpYmluZ1N1YmplY3QiLCJlbmRlZEJ5U3ViamVjdCIsInRodW1ibmFpbHNTdWJqZWN0IiwibWVtYmVyc1N1YmplY3QiLCJvd25DYXBhYmlsaXRpZXNTdWJqZWN0IiwiY2FsbGluZ1N0YXRlU3ViamVjdCIsInN0YXJ0ZWRBdFN1YmplY3QiLCJwYXJ0aWNpcGFudENvdW50U3ViamVjdCIsImFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0IiwicGFydGljaXBhbnRzU3ViamVjdCIsImNhbGxTdGF0c1JlcG9ydFN1YmplY3QiLCJzb3J0UGFydGljaXBhbnRzQnkiLCJzZXRTb3J0UGFydGljaXBhbnRzQnkiLCJwcyIsInNldFBhcnRpY2lwYW50Q291bnQiLCJjb3VudCIsInNldFN0YXJ0ZWRBdCIsInNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQiLCJzZXRQYXJ0aWNpcGFudHMiLCJzZXRDYWxsaW5nU3RhdGUiLCJzdGF0ZSIsInNldENhbGxTdGF0c1JlcG9ydCIsInJlcG9ydCIsInNldE1lbWJlcnMiLCJtZW1iZXJzIiwic2V0T3duQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwiZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQiLCJnZXRQYXJ0aWNpcGFudExvb2t1cEJ5U2Vzc2lvbklkIiwicmVkdWNlIiwibG9va3VwVGFibGUiLCJ1cGRhdGVQYXJ0aWNpcGFudCIsInRoZVBhdGNoIiwidXBkYXRlZFBhcnRpY2lwYW50IiwidXBkYXRlT3JBZGRQYXJ0aWNpcGFudCIsInVwZGF0ZVBhcnRpY2lwYW50cyIsInVwZGF0ZUZyb21FdmVudCIsImV2ZW50IiwiZXZlbnRIYW5kbGVycyIsInNldFNlcnZlclNpZGVQaW5zIiwicGluc0xvb2t1cCIsImxvb2t1cCIsInNlcnZlclNpZGVQaW5uZWRBdCIsInVwZGF0ZUZyb21DYWxsUmVzcG9uc2UiLCJiYWNrc3RhZ2UiLCJibG9ja2VkX3VzZXJfaWRzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJzdGFydHNfYXQiLCJlbmRlZF9hdCIsImNyZWF0ZWRfYnkiLCJlZ3Jlc3MiLCJpbmdyZXNzIiwicmVjb3JkaW5nIiwic2Vzc2lvbiIsInRyYW5zY3JpYmluZyIsInRodW1ibmFpbHMiLCJ1cGRhdGVGcm9tTWVtYmVyUmVtb3ZlZCIsIm0iLCJpbmRleE9mIiwidXNlcl9pZCIsInVwZGF0ZUZyb21NZW1iZXJBZGRlZCIsInVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkIiwidXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCIsInVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdGFydGVkIiwiaGxzX3BsYXlsaXN0X3VybCIsInVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRMZWZ0IiwicGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUiLCJ1c2VyIiwidXNlcl9zZXNzaW9uX2lkIiwidXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZCIsInNob3VsZEluc2VydFBhcnRpY2lwYW50IiwidXBkYXRlZFBhcnRpY2lwYW50cyIsImluY3JlbWVudCIsInVwZGF0ZU1lbWJlcnMiLCJtZW1iZXIiLCJtZW1iZXJVcGRhdGUiLCJ1cGRhdGVQYXJ0aWNpcGFudFJlYWN0aW9uIiwiZW1vamlfY29kZSIsInVuYmxvY2tVc2VyIiwiY3VycmVudCIsImJsb2NrVXNlciIsInVwZGF0ZU93bkNhcGFiaWxpdGllcyIsImxvY2FsUGFydGljaXBhbnQiLCJvd25fY2FwYWJpbGl0aWVzIiwicGFydGljaXBhbnRzJCIsImFzT2JzZXJ2YWJsZSIsInBpcGUiLCJzb3J0IiwiYnVmZmVyU2l6ZSIsInJlZkNvdW50IiwibG9jYWxQYXJ0aWNpcGFudCQiLCJpc0xvY2FsUGFydGljaXBhbnQiLCJyZW1vdGVQYXJ0aWNpcGFudHMkIiwicGlubmVkUGFydGljaXBhbnRzJCIsImRvbWluYW50U3BlYWtlciQiLCJoYXNPbmdvaW5nU2NyZWVuU2hhcmUkIiwic3RhcnRlZEF0JCIsInBhcnRpY2lwYW50Q291bnQkIiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQiLCJjYWxsU3RhdHNSZXBvcnQkIiwibWVtYmVycyQiLCJvd25DYXBhYmlsaXRpZXMkIiwiY2FsbGluZ1N0YXRlJCIsImJhY2tzdGFnZSQiLCJibG9ja2VkVXNlcklkcyQiLCJjcmVhdGVkQXQkIiwiZW5kZWRBdCQiLCJzdGFydHNBdCQiLCJ1cGRhdGVkQXQkIiwiY3JlYXRlZEJ5JCIsImN1c3RvbSQiLCJlZ3Jlc3MkIiwiaW5ncmVzcyQiLCJyZWNvcmRpbmckIiwic2Vzc2lvbiQiLCJzZXR0aW5ncyQiLCJ0cmFuc2NyaWJpbmckIiwiZW5kZWRCeSQiLCJ0aHVtYm5haWxzJCIsImFub255bW91c1BhcnRpY2lwYW50Q291bnQiLCJyZW1vdGVQYXJ0aWNpcGFudHMiLCJwaW5uZWRQYXJ0aWNpcGFudHMiLCJoYXNPbmdvaW5nU2NyZWVuU2hhcmUiLCJjYWxsaW5nU3RhdGUiLCJjYWxsU3RhdHNSZXBvcnQiLCJvd25DYXBhYmlsaXRpZXMiLCJibG9ja2VkVXNlcklkcyIsImVuZGVkQXQiLCJzdGFydHNBdCIsImNyZWF0ZWRCeSIsImVuZGVkQnkiLCJTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUiLCJjb25uZWN0ZWRVc2VyU3ViamVjdCIsImNhbGxzU3ViamVjdCIsInNldENvbm5lY3RlZFVzZXIiLCJzZXRDYWxscyIsImNhbGxzIiwicmVnaXN0ZXJDYWxsIiwiY2lkIiwidW5yZWdpc3RlckNhbGwiLCJmaW5kQ2FsbCIsIkxFRlQiLCJsZWF2ZSIsImNhdGNoIiwiY29ubmVjdGVkVXNlciIsIlN0cmVhbVZpZGVvUmVhZE9ubHlTdGF0ZVN0b3JlIiwic3RvcmUiLCJjb25uZWN0ZWRVc2VyJCIsImNhbGxzJCIsImdldFJ0cE1hcCIsImxpbmUiLCJydHBSZWdleCIsInJ0cE1hdGNoIiwiZXhlYyIsIm9yaWdpbmFsIiwiZ2V0Rm10cCIsImZtdHBSZWdleCIsImZtdHBNYXRjaCIsImNvbmZpZyIsImdldE1lZGlhIiwibWVkaWFUeXBlIiwicmVnZXgiLCJSZWdFeHAiLCJtZWRpYVdpdGhQb3J0cyIsImNvZGVjT3JkZXIiLCJnZXRNZWRpYVNlY3Rpb24iLCJtZWRpYSIsInJ0cE1hcCIsImZtdHAiLCJpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uIiwiaXNWYWxpZExpbmUiLCJ0ZXN0IiwiX21lZGlhIiwicnRwTWFwTGluZSIsImdldE9wdXNGbXRwIiwic2VjdGlvbiIsImNvZGVjSWQiLCJ0b2dnbGVEdHgiLCJlbmFibGUiLCJvcHVzRm10cCIsIm1hdGNoRHR4IiwicmVxdWlyZWREdHhDb25maWciLCJuZXdGbXRwIiwiZW5hYmxlSGlnaFF1YWxpdHlBdWRpbyIsInRyYWNrTWlkIiwibWluIiwicGFyc2VkU2RwIiwiYXVkaW9NZWRpYSIsIlN0cmluZyIsIm9wdXNSdHAiLCJydHAiLCJ3cml0ZSIsImxvZ2dlciQzIiwiUHVibGlzaGVyIiwiY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJwYyIsImdldENvbmZpZ3VyYXRpb24iLCJfY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJjb25uZWN0aW9uQ29uZmlnIiwic2Z1Q2xpZW50IiwiZGlzcGF0Y2hlciIsImlzRHR4RW5hYmxlZCIsImlzUmVkRW5hYmxlZCIsImljZVJlc3RhcnREZWxheSIsInRyYW5zY2VpdmVyUmVnaXN0cnkiLCJwdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZSIsIk1hcCIsInRyYW5zY2VpdmVySW5pdE9yZGVyIiwidHJhY2tLaW5kTWFwcGluZyIsInRyYWNrTGF5ZXJzQ2FjaGUiLCJpc0ljZVJlc3RhcnRpbmciLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkljZUNhbmRpZGF0ZSIsIm9uTmVnb3RpYXRpb25OZWVkZWQiLCJvbkljZUNhbmRpZGF0ZUVycm9yIiwib25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlIiwib25TaWduYWxpbmdTdGF0ZUNoYW5nZSIsInN0b3BUcmFja3MiLCJzdG9wUHVibGlzaGluZyIsImNsZWFyVGltZW91dCIsImljZVJlc3RhcnRUaW1lb3V0IiwidW5zdWJzY3JpYmVPbkljZVJlc3RhcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHVibGlzaFN0cmVhbSIsIm1lZGlhU3RyZWFtIiwidHJhY2siLCJvcHRzIiwicmVhZHlTdGF0ZSIsInRyYW5zY2VpdmVyIiwic2VuZGVyIiwiaGFuZGxlVHJhY2tFbmRlZCIsIm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZCIsInZpZGVvIiwidGFyZ2V0X3Jlc29sdXRpb24iLCJ2aWRlb0VuY29kaW5ncyIsInNjcmVlblNoYXJlU2V0dGluZ3MiLCJvc05hbWUiLCJjb2RlY1ByZWZlcmVuY2VzIiwiZ2V0Q29kZWNQcmVmZXJlbmNlcyIsImVuYWJsZWQiLCJzdHJlYW1zIiwic2VuZEVuY29kaW5ncyIsInNldCIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJwcmV2aW91c1RyYWNrIiwicmVwbGFjZVRyYWNrIiwidW5wdWJsaXNoU3RyZWFtIiwic3RvcFRyYWNrIiwiaXNQdWJsaXNoaW5nIiwidHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUiLCJpc0xpdmUiLCJpc011dGVkIiwidXBkYXRlTXV0ZVN0YXRlIiwiYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbSIsImdldFNlbmRlcnMiLCJzaWduYWxpbmdTdGF0ZSIsInJlbW92ZVRyYWNrIiwidXBkYXRlVmlkZW9QdWJsaXNoUXVhbGl0eSIsImVuYWJsZWRMYXllcnMiLCJ2aWRlb1NlbmRlciIsInBhcmFtcyIsImdldFBhcmFtZXRlcnMiLCJlbmNvZGluZ3MiLCJjaGFuZ2VkIiwiZW5hYmxlZFJpZHMiLCJseSIsImVuYyIsInNob3VsZEVuYWJsZSIsInZscyIsImFjdGl2ZUxheWVycyIsInNldFBhcmFtZXRlcnMiLCJnZXRTdGF0cyIsInNlbGVjdG9yIiwiZGVmYXVsdEF1ZGlvQ29kZWMiLCJzZXRTZnVDbGllbnQiLCJtaWdyYXRlVG8iLCJzZXRDb25maWd1cmF0aW9uIiwic2hvdWxkUmVzdGFydEljZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIm5lZ290aWF0ZSIsInJlc3RhcnRJY2UiLCJtdW5nZUNvZGVjcyIsImV4dHJhY3RNaWQiLCJ0cmFja0luZm9zIiwiZ2V0Q3VycmVudFRyYWNrSW5mb3MiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwicmVzcG9uc2UiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImljZVRyaWNrbGVCdWZmZXIiLCJhZGRJY2VDYW5kaWRhdGUiLCJtc2lkIiwiaGV1cmlzdGljTWlkIiwibG9jYWxEZXNjcmlwdGlvbiIsIm9wdGltYWxMYXllcnMiLCJwdWJsaXNoT3B0cyIsImdldCIsIm9wdGltYWxMYXllciIsInJpZFRvVmlkZW9RdWFsaXR5IiwiaXNBdWRpb1RyYWNrIiwidHJhY2tTZXR0aW5ncyIsImlzU3RlcmVvIiwiZXJyb3JNZXNzYWdlIiwiUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50IiwiZXJyb3JDb2RlIiwiZXJyb3JUZXh0IiwiaWNlU3RhdGUiLCJoYXNOZXR3b3JrQ29ubmVjdGlvbiIsIk9GRkxJTkUiLCJzZXRUaW1lb3V0IiwiaWNlR2F0aGVyaW5nU3RhdGUiLCJMT1dfVU5TUEVDSUZJRUQiLCJNSUQiLCJISUdIIiwibG9nZ2VyJDIiLCJTdWJzY3JpYmVyIiwiaGFuZGxlT25UcmFjayIsInVucmVnaXN0ZXJPblN1YnNjcmliZXJPZmZlciIsInVucmVnaXN0ZXJPbkljZVJlc3RhcnQiLCJwcmV2aW91c1BDIiwidHJhY2tJZHNUb01pZ3JhdGUiLCJTZXQiLCJnZXRSZWNlaXZlcnMiLCJhZGQiLCJtaWdyYXRpb25UaW1lb3V0SWQiLCJjbGVhbnVwTWlncmF0aW9uIiwiaGFuZGxlVHJhY2tNaWdyYXRpb24iLCJkZWxldGUiLCJoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJjb25uZWN0aW9uU3RhdGUiLCJwcmV2aW91c0lzSWNlUmVzdGFydGluZyIsInByaW1hcnlTdHJlYW0iLCJwYXJ0aWNpcGFudFRvVXBkYXRlIiwic3RyZWFtS2luZFByb3AiLCJUUkFDS19UWVBFX0FVRElPIiwiVFJBQ0tfVFlQRV9WSURFTyIsIlRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFIiwiVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkVfQVVESU8iLCJwcmV2aW91c1N0cmVhbSIsImdldFRyYWNrcyIsImFuc3dlciIsImNyZWF0ZUFuc3dlciIsImNyZWF0ZVdlYlNvY2tldFNpZ25hbENoYW5uZWwiLCJlbmRwb2ludCIsIm9uTWVzc2FnZSIsIndzIiwiYmluYXJ5VHlwZSIsImRhdGEiLCJBcnJheUJ1ZmZlciIsImZyb21CaW5hcnkiLCJVaW50OEFycmF5IiwiZnJvbUpzb25TdHJpbmciLCJzbGVlcCIsIlByb21pc2UiLCJpc0Z1bmN0aW9uIiwiRnVuY3Rpb24iLCJLbm93bkNvZGVzIiwiVE9LRU5fRVhQSVJFRCIsIldTX0NMT1NFRF9TVUNDRVNTIiwiV1NfQ0xPU0VEX0FCUlVQVExZIiwiV1NfUE9MSUNZX1ZJT0xBVElPTiIsInJldHJ5SW50ZXJ2YWwiLCJudW1iZXJPZkZhaWx1cmVzIiwicmFuZG9tIiwicmFuZG9tSWQiLCJnZW5lcmF0ZVVVSUR2NCIsImhleCIsImJ5dGVzIiwicGFkU3RhcnQiLCJnZXRSYW5kb21CeXRlcyIsInN1YmFycmF5IiwiZ2V0UmFuZG9tVmFsdWVzV2l0aE1hdGhSYW5kb20iLCJwb3ciLCJieXRlTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwiY3J5cHRvIiwiYmluZCIsIm1zQ3J5cHRvIiwiY29udmVydEVycm9yVG9Kc29uIiwianNvbk9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfIiwiaXNPbmxpbmUiLCJuYXYiLCJ3aW5kb3ciLCJvbkxpbmUiLCJhZGRDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMiLCJjYiIsInJlbW92ZUNvbm5lY3Rpb25FdmVudExpc3RlbmVycyIsIlN0cmVhbVNmdUNsaWVudCIsInNmdVNlcnZlciIsImlzTWlncmF0aW5nQXdheSIsImlzRmFzdFJlY29ubmVjdGluZyIsInBpbmdJbnRlcnZhbEluTXMiLCJ1bmhlYWx0aHlUaW1lb3V0SW5NcyIsInNpZ25hbFdzIiwiQ0xPU0VEIiwidW5zdWJzY3JpYmVJY2VUcmlja2xlIiwiY2xlYXJJbnRlcnZhbCIsImtlZXBBbGl2ZUludGVydmFsIiwiY29ubmVjdGlvbkNoZWNrVGltZW91dCIsInJldHJ5YWJsZSIsInJwYyIsInN0YXRzIiwic2VuZCIsInNpZ25hbFJlYWR5IiwidGhlbiIsInNpZ25hbCIsIk9QRU4iLCJlZGdlTmFtZSIsInRvQmluYXJ5Iiwia2VlcEFsaXZlIiwic2V0SW50ZXJ2YWwiLCJzY2hlZHVsZUNvbm5lY3Rpb25DaGVjayIsImxhc3RNZXNzYWdlVGltZXN0YW1wIiwidGltZVNpbmNlTGFzdE1lc3NhZ2UiLCJFUlJPUl9DT05ORUNUSU9OX1VOSEVBTFRIWSIsImVkZ2VfbmFtZSIsImxvZ0ludGVyY2VwdG9yIiwidXJsIiwiaW50ZXJjZXB0b3JzIiwiQXV0aG9yaXphdGlvbiIsIndzX2VuZHBvaW50IiwicmVzb2x2ZSIsIm9uT3BlbiIsIk5PUk1BTF9DTE9TVVJFIiwiRVJST1JfQ09OTkVDVElPTl9CUk9LRU4iLCJNQVhfUkVUUklFUyIsInJldHJ5QXR0ZW1wdCIsInJwY0NhbGxSZXN1bHQiLCJ3YXRjaENhbGxBY2NlcHRlZCIsIm9uQ2FsbEFjY2VwdGVkIiwiY3VycmVudFVzZXJJZCIsIlJJTkdJTkciLCJ3YXRjaENhbGxSZWplY3RlZCIsIm9uQ2FsbFJlamVjdGVkIiwiZXZlbnRDYWxsIiwiY2FsbFNlc3Npb24iLCJyZWplY3RlZEJ5IiwicmVqZWN0ZWRfYnkiLCJpc0NyZWF0ZWRCeU1lIiwiZXZlcnlvbmVFbHNlUmVqZWN0ZWQiLCJldmVyeSIsIndhdGNoQ2FsbEVuZGVkIiwib25DYWxsRW5kZWQiLCJKT0lORUQiLCJKT0lOSU5HIiwid2F0Y2hDYWxsR3JhbnRzVXBkYXRlZCIsIm9uQ2FsbEdyYW50c1VwZGF0ZWQiLCJuZXh0Q2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0eSIsImxvZ2dlciQxIiwid2F0Y2hDaGFuZ2VQdWJsaXNoUXVhbGl0eSIsInVwZGF0ZVB1Ymxpc2hRdWFsaXR5Iiwid2F0Y2hDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJwYXRjaGVzIiwid2F0Y2hQYXJ0aWNpcGFudENvdW50Q2hhbmdlZCIsIndhdGNoTGl2ZUVuZGVkIiwiTElWRV9FTkRFRCIsInBlcm1pc3Npb25zQ29udGV4dCIsImhhc1Blcm1pc3Npb24iLCJ3YXRjaFNmdUVycm9yUmVwb3J0cyIsIndhdGNoUGluc1VwZGF0ZWQiLCJvblBpbnNVcGRhdGVkIiwiaGFuZGxlUmVtb3RlU29mdE11dGUiLCJNT0RFUkFUSU9OIiwiY2FtZXJhIiwiZGlzYWJsZSIsIm1pY3JvcGhvbmUiLCJwdWJsaXNoZXIiLCJzdG9wUHVibGlzaCIsIndhdGNoUGFydGljaXBhbnRKb2luZWQiLCJvblBhcnRpY2lwYW50Sm9pbmVkIiwiYXNzaWduIiwic2NyZWVuU2hhcmVUcmFjayIsIndhdGNoUGFydGljaXBhbnRMZWZ0Iiwib25QYXJ0aWNpcGFudExlZnQiLCJ3YXRjaFRyYWNrUHVibGlzaGVkIiwib25UcmFja1B1Ymxpc2hlZCIsInVuaXF1ZSIsIndhdGNoVHJhY2tVbnB1Ymxpc2hlZCIsIm9uVHJhY2tVbnB1Ymxpc2hlZCIsImFyciIsIndhdGNoRG9taW5hbnRTcGVha2VyQ2hhbmdlZCIsIndhdGNoQXVkaW9MZXZlbENoYW5nZWQiLCJyZWdpc3RlckV2ZW50SGFuZGxlcnMiLCJyaW5naW5nIiwicmVnaXN0ZXJSaW5naW5nQ2FsbEV2ZW50SGFuZGxlcnMiLCJjb29yZGluYXRvclJpbmdFdmVudHMiLCJodHRwQ2xpZW50IiwiY3JlZGVudGlhbHMiLCJzdGF0c19vcHRpb25zIiwiZG9Kb2luIiwidG9SdGNDb25maWd1cmF0aW9uIiwiaWNlX3NlcnZlcnMiLCJzZXJ2ZXIiLCJtZXRhZGF0YSIsInN0YXRzT3B0aW9ucyIsImxvY2F0aW9uIiwiZ2V0TG9jYXRpb25IaW50IiwicmVxdWVzdCIsInBvc3QiLCJydGNDb25maWciLCJpY2VTZXJ2ZXJzIiwiaWNlIiwidXJscyIsInVzZXJuYW1lIiwiY3JlZGVudGlhbCIsInBhc3N3b3JkIiwiZmxhdHRlbiQxIiwiY3JlYXRlU3RhdHNSZXBvcnRlciIsInN1YnNjcmliZXIiLCJwb2xsaW5nSW50ZXJ2YWxJbk1zIiwiZ2V0UmF3U3RhdHNGb3JUcmFjayIsImdldFN0YXRzRm9yU3RyZWFtIiwic3RhdHNGb3JTdHJlYW0iLCJ0cmFuc2Zvcm0iLCJ0cmFja0tpbmQiLCJzdGFydFJlcG9ydGluZ1N0YXRzRm9yIiwic2Vzc2lvbklkc1RvVHJhY2siLCJydW4iLCJzdG9wUmVwb3J0aW5nU3RhdHNGb3IiLCJwYXJ0aWNpcGFudFN0YXRzIiwic2Vzc2lvbklkcyIsImhhcyIsIm1lcmdlZFN0cmVhbSIsIk1lZGlhU3RyZWFtIiwidmlkZW9TdHJlYW0iLCJnZXRWaWRlb1RyYWNrcyIsImF1ZGlvU3RyZWFtIiwiZ2V0QXVkaW9UcmFja3MiLCJhbGwiLCJhZ2dyZWdhdGUiLCJzdWJzY3JpYmVyUmF3U3RhdHMiLCJwdWJsaXNoZXJSYXdTdGF0cyIsImRhdGFjZW50ZXIiLCJ0aW1lc3RhbXAiLCJ0aW1lb3V0SWQiLCJsb29wIiwic3RhdCIsInJ0Y1N0cmVhbVN0YXRzIiwidHJhbnNwb3J0SWQiLCJyb3VuZFRyaXBUaW1lIiwiZHRsc1N0YXRlIiwiY2FuZGlkYXRlUGFpciIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY3VycmVudFJvdW5kVHJpcFRpbWUiLCJieXRlc1NlbnQiLCJieXRlc1JlY2VpdmVkIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZnJhbWVzUGVyU2Vjb25kIiwiaml0dGVyIiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb24iLCJzc3JjIiwicmF3U3RhdHMiLCJhZ2dyZWdhdGVkU3RhdHMiLCJyYXdSZXBvcnQiLCJ0b3RhbEJ5dGVzU2VudCIsInRvdGFsQnl0ZXNSZWNlaXZlZCIsImF2ZXJhZ2VKaXR0ZXJJbk1zIiwiYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zIiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb25zIiwiaGlnaGVzdEZyYW1lV2lkdGgiLCJoaWdoZXN0RnJhbWVIZWlnaHQiLCJoaWdoZXN0RnJhbWVzUGVyU2Vjb25kIiwibWF4QXJlYSIsImFyZWEiLCJhY2MiLCJzdHJlYW0iLCJzdHJlYW1BcmVhIiwiU2Z1U3RhdHNSZXBvcnRlciIsInNka05hbWUiLCJ3ZWJSVENWZXJzaW9uIiwic3RhcnQiLCJyZXBvcnRpbmdfaW50ZXJ2YWxfbXMiLCJpbnRlcnZhbElkIiwid2ViUlRDSW5mbyIsIlJFQUNUIiwiUkVBQ1RfTkFUSVZFIiwiREVGQVVMVF9USFJFU0hPTEQiLCJWaWV3cG9ydFRyYWNrZXIiLCJlbGVtZW50SGFuZGxlck1hcCIsIm9ic2VydmVyIiwicXVldWVTZXQiLCJzZXRWaWV3cG9ydCIsInZpZXdwb3J0RWxlbWVudCIsImNsZWFudXAiLCJkaXNjb25uZWN0IiwiY2xlYXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJ5Iiwicm9vdCIsInRocmVzaG9sZCIsInF1ZXVlRWxlbWVudCIsInF1ZXVlSGFuZGxlciIsImNvbnRhaW5zIiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJxdWV1ZUl0ZW0iLCJ1bm9ic2VydmUiLCJpc1NhZmFyaSIsImlzRmlyZWZveCIsImlzQ2hyb21lIiwiYnJvd3NlcnMiLCJERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEUiLCJEeW5hc2NhbGVNYW5hZ2VyIiwidmlld3BvcnRUcmFja2VyIiwidHJhY2tFbGVtZW50VmlzaWJpbGl0eSIsInByZXZpb3VzVmlzaWJpbGl0eVN0YXRlIiwiaXNWaXNpYmxlIiwiaXNJbnRlcnNlY3RpbmciLCJkb2N1bWVudCIsImZ1bGxzY3JlZW5FbGVtZW50IiwiVklTSUJMRSIsImJpbmRWaWRlb0VsZW1lbnQiLCJ2aWRlb0VsZW1lbnQiLCJib3VuZFBhcnRpY2lwYW50IiwicmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMiLCJkZWJvdW5jZVR5cGUiLCJ1cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbCIsInBhcnRpY2lwYW50JCIsInZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlU3Vic2NyaXB0aW9uIiwibmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlIiwiTUVESVVNIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJsYXN0RGltZW5zaW9ucyIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJjdXJyZW50RGltZW5zaW9ucyIsIlNMT1ciLCJwdWJsaXNoZWRUcmFja3NTdWJzY3JpcHRpb24iLCJGQVNUIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsInN0cmVhbVN1YnNjcmlwdGlvbiIsInNvdXJjZSIsInNjcmVlblNoYXJlU3RyZWFtIiwic3JjT2JqZWN0IiwicGxheSIsImJpbmRBdWRpb0VsZW1lbnQiLCJhdWRpb0VsZW1lbnQiLCJ1cGRhdGVNZWRpYVN0cmVhbVN1YnNjcmlwdGlvbiIsInNjcmVlblNoYXJlQXVkaW9TdHJlYW0iLCJzZWxlY3RlZERldmljZSIsInNwZWFrZXIiLCJzZXRTaW5rSWQiLCJzaW5rSWRTdWJzY3JpcHRpb24iLCJzZWxlY3RlZERldmljZSQiLCJkZXZpY2VJZCIsInZvbHVtZVN1YnNjcmlwdGlvbiIsInZvbHVtZSQiLCJ2b2x1bWUiLCJhdWRpb1ZvbHVtZSIsIlBlcm1pc3Npb25zQ29udGV4dCIsInBlcm1pc3Npb25zIiwic2V0UGVybWlzc2lvbnMiLCJzZXRDYWxsU2V0dGluZ3MiLCJwZXJtaXNzaW9uIiwiY2FuUmVxdWVzdCIsImF1ZGlvIiwic2NyZWVuc2hhcmluZyIsImFjY2Vzc19yZXF1ZXN0X2VuYWJsZWQiLCJDYWxsVHlwZSIsIkNhbGxUeXBlc1JlZ2lzdHJ5IiwiY2FsbFR5cGVzIiwicmVnaXN0ZXIiLCJjYWxsVHlwZSIsInVucmVnaXN0ZXIiLCJDYWxsVHlwZXMiLCJnZXREZXZpY2VzIiwiY29uc3RyYWludHMiLCJlbnVtZXJhdGUiLCJkZXZpY2VzIiwibWVkaWFEZXZpY2VzIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5lZWRzR2V0VXNlck1lZGlhIiwibGFiZWwiLCJnZXRVc2VyTWVkaWEiLCJkaXNwb3NlT2ZNZWRpYVN0cmVhbSIsImNvbXBsZXRlIiwiY2hlY2tJZkF1ZGlvT3V0cHV0Q2hhbmdlU3VwcG9ydGVkIiwiY3JlYXRlRWxlbWVudCIsImF1ZGlvRGV2aWNlQ29uc3RyYWludHMiLCJhdXRvR2FpbkNvbnRyb2wiLCJub2lzZVN1cHByZXNzaW9uIiwiZWNob0NhbmNlbGxhdGlvbiIsInZpZGVvRGV2aWNlQ29uc3RyYWludHMiLCJtZW1vaXplZE9ic2VydmFibGUiLCJtZW1vaXplZCIsImdldERldmljZUNoYW5nZU9ic2VydmVyIiwibm90aWZ5IiwiZ2V0QXVkaW9EZXZpY2VzT2JzZXJ2ZXIiLCJnZXRBdWRpb091dHB1dERldmljZXNPYnNlcnZlciIsImdldFZpZGVvRGV2aWNlc09ic2VydmVyIiwiZ2V0QXVkaW9EZXZpY2VzIiwiZ2V0VmlkZW9EZXZpY2VzIiwiZ2V0QXVkaW9PdXRwdXREZXZpY2VzIiwiZ2V0U3RyZWFtIiwiZ2V0QXVkaW9TdHJlYW0iLCJ0cmFja0NvbnN0cmFpbnRzIiwiZ2V0VmlkZW9TdHJlYW0iLCJnZXRTY3JlZW5TaGFyZVN0cmVhbSIsImdldERpc3BsYXlNZWRpYSIsImlkZWFsIiwic3lzdGVtQXVkaW8iLCJkZXZpY2VJZHMkIiwicmVsZWFzZSIsIklucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIiwic3RvcE9uTGVhdmUiLCJpc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQiLCJmaWx0ZXJzIiwiZGlzcG9zZSIsImhhbmRsZURpc2Nvbm5lY3RlZE9yUmVwbGFjZWREZXZpY2VzIiwibGlzdERldmljZXMiLCJzdGF0dXMiLCJlbmFibGVQcm9taXNlIiwidW5tdXRlU3RyZWFtIiwic2V0U3RhdHVzIiwiZm9yY2VTdG9wIiwicHJldlN0YXR1cyIsImRpc2FibGVNb2RlIiwiZGlzYWJsZVByb21pc2UiLCJtdXRlU3RyZWFtIiwicmVzdW1lIiwidG9nZ2xlIiwicmVnaXN0ZXJGaWx0ZXIiLCJhcHBseVNldHRpbmdzVG9TdHJlYW0iLCJzZXREZWZhdWx0Q29uc3RyYWludHMiLCJzZWxlY3QiLCJzZXREZXZpY2UiLCJzdG9wUHVibGlzaFN0cmVhbSIsIm11dGVMb2NhbFN0cmVhbSIsImFsbEVuZGVkIiwic2V0TWVkaWFTdHJlYW0iLCJtdXRlVHJhY2tzIiwidW5tdXRlVHJhY2tzIiwiZGVmYXVsdENvbnN0cmFpbnRzIiwiY2hhaW5XaXRoIiwicGFyZW50U3RyZWFtIiwiZmlsdGVyU3RyZWFtIiwicGFyZW50Iiwib3JpZ2luYWxTdG9wIiwicGFyZW50VHJhY2siLCJoYW5kbGVQYXJlbnRUcmFja0VuZGVkIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwibWVkaWFEZXZpY2VLaW5kIiwicHJldkRldmljZXMiLCJjdXJyZW50RGV2aWNlcyIsImlzRGV2aWNlRGlzY29ubmVjdGVkIiwiaXNEZXZpY2VSZXBsYWNlZCIsImN1cnJlbnREZXZpY2UiLCJmaW5kRGV2aWNlSW5MaXN0IiwicHJldkRldmljZSIsImdyb3VwSWQiLCJJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIiwicGVybWlzc2lvbk5hbWUiLCJzdGF0dXNTdWJqZWN0IiwibWVkaWFTdHJlYW1TdWJqZWN0Iiwic2VsZWN0ZWREZXZpY2VTdWJqZWN0IiwiZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdCIsIm1lZGlhU3RyZWFtJCIsInN0YXR1cyQiLCJkZWZhdWx0Q29uc3RyYWludHMkIiwiaGFzQnJvd3NlclBlcm1pc3Npb24kIiwibm90aWZ5R3JhbnRlZCIsInBlcm1pc3Npb25zQVBJQXZhaWxhYmxlIiwicXVlcnkiLCJwZXJtaXNzaW9uU3RhdGUiLCJwZXJtaXNzaW9uU3RhdHVzIiwiZ2V0RGV2aWNlSWRGcm9tU3RyZWFtIiwiQ2FtZXJhTWFuYWdlclN0YXRlIiwiZGlyZWN0aW9uU3ViamVjdCIsImRpcmVjdGlvbiQiLCJzZXREaXJlY3Rpb24iLCJmYWNpbmdNb2RlIiwiQ2FtZXJhTWFuYWdlciIsInNlbGVjdERpcmVjdGlvbiIsImZsaXAiLCJuZXdEaXJlY3Rpb24iLCJzZWxlY3RUYXJnZXRSZXNvbHV0aW9uIiwicmVzb2x1dGlvbiIsInNldFByZWZlcnJlZENvZGVjIiwicHVibGlzaFZpZGVvU3RyZWFtIiwiTWljcm9waG9uZU1hbmFnZXJTdGF0ZSIsInNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3QiLCJzcGVha2luZ1doaWxlTXV0ZWQkIiwic3BlYWtpbmdXaGlsZU11dGVkIiwic2V0U3BlYWtpbmdXaGlsZU11dGVkIiwiREVURUNUSU9OX0ZSRVFVRU5DWV9JTl9NUyIsIkFVRElPX0xFVkVMX1RIUkVTSE9MRCQxIiwiRkZUX1NJWkUiLCJjcmVhdGVTb3VuZERldGVjdG9yIiwib25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkIiwiZGV0ZWN0aW9uRnJlcXVlbmN5SW5NcyIsImF1ZGlvTGV2ZWxUaHJlc2hvbGQiLCJmZnRTaXplIiwiZGVzdHJveVN0cmVhbU9uU3RvcCIsImF1ZGlvQ29udGV4dCIsIkF1ZGlvQ29udGV4dCIsImFuYWx5c2VyIiwiY3JlYXRlQW5hbHlzZXIiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsImNvbm5lY3QiLCJmcmVxdWVuY3lCaW5Db3VudCIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwiaXNTb3VuZERldGVjdGVkIiwiYXZlcmFnZWREYXRhVmFsdWUiLCJwdiIsImN2IiwicGVyY2VudGFnZSIsImZsYXR0ZW4iLCJBVURJT19MRVZFTF9USFJFU0hPTEQiLCJSTlNwZWVjaERldGVjdG9yIiwicGMxIiwicGMyIiwiYWRkVHJhY2siLCJhdWRpb1RyYWNrcyIsIm9uU3BlYWtpbmdEZXRlY3RlZFN0YXRlQ2hhbmdlIiwiYXVkaW9NZWRpYVNvdXJjZVN0YXRzIiwiTWljcm9waG9uZU1hbmFnZXIiLCJzdG9wU3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uIiwic3RhcnRTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24iLCJwdWJsaXNoQXVkaW9TdHJlYW0iLCJyblNwZWVjaERldGVjdG9yIiwic291bmREZXRlY3RvckNsZWFudXAiLCJTY3JlZW5TaGFyZVN0YXRlIiwiYXJndW1lbnRzIiwiYXVkaW9FbmFibGVkU3ViamVjdCIsImF1ZGlvRW5hYmxlZCQiLCJhdWRpb0VuYWJsZWQiLCJzZXRBdWRpb0VuYWJsZWQiLCJpc0VuYWJsZWQiLCJzZXRTZXR0aW5ncyIsIlNjcmVlblNoYXJlTWFuYWdlciIsImVuYWJsZVNjcmVlblNoYXJlQXVkaW8iLCJkaXNhYmxlU2NyZWVuU2hhcmVBdWRpbyIsInB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbSIsIlNwZWFrZXJTdGF0ZSIsInZvbHVtZVN1YmplY3QiLCJpc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZCIsInNldFZvbHVtZSIsIlNwZWFrZXJNYW5hZ2VyIiwic2V0UGFydGljaXBhbnRWb2x1bWUiLCJzdHJlYW1DbGllbnQiLCJjbGllbnRTdG9yZSIsIndhdGNoaW5nIiwiZHluYXNjYWxlTWFuYWdlciIsInRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QiLCJyZWNvbm5lY3RBdHRlbXB0cyIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwibGVhdmVDYWxsSG9va3MiLCJzdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzIiwib2ZmSGFuZGxlciIsImNhbGxfY2lkIiwicmVnaXN0ZXJlZE9mZkhhbmRsZXIiLCJyZWplY3QiLCJhc3NlcnRDYWxsSm9pbmVkIiwiaGFzT3RoZXJQYXJ0aWNpcGFudHMiLCJzdGF0c1JlcG9ydGVyIiwic2Z1U3RhdHNSZXBvcnRlciIsImhvb2siLCJzY3JlZW5TaGFyZSIsInN0b3BPbkxlYXZlUHJvbWlzZXMiLCJzdHJlYW1DbGllbnRCYXNlUGF0aCIsInJpbmciLCJyaW5naW5nU3ViamVjdCIsIl9oYXNDb25uZWN0aW9uSUQiLCJhcHBseURldmljZUNvbmZpZyIsImdldE9yQ3JlYXRlIiwiYWNjZXB0IiwiaXNNaWdyYXRpbmciLCJNSUdSQVRJTkciLCJpc1JlY29ubmVjdGluZyIsIlJFQ09OTkVDVElORyIsInNmdVRva2VuIiwicHJldmlvdXNTZnVDbGllbnQiLCJyZWNvbm5lY3QiLCJzdHJhdGVneSIsImN1cnJlbnRTdGF0ZSIsIm1pZ3JhdGluZ19mcm9tIiwidW5yZWdpc3RlckdvQXdheSIsIlJFQ09OTkVDVElOR19GQUlMRUQiLCJ1bnN1YnNjcmliZU9ubGluZUV2ZW50Iiwib25saW5lIiwiY3VycmVudENhbGxpbmdTdGF0ZSIsInNob3VsZFJlY29ubmVjdCIsImlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0IiwidW5zdWJzY3JpYmVPZmZsaW5lRXZlbnQiLCJhdWRpb1NldHRpbmdzIiwib3B1c19kdHhfZW5hYmxlZCIsInJlZHVuZGFudF9jb2RpbmdfZW5hYmxlZCIsIndhaXRGb3JKb2luUmVzcG9uc2UiLCJjdXJyZW50UGFydGljaXBhbnRzIiwicGFydGljaXBhbnRMb29rdXAiLCJleGlzdGluZ1BhcnRpY2lwYW50IiwiaW5pdENhbWVyYSIsImluaXRNaWMiLCJhdWRpb1RyYWNrIiwic2NyZWVuU2hhcmVBdWRpb1RyYWNrIiwiY2hhbmdlcyIsImNoYW5nZSIsInByb3AiLCJzY3JlZW5TaGFyZURpbWVuc2lvbiIsInJlc2V0UmVhY3Rpb24iLCJjcml0ZXJpYSIsInNlbmRSZWFjdGlvbiIsIm11dGVTZWxmIiwibXlVc2VySWQiLCJtdXRlVXNlciIsIm11dGVPdGhlcnMiLCJ1c2VySWRzVG9NdXRlIiwidXNlcl9pZHMiLCJtdXRlQWxsVXNlcnMiLCJtdXRlX2FsbF91c2VycyIsInN0YXJ0UmVjb3JkaW5nIiwic3RvcFJlY29yZGluZyIsInN0YXJ0VHJhbnNjcmlwdGlvbiIsInN0b3BUcmFuc2NyaXB0aW9uIiwicmVxdWVzdFBlcm1pc3Npb25zIiwiY2FuUmVxdWVzdFBlcm1pc3Npb25zIiwiZ3JhbnRQZXJtaXNzaW9ucyIsInVwZGF0ZVVzZXJQZXJtaXNzaW9ucyIsImdyYW50X3Blcm1pc3Npb25zIiwicmV2b2tlUGVybWlzc2lvbnMiLCJyZXZva2VfcGVybWlzc2lvbnMiLCJnb0xpdmUiLCJzdG9wTGl2ZSIsInN0YXJ0SExTIiwic3RvcEhMUyIsInVwZGF0ZXMiLCJlbmRDYWxsIiwidW5waW4iLCJwaW5Gb3JFdmVyeW9uZSIsInVucGluRm9yRXZlcnlvbmUiLCJxdWVyeU1lbWJlcnMiLCJ1cGRhdGVDYWxsTWVtYmVycyIsInNjaGVkdWxlQXV0b0Ryb3AiLCJkcm9wVGltZW91dCIsInRpbWVvdXRJbk1zIiwiYXV0b19jYW5jZWxfdGltZW91dF9tcyIsInF1ZXJ5UmVjb3JkaW5ncyIsImNhbGxTZXNzaW9uSWQiLCJxdWVyeVRyYW5zY3JpcHRpb25zIiwiZ2V0Q2FsbFN0YXRzIiwiY2FsbFNlc3Npb25JRCIsInNlbmRDdXN0b21FdmVudCIsInVuYmluZCIsImJpbmRDYWxsVGh1bWJuYWlsRWxlbWVudCIsImltYWdlRWxlbWVudCIsImhhbmRsZUVycm9yIiwic3JjIiwiZmFsbGJhY2tJbWFnZVNvdXJjZSIsInRodW1ibmFpbFVybCIsIlVSTCIsImltYWdlX3VybCIsInNlYXJjaFBhcmFtcyIsImNhbGxUeXBlQ29uZmlnIiwicGFydGljaXBhbnRTb3J0ZXIiLCJJRExFIiwicmVnaXN0ZXJFZmZlY3RzIiwicGVybWlzc2lvblRvVHJhY2tUeXBlIiwiaXNSaW5naW5nIiwiZGVmYXVsdERpcmVjdGlvbiIsImJhY2tlbmRTZXR0aW5nIiwiY2FtZXJhX2ZhY2luZyIsImNhbWVyYV9kZWZhdWx0X29uIiwibWljX2RlZmF1bHRfb24iLCJJbnNpZ2h0TWV0cmljcyIsImNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCIsIndzVG90YWxGYWlsdXJlcyIsIndzQ29uc2VjdXRpdmVGYWlsdXJlcyIsImluc3RhbmNlQ2xpZW50SWQiLCJwb3N0SW5zaWdodHMiLCJpbnNpZ2h0VHlwZSIsImluc2lnaHRzIiwibWF4QXR0ZW1wdHMiLCJidWlsZFdzRmF0YWxJbnNpZ2h0IiwiY29ubmVjdGlvbiIsImJ1aWxkV3NCYXNlSW5zaWdodCIsImNsaWVudCIsInJlYWR5X3N0YXRlIiwiX2J1aWxkVXJsIiwiYXBpX2tleSIsInN0YXJ0X3RzIiwiaW5zaWdodE1ldHJpY3MiLCJlbmRfdHMiLCJhdXRoX3R5cGUiLCJnZXRBdXRoVHlwZSIsInRva2VuTWFuYWdlciIsInVzZXJJRCIsInVzZXJfZGV0YWlscyIsIl91c2VyIiwiY2xpZW50X2lkIiwiY29ubmVjdGlvbklEIiwid3NfZGV0YWlscyIsIndzX2NvbnNlY3V0aXZlX2ZhaWx1cmVzIiwid3NfdG90YWxfZmFpbHVyZXMiLCJyZXF1ZXN0X2lkIiwicmVxdWVzdElEIiwidXNlcl9hZ2VudCIsImluc3RhbmNlX2NsaWVudF9pZCIsImJ1aWxkV3NTdWNjZXNzQWZ0ZXJGYWlsdXJlSW5zaWdodCIsImlzQ2xvc2VFdmVudCIsInJlcyIsImlzRXJyb3JFdmVudCIsIlN0YWJsZVdTQ29ubmVjdGlvbiIsIl9sb2ciLCJleHRyYSIsInNldENsaWVudCIsIlVSTFNlYXJjaFBhcmFtcyIsImdldFVzZXJBZ2VudCIsIndzQmFzZVVSTCIsIm9ubGluZVN0YXR1c0NoYW5nZWQiLCJfc2V0SGVhbHRoIiwiaXNIZWFsdGh5IiwiX3JlY29ubmVjdCIsImludGVydmFsIiwib25vcGVuIiwid3NJRCIsIl9nZXRUb2tlbiIsImF1dGhNZXNzYWdlIiwiYXV0aGVudGljYXRpb25TZW50Iiwib25tZXNzYWdlIiwiaXNSZXNvbHZlZCIsInJlamVjdFByb21pc2UiLCJfZXJyb3JGcm9tV1NFdmVudCIsImxhc3RFdmVudCIsInNjaGVkdWxlTmV4dFBpbmciLCJyZXNvbHZlUHJvbWlzZSIsImlzQ29ubmVjdGluZyIsImNvbnNlY3V0aXZlRmFpbHVyZXMiLCJpc1N0YXRpYyIsImNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYiLCJyZWZyZXNoVG9rZW4iLCJvbmNsb3NlIiwid2FzQ2xlYW4iLCJ0b3RhbEZhaWx1cmVzIiwib25lcnJvciIsImhlYWx0aHkiLCJkaXNwYXRjaEltbWVkaWF0ZWx5IiwiaXNXU0ZhaWx1cmUiLCJzdGF0dXNDb2RlIiwiU3RhdHVzQ29kZSIsIl9zZXR1cENvbm5lY3Rpb25Qcm9taXNlIiwiY29ubmVjdGlvbk9wZW4iLCJoZWFsdGhDaGVja1RpbWVvdXRSZWYiLCJjbGllbnRJRCIsInBpbmdJbnRlcnZhbCIsImlzRGlzY29ubmVjdGVkIiwiaGVhbHRoQ2hlY2siLCJfY29ubmVjdCIsIl93YWl0Rm9ySGVhbHRoeSIsInJhY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJpc0Nsb3NlZFByb21pc2UiLCJlbmFibGVXU0ZhbGxiYWNrIiwiaXNUb2tlblJlYWR5IiwidG9rZW5SZWFkeSIsImxvYWRUb2tlbiIsIndzVVJMIiwiY29ubmVjdGlvbl9pZCIsInJlc29sdmVDb25uZWN0aW9uSWQiLCJlbmFibGVJbnNpZ2h0cyIsInJlamVjdENvbm5lY3Rpb25JZCIsIl9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbiIsImlzU3RyaW5nIiwiYXJyYXlPclN0cmluZyIsImlzTWFwU3RyaW5nQ2FsbGJhY2siLCJjYWxsYmFjayIsImNoYXJBdCIsImtWYWx1ZSIsIm1hcHBlZFZhbHVlIiwiZW5jb2RlQmFzZTY0IiwiY2hhciIsImNoYXJDb2RlQXQiLCJkZWNvZGVCYXNlNjQiLCJmcm9tQ2hhckNvZGUiLCJMIiwieCIsIkEiLCJKV1RVc2VyVG9rZW4iLCJhcGlTZWNyZXQiLCJleHRyYURhdGEiLCJqd3RPcHRpb25zIiwiVHlwZUVycm9yIiwic2lnbiIsImFsZ29yaXRobSIsIm5vVGltZXN0YW1wIiwiaWF0IiwiSldUU2VydmVyVG9rZW4iLCJVc2VyRnJvbVRva2VuIiwiZnJhZ21lbnRzIiwiYjY0UGF5bG9hZCIsIkRldlRva2VuIiwiVG9rZW5NYW5hZ2VyIiwic2VjcmV0Iiwic2V0VG9rZW5PclByb3ZpZGVyIiwidG9rZW5PclByb3ZpZGVyIiwiaXNBbm9ueW1vdXMiLCJ2YWxpZGF0ZVRva2VuIiwidG9rZW5Qcm92aWRlciIsInJlc2V0IiwibG9hZFRva2VuUHJvbWlzZSIsInRva2VuVXNlcklkIiwiZ2V0VG9rZW4iLCJBUElFcnJvckNvZGVzIiwiaXNBUElFcnJvciIsImlzRXJyb3JSZXRyeWFibGUiLCJpc0Nvbm5lY3Rpb25JREVycm9yIiwiaXNFcnJvclJlc3BvbnNlIiwiQ29ubmVjdGlvblN0YXRlIiwiV1NDb25uZWN0aW9uRmFsbGJhY2siLCJfb25saW5lU3RhdHVzQ2hhbmdlZCIsIl9zZXRTdGF0ZSIsIkNsb3NlZCIsImNhbmNlbFRva2VuIiwiY2FuY2VsIiwiX3JlcSIsInJldHJ5IiwiQ2FuY2VsVG9rZW4iLCJkb0F4aW9zUmVxdWVzdCIsImJhc2VVUkwiLCJwdWJsaWNFbmRwb2ludCIsIl9wb2xsIiwiQ29ubmVjdGVkIiwiaXNDYW5jZWwiLCJEaXNjb25uZWN0ZWQiLCJDb25uZWN0aW5nIiwiX2J1aWxkV1NQYXlsb2FkIiwiSW5pdCIsIkhJTlRfVVJMIiwiaGludFVybCIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImFib3J0IiwiZmV0Y2giLCJhd3NQb3AiLCJTdHJlYW1DbGllbnQiLCJuZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciIsImRldlRva2VuIiwic2V0QmFzZVVSTCIsImhpbnQiLCJsb2NhdGlvbkhpbnQiLCJsb2NhdGlvbkhpbnRVcmwiLCJsb2NhdGlvbkhpbnRUaW1lb3V0IiwiX2dldENvbm5lY3Rpb25JRCIsIndzQ29ubmVjdGlvbiIsIndzRmFsbGJhY2siLCJjb25uZWN0VXNlciIsInVzZXJUb2tlbk9yUHJvdmlkZXIiLCJzZXRVc2VyUHJvbWlzZSIsIl9pc1VzaW5nU2VydmVyQXV0aCIsIm5vZGUiLCJhbGxvd1NlcnZlclNpZGVDb25uZWN0Iiwic2V0VG9rZW5Qcm9taXNlIiwiX3NldFRva2VuIiwiX3NldFVzZXIiLCJ3c1Byb21pc2UiLCJvcGVuQ29ubmVjdGlvbiIsInBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZSIsImNsb3NlQ29ubmVjdGlvbiIsImRpc2Nvbm5lY3RVc2VyIiwiY2xlYW5pbmdJbnRlcnZhbFJlZiIsImNvbm5lY3Rpb25JZFByb21pc2UiLCJfbm9ybWFsaXplRGF0ZSIsImJlZm9yZSIsImNvbm5lY3RHdWVzdFVzZXIiLCJndWVzdFVzZXJDcmVhdGVQcm9taXNlIiwiZmluYWxseSIsImFjY2Vzc190b2tlbiIsImNvbm5lY3RBbm9ueW1vdXNVc2VyIiwiX2xvZ0FwaVJlcXVlc3QiLCJfbG9nQXBpUmVzcG9uc2UiLCJfbG9nQXBpRXJyb3IiLCJyZXF1ZXN0Q29uZmlnIiwiX2VucmljaEF4aW9zT3B0aW9ucyIsImF4aW9zSW5zdGFuY2UiLCJwdXQiLCJoYW5kbGVSZXNwb25zZSIsImNsaWVudF9yZXF1ZXN0X2lkIiwiZXJyb3JGcm9tUmVzcG9uc2UiLCJyZWNlaXZlZF9hdCIsImxpc3RlbmVyIiwid2FybVVwIiwiX3NheUhpIiwiZGVmYXVsdFdTVGltZW91dFdpdGhGYWxsYmFjayIsImRlZmF1bHRXU1RpbWVvdXQiLCJtb2RlIiwic2V0VXNlckFnZW50IiwiYXV0aG9yaXphdGlvbiIsImF4aW9zUmVxdWVzdENvbmZpZyIsImNyZWF0ZUFib3J0Q29udHJvbGxlckZvck5leHRSZXF1ZXN0IiwiY3JlYXRlVG9rZW4iLCJleHAiLCJjYWxsX2NpZHMiLCJpbnB1dE9wdGlvbnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJodHRwc0FnZW50IiwiQWdlbnQiLCJrZWVwQWxpdmVNc2VjcyIsInByb2Nlc3MiLCJlbnYiLCJTVFJFQU1fTE9DQUxfVEVTVF9SVU4iLCJTVFJFQU1fTE9DQUxfVEVTVF9IT1NUIiwiU3RyZWFtVmlkZW9DbGllbnQiLCJhcGlLZXlPckFyZ3MiLCJldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyIiwiY29ubmVjdGlvblByb21pc2UiLCJkaXNjb25uZWN0aW9uUHJvbWlzZSIsIndyaXRlYWJsZVN0YXRlU3RvcmUiLCJjcmVhdGVHdWVzdFVzZXIiLCJxdWVyeUNhbGxzIiwid2F0Y2giLCJxdWVyeUNhbGxTdGF0cyIsImVkZ2VzIiwiYWRkRGV2aWNlIiwicHVzaF9wcm92aWRlciIsInB1c2hfcHJvdmlkZXJfbmFtZSIsInZvaXBfdG9rZW4iLCJyZW1vdmVEZXZpY2UiLCJvblJpbmdpbmdDYWxsIiwicmVhZE9ubHlTdGF0ZVN0b3JlIiwiY2FsbElkIiwiYXBpS2V5IiwiY29ubmVjdFVzZXJSZXNwb25zZSIsIm1lIiwiY2FsbHNUb1JlV2F0Y2giLCJmaWx0ZXJfY29uZGl0aW9ucyIsIiRpbiIsImZpZWxkIiwibmV3Q2FsbCIsInByZXZDYWxsIiwidGhlQ2FsbCIsImFkZFZvaXBEZXZpY2UiLCJTdHJlYW1WaWRlb1NlcnZlckNsaWVudCIsImdldENhbGxUeXBlcyIsImdldENhbGxUeXBlIiwiY3JlYXRlQ2FsbFR5cGUiLCJkZWxldGVDYWxsVHlwZSIsInVwZGF0ZUNhbGxUeXBlIiwibGlzdEV4dGVybmFsU3RvcmFnZSIsImNyZWF0ZUV4dGVybmFsU3RvcmFnZSIsImRlbGV0ZUV4dGVybmFsU3RvcmFnZSIsInVwZGF0ZUV4dGVybmFsU3RvcmFnZSIsImNoZWNrRXh0ZXJuYWxTdG9yYWdlIiwiQnJvd3NlcnMiLCJSeFV0aWxzIiwiU2Z1RXZlbnRzIiwiU2Z1TW9kZWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@stream-io+video-client@0.6.10/node_modules/@stream-io/video-client/dist/index.es.js\n");

/***/ })

};
;