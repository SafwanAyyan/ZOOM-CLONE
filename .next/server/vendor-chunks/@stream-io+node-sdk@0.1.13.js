"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io+node-sdk@0.1.13";
exports.ids = ["vendor-chunks/@stream-io+node-sdk@0.1.13"];
exports.modules = {

/***/ "(action-browser)/./node_modules/.pnpm/@stream-io+node-sdk@0.1.13/node_modules/@stream-io/node-sdk/dist/index.es.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@stream-io+node-sdk@0.1.13/node_modules/@stream-io/node-sdk/dist/index.es.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APNConfigRequestAuthTypeEnum: () => (/* binding */ APNConfigRequestAuthTypeEnum),\n/* harmony export */   AppSearchBackendEnum: () => (/* binding */ AppSearchBackendEnum),\n/* harmony export */   AsyncModerationCallbackConfigRequestModeEnum: () => (/* binding */ AsyncModerationCallbackConfigRequestModeEnum),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   BlockListOptionsBehaviorEnum: () => (/* binding */ BlockListOptionsBehaviorEnum),\n/* harmony export */   BlockListOptionsRequestBehaviorEnum: () => (/* binding */ BlockListOptionsRequestBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodBehaviorEnum: () => (/* binding */ ChannelConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodEnum: () => (/* binding */ ChannelConfigAutomodEnum),\n/* harmony export */   ChannelConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodEnum: () => (/* binding */ ChannelConfigWithInfoAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelMemberRequestRoleEnum: () => (/* binding */ ChannelMemberRequestRoleEnum),\n/* harmony export */   ChannelMemberRoleEnum: () => (/* binding */ ChannelMemberRoleEnum),\n/* harmony export */   ChannelTypeConfigAutomodBehaviorEnum: () => (/* binding */ ChannelTypeConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelTypeConfigAutomodEnum: () => (/* binding */ ChannelTypeConfigAutomodEnum),\n/* harmony export */   ChannelTypeConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelTypeConfigBlocklistBehaviorEnum),\n/* harmony export */   CheckPushRequestPushProviderTypeEnum: () => (/* binding */ CheckPushRequestPushProviderTypeEnum),\n/* harmony export */   CheckSNSResponseStatusEnum: () => (/* binding */ CheckSNSResponseStatusEnum),\n/* harmony export */   CheckSQSResponseStatusEnum: () => (/* binding */ CheckSQSResponseStatusEnum),\n/* harmony export */   ConfigDefaultRoleEnum: () => (/* binding */ ConfigDefaultRoleEnum),\n/* harmony export */   ConfigRequestDefaultRoleEnum: () => (/* binding */ ConfigRequestDefaultRoleEnum),\n/* harmony export */   CreateCallRequestTypeEnum: () => (/* binding */ CreateCallRequestTypeEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodEnum: () => (/* binding */ CreateChannelTypeRequestAutomodEnum),\n/* harmony export */   CreateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodEnum: () => (/* binding */ CreateChannelTypeResponseAutomodEnum),\n/* harmony export */   CreateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   CreateImportRequestModeEnum: () => (/* binding */ CreateImportRequestModeEnum),\n/* harmony export */   DeleteUsersRequestConversationsEnum: () => (/* binding */ DeleteUsersRequestConversationsEnum),\n/* harmony export */   DeleteUsersRequestMessagesEnum: () => (/* binding */ DeleteUsersRequestMessagesEnum),\n/* harmony export */   DeleteUsersRequestUserEnum: () => (/* binding */ DeleteUsersRequestUserEnum),\n/* harmony export */   DeviceFieldsPushProviderEnum: () => (/* binding */ DeviceFieldsPushProviderEnum),\n/* harmony export */   DevicePushProviderEnum: () => (/* binding */ DevicePushProviderEnum),\n/* harmony export */   DeviceRequestPushProviderEnum: () => (/* binding */ DeviceRequestPushProviderEnum),\n/* harmony export */   ImageSizeCropEnum: () => (/* binding */ ImageSizeCropEnum),\n/* harmony export */   ImageSizeResizeEnum: () => (/* binding */ ImageSizeResizeEnum),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   MessageRequest1TypeEnum: () => (/* binding */ MessageRequest1TypeEnum),\n/* harmony export */   MessageRequestTypeEnum: () => (/* binding */ MessageRequestTypeEnum),\n/* harmony export */   MessageTypeEnum: () => (/* binding */ MessageTypeEnum),\n/* harmony export */   PermissionLevelEnum: () => (/* binding */ PermissionLevelEnum),\n/* harmony export */   PolicyRequest1ActionEnum: () => (/* binding */ PolicyRequest1ActionEnum),\n/* harmony export */   PolicyRequestActionEnum: () => (/* binding */ PolicyRequestActionEnum),\n/* harmony export */   PushConfigRequestVersionEnum: () => (/* binding */ PushConfigRequestVersionEnum),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamChannel: () => (/* binding */ StreamChannel),\n/* harmony export */   StreamChatClient: () => (/* binding */ StreamChatClient),\n/* harmony export */   StreamClient: () => (/* binding */ StreamClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranslateMessageRequestLanguageEnum: () => (/* binding */ TranslateMessageRequestLanguageEnum),\n/* harmony export */   UpdateAppRequestEnforceUniqueUsernamesEnum: () => (/* binding */ UpdateAppRequestEnforceUniqueUsernamesEnum),\n/* harmony export */   UpdateAppRequestPermissionVersionEnum: () => (/* binding */ UpdateAppRequestPermissionVersionEnum),\n/* harmony export */   UpdateAppRequestVideoProviderEnum: () => (/* binding */ UpdateAppRequestVideoProviderEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodEnum),\n/* harmony export */   UpdateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodEnum),\n/* harmony export */   UpdateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   VideoAudioSettingsDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsDefaultDeviceEnum),\n/* harmony export */   VideoAudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   VideoCreateDeviceRequestPushProviderEnum: () => (/* binding */ VideoCreateDeviceRequestPushProviderEnum),\n/* harmony export */   VideoLayoutSettingsNameEnum: () => (/* binding */ VideoLayoutSettingsNameEnum),\n/* harmony export */   VideoLayoutSettingsRequestNameEnum: () => (/* binding */ VideoLayoutSettingsRequestNameEnum),\n/* harmony export */   VideoOwnCapability: () => (/* binding */ VideoOwnCapability),\n/* harmony export */   VideoRecordSettingsRequestModeEnum: () => (/* binding */ VideoRecordSettingsRequestModeEnum),\n/* harmony export */   VideoRecordSettingsRequestQualityEnum: () => (/* binding */ VideoRecordSettingsRequestQualityEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoTranscriptionSettingsModeEnum: () => (/* binding */ VideoTranscriptionSettingsModeEnum),\n/* harmony export */   VideoTranscriptionSettingsRequestModeEnum: () => (/* binding */ VideoTranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoVideoSettingsCameraFacingEnum: () => (/* binding */ VideoVideoSettingsCameraFacingEnum),\n/* harmony export */   VideoVideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoVideoSettingsRequestCameraFacingEnum)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-node/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonwebtoken */ \"(action-browser)/./node_modules/.pnpm/jsonwebtoken@9.0.2/node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n/**\n * @export\n */\nconst APNConfigRequestAuthTypeEnum = {\n    CERTIFICATE: 'certificate',\n    TOKEN: 'token'\n};\n/**\n * @export\n */\nconst AppSearchBackendEnum = {\n    ELASTICSEARCH: 'elasticsearch',\n    POSTGRES: 'postgres',\n    DISABLED: 'disabled'\n};\n/**\n * @export\n */\nconst AsyncModerationCallbackConfigRequestModeEnum = {\n    NONE: 'CALLBACK_MODE_NONE',\n    REST: 'CALLBACK_MODE_REST',\n    TWIRP: 'CALLBACK_MODE_TWIRP'\n};\n/**\n * @export\n */\nconst AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst BlockListOptionsBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst BlockListOptionsRequestBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelMemberRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelMemberRequestRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CheckPushRequestPushProviderTypeEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CheckSNSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst CheckSQSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst ConfigDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst ConfigRequestDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst CreateCallRequestTypeEnum = {\n    AUDIO: 'audio',\n    VIDEO: 'video'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CreateImportRequestModeEnum = {\n    INSERT: 'insert',\n    UPSERT: 'upsert'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestConversationsEnum = {\n    SOFT: 'soft',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestMessagesEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestUserEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DevicePushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceFieldsPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst ImageSizeCropEnum = {\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    RIGHT: 'right',\n    CENTER: 'center'\n};\n/**\n * @export\n */\nconst ImageSizeResizeEnum = {\n    CLIP: 'clip',\n    CROP: 'crop',\n    SCALE: 'scale',\n    FILL: 'fill'\n};\n/**\n * @export\n */\nconst LayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst MessageTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequestTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequest1TypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst PermissionLevelEnum = {\n    APP: 'app',\n    CHANNEL: 'channel'\n};\n/**\n * @export\n */\nconst PolicyRequestActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PolicyRequest1ActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PushConfigRequestVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst TranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst TranslateMessageRequestLanguageEnum = {\n    AF: 'af',\n    SQ: 'sq',\n    AM: 'am',\n    AR: 'ar',\n    AZ: 'az',\n    BN: 'bn',\n    BS: 'bs',\n    BG: 'bg',\n    ZH: 'zh',\n    ZH_TW: 'zh-TW',\n    HR: 'hr',\n    CS: 'cs',\n    DA: 'da',\n    FA_AF: 'fa-AF',\n    NL: 'nl',\n    EN: 'en',\n    ET: 'et',\n    FI: 'fi',\n    FR: 'fr',\n    FR_CA: 'fr-CA',\n    KA: 'ka',\n    DE: 'de',\n    EL: 'el',\n    HA: 'ha',\n    HE: 'he',\n    HI: 'hi',\n    HU: 'hu',\n    ID: 'id',\n    IT: 'it',\n    JA: 'ja',\n    KO: 'ko',\n    LV: 'lv',\n    MS: 'ms',\n    NO: 'no',\n    FA: 'fa',\n    PS: 'ps',\n    PL: 'pl',\n    PT: 'pt',\n    RO: 'ro',\n    RU: 'ru',\n    SR: 'sr',\n    SK: 'sk',\n    SL: 'sl',\n    SO: 'so',\n    ES: 'es',\n    ES_MX: 'es-MX',\n    SW: 'sw',\n    SV: 'sv',\n    TL: 'tl',\n    TA: 'ta',\n    TH: 'th',\n    TR: 'tr',\n    UK: 'uk',\n    UR: 'ur',\n    VI: 'vi'\n};\n/**\n * @export\n */\nconst UpdateAppRequestEnforceUniqueUsernamesEnum = {\n    NO: 'no',\n    APP: 'app',\n    TEAM: 'team'\n};\n/**\n * @export\n */\nconst UpdateAppRequestPermissionVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst UpdateAppRequestVideoProviderEnum = {\n    AGORA: 'agora',\n    HMS: 'hms'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst VideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/**\n * @export\n */\nconst VideoAudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoAudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoCreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * All possibility of string to use\n * @export\n */\nconst VideoOwnCapability = {\n    BLOCK_USERS: 'block-users',\n    CREATE_CALL: 'create-call',\n    CREATE_REACTION: 'create-reaction',\n    END_CALL: 'end-call',\n    JOIN_BACKSTAGE: 'join-backstage',\n    JOIN_CALL: 'join-call',\n    JOIN_ENDED_CALL: 'join-ended-call',\n    MUTE_USERS: 'mute-users',\n    PIN_FOR_EVERYONE: 'pin-for-everyone',\n    READ_CALL: 'read-call',\n    REMOVE_CALL_MEMBER: 'remove-call-member',\n    SCREENSHARE: 'screenshare',\n    SEND_AUDIO: 'send-audio',\n    SEND_VIDEO: 'send-video',\n    START_BROADCAST_CALL: 'start-broadcast-call',\n    START_RECORD_CALL: 'start-record-call',\n    START_TRANSCRIPTION_CALL: 'start-transcription-call',\n    STOP_BROADCAST_CALL: 'stop-broadcast-call',\n    STOP_RECORD_CALL: 'stop-record-call',\n    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',\n    UPDATE_CALL: 'update-call',\n    UPDATE_CALL_MEMBER: 'update-call-member',\n    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',\n    UPDATE_CALL_SETTINGS: 'update-call-settings'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestQualityEnum = {\n    _360P: '360p',\n    _480P: '480p',\n    _720P: '720p',\n    _1080P: '1080p',\n    _1440P: '1440p'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsRequestCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH$1 = \"https://chat.stream-io-api.com\".replace(/\\/+$/, \"\");\nlet Configuration$1 = class Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring$1;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n};\nconst DefaultConfig$1 = new Configuration$1();\n/**\n * This is the base class for all generated API classes.\n */\nlet BaseAPI$1 = class BaseAPI {\n    constructor(configuration = DefaultConfig$1) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError$1(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob$1(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n};\nBaseAPI$1.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob$1(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData$1(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nlet ResponseError$1 = class ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n};\nlet FetchError$1 = class FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n};\nlet RequiredError$1 = class RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n};\nconst COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\nfunction querystring$1(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey$1(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey$1(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey$1(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring$1(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nfunction canConsumeForm(consumes) {\n    for (const consume of consumes) {\n        if ('multipart/form-data' === consume.contentType) {\n            return true;\n        }\n    }\n    return false;\n}\nlet JSONApiResponse$1 = class JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n};\nlet VoidApiResponse$1 = class VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelTypesApi extends BaseAPI$1 {\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelsApi extends BaseAPI$1 {\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {\n                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {\n                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatusRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatus(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {\n                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/query`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.channelGetOrCreateRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {\n                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/hide`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.hideChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.hideChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {\n                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {\n                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.queryChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/members`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {\n                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/show`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.showChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.showChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {\n                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/truncate`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.truncateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {\n                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCountsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/unread`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCounts(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unreadCountsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {\n                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {\n                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass CustomCommandsApi extends BaseAPI$1 {\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {\n                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommandsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommands(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCommandsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');\n            }\n            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {\n                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DevicesApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass EventsApi extends BaseAPI$1 {\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {\n                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');\n            }\n            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {\n                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/event`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendUserCustomEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass MessagesApi extends BaseAPI$1 {\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hard !== undefined) {\n                queryParameters['hard'] = requestParameters.hard;\n            }\n            if (requestParameters.deletedBy !== undefined) {\n                queryParameters['deleted_by'] = requestParameters.deletedBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');\n            }\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');\n            }\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction/{type}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessagesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');\n            }\n            const queryParameters = {};\n            if (requestParameters.ids) {\n                queryParameters['ids'] = requestParameters.ids.join(',');\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/messages`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessages(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOGRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/og`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOG(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOGRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');\n            }\n            const queryParameters = {};\n            if (requestParameters.limit !== undefined) {\n                queryParameters['limit'] = requestParameters.limit;\n            }\n            if (requestParameters.offset !== undefined) {\n                queryParameters['offset'] = requestParameters.offset;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reactions`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getReactionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getRepliesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {\n                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');\n            }\n            const queryParameters = {};\n            if (requestParameters.idGte !== undefined) {\n                queryParameters['id_gte'] = requestParameters.idGte;\n            }\n            if (requestParameters.idGt !== undefined) {\n                queryParameters['id_gt'] = requestParameters.idGt;\n            }\n            if (requestParameters.idLte !== undefined) {\n                queryParameters['id_lte'] = requestParameters.idLte;\n            }\n            if (requestParameters.idLt !== undefined) {\n                queryParameters['id_lt'] = requestParameters.idLt;\n            }\n            if (requestParameters.createdAtAfterOrEqual !== undefined) {\n                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;\n            }\n            if (requestParameters.createdAtAfter !== undefined) {\n                queryParameters['created_at_after'] = requestParameters.createdAtAfter;\n            }\n            if (requestParameters.createdAtBeforeOrEqual !== undefined) {\n                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;\n            }\n            if (requestParameters.createdAtBefore !== undefined) {\n                queryParameters['created_at_before'] = requestParameters.createdAtBefore;\n            }\n            if (requestParameters.idAround !== undefined) {\n                queryParameters['id_around'] = requestParameters.idAround;\n            }\n            if (requestParameters.createdAtAround !== undefined) {\n                queryParameters['created_at_around'] = requestParameters.createdAtAround;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{parent_id}/replies`.replace(`{${\"parent_id\"}}`, encodeURIComponent(String(requestParameters.parentId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getReplies(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRepliesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlagsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flags/message`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlags(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageActionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');\n            }\n            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {\n                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/action`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.messageActionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageAction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {\n                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/message`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');\n            }\n            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {\n                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendReactionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');\n            }\n            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {\n                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/translate`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.translateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.translateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');\n            }\n            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {\n                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');\n            }\n            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {\n                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessagePartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.uploadSizes) {\n                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS[\"csv\"]));\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PermissionsV2Api extends BaseAPI$1 {\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {\n                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createRoleRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermissionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermission(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getPermissionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissionsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissions(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPermissionsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRolesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRoles(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRolesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PushApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet ServerSideApi$1 = class ServerSideApi extends BaseAPI$1 {\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {\n                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.upsertPushProviderRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet SettingsApi$1 = class SettingsApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {\n                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getAppRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getApp(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getAppRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimitsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.serverSide !== undefined) {\n                queryParameters['server_side'] = requestParameters.serverSide;\n            }\n            if (requestParameters.android !== undefined) {\n                queryParameters['android'] = requestParameters.android;\n            }\n            if (requestParameters.ios !== undefined) {\n                queryParameters['ios'] = requestParameters.ios;\n            }\n            if (requestParameters.web !== undefined) {\n                queryParameters['web'] = requestParameters.web;\n            }\n            if (requestParameters.endpoints !== undefined) {\n                queryParameters['endpoints'] = requestParameters.endpoints;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/rate_limits`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimits(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockListsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockLists(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listBlockListsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateAppRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {\n                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateAppRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateApp(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateAppRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');\n            }\n            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {\n                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TasksApi extends BaseAPI$1 {\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTaskRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/tasks/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTask(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getTaskRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TestingApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass UsersApi extends BaseAPI$1 {\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    banRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {\n                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.banRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    ban(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.banRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connect(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {\n                throw new RequiredError$1('guestRequest', 'Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.guestRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');\n            }\n            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {\n                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/deactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {\n                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/deactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deleteUser.');\n            }\n            const queryParameters = {};\n            if (requestParameters.markMessagesDeleted !== undefined) {\n                queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;\n            }\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            if (requestParameters.deleteConversationChannels !== undefined) {\n                queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {\n                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/export`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {\n                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPollRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/longpoll`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPoll(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.longPollRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {\n                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/query_banned_users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');\n            }\n            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {\n                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/reactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {\n                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/reactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {\n                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/restore`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.restoreUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unbanRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.targetUserId !== undefined) {\n                queryParameters['target_user_id'] = requestParameters.targetUserId;\n            }\n            if (requestParameters.type !== undefined) {\n                queryParameters['type'] = requestParameters.type;\n            }\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.createdBy !== undefined) {\n                queryParameters['created_by'] = requestParameters.createdBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unban(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unbanRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {\n                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {\n                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {\n                throw new RequiredError$1('updateUserPartialRequest', 'Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUserPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamChannel {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.delete = (request) => {\n            return this.channelsApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));\n        };\n        this.update = (updateChannelRequest) => {\n            return this.channelsApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));\n        };\n        this.updatePartial = (updateChannelPartialRequest) => {\n            return this.channelsApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));\n        };\n        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {\n            if (this.id) {\n                return yield this.channelsApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));\n            }\n            else {\n                throw new Error(`This operation isn't yet implemented`);\n                // if (!channelGetOrCreateRequest?.data?.members) {\n                //   throw new Error('You need to provide members to create a channel without ID');\n                // }\n                // const response = await this.channelsApi.getOrCreateChannelType1({type: this.type, channelGetOrCreateRequest});\n                // this.id = response.channel?.id;\n                // return response;\n            }\n        });\n        this.markRead = (markReadRequest) => {\n            return this.channelsApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));\n        };\n        this.markUnread = (markUnreadRequest) => {\n            return this.channelsApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));\n        };\n        this.show = (showChannelRequest) => {\n            return this.channelsApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));\n        };\n        this.hide = (hideChannelRequest) => {\n            return this.channelsApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));\n        };\n        this.truncate = (truncateChannelRequest) => {\n            return this.channelsApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.channelsApi.queryMembers({\n                payload: Object.assign(Object.assign({}, this.baseRequest), request),\n            });\n        };\n        this.mute = (muteChannelRequest) => {\n            return this.channelsApi.muteChannel({\n                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),\n            });\n        };\n        this.unmute = (unmuteChannelRequest) => {\n            return this.channelsApi.unmuteChannel({\n                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cid: this.cid, channel_cids: [] }),\n            });\n        };\n        // TODO: there is probably an issue with the generated code here\n        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {\n        //   return this.messagesApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});\n        // }\n        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {\n        //   return this.messagesApi.deleteFile({...request, ...this.baseRequest});\n        // }\n        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {\n        //   return this.messagesApi.uploadImage({...request, ...this.baseRequest});\n        // }\n        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {\n        //   return this.messagesApi.deleteImage({...request, ...this.baseRequest});\n        // }\n        this.sendMessage = (sendMessageRequest) => {\n            return this.messagesApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));\n        };\n        this.deleteMessage = (request) => {\n            return this.messagesApi.deleteMessage(request);\n        };\n        this.updateMessage = (id, updateMessageRequest) => {\n            return this.messagesApi.updateMessage({ id, updateMessageRequest });\n        };\n        this.updateMessagePartial = (id, updateMessagePartialRequest) => {\n            return this.messagesApi.updateMessagePartial({\n                id,\n                updateMessagePartialRequest,\n            });\n        };\n        this.getMessage = (request) => {\n            return this.messagesApi.getMessage(request);\n        };\n        this.getManyMessages = (request) => {\n            return this.messagesApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));\n        };\n        this.translateMessage = (id, translateMessageRequest) => {\n            return this.messagesApi.translateMessage({ id, translateMessageRequest });\n        };\n        this.getMessagesAround = (request) => {\n            return this.messagesApi.getReplies(request);\n        };\n        this.getOpenGraphData = (request) => {\n            return this.messagesApi.getOG(request);\n        };\n        this.sendMessageReaction = (messageId, sendReactionRequest) => {\n            return this.messagesApi.sendReaction({\n                id: messageId,\n                sendReactionRequest,\n            });\n        };\n        this.deleteMessageReaction = (messageId, request) => {\n            return this.messagesApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));\n        };\n        this.getMessageReactions = (messageId, request) => {\n            return this.messagesApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));\n        };\n        this.sendCustomEvent = (event) => {\n            return this.eventsApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.messagesApi = new MessagesApi(configuration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(configuration);\n    }\n    get cid() {\n        return `${this.baseRequest.type}:${this.baseRequest.id}`;\n    }\n    get baseRequest() {\n        if (!this.id) {\n            throw new Error('You need to initialize the channel with `getOrCreate`');\n        }\n        return {\n            id: this.id,\n            type: this.type,\n        };\n    }\n}\n\nclass StreamChatClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.channel = (type, id) => {\n            return new StreamChannel(this.streamClient, type, id);\n        };\n        this.createBlockList = (createBlockListRequest) => {\n            return this.settingsApi.createBlockList({ createBlockListRequest });\n        };\n        this.listBlockLists = () => {\n            return this.settingsApi.listBlockLists();\n        };\n        this.getBlockList = (request) => {\n            return this.settingsApi.getBlockList(request);\n        };\n        this.updateBlockList = (name, updateBlockListRequest) => {\n            return this.settingsApi.updateBlockList({ name, updateBlockListRequest });\n        };\n        this.deleteBlockList = (request) => {\n            return this.settingsApi.deleteBlockList(request);\n        };\n        this.createChannelType = (createChannelTypeRequest) => {\n            return this.channelTypesApi.createChannelType({ createChannelTypeRequest });\n        };\n        this.deleteChannelType = (request) => {\n            return this.channelTypesApi.deleteChannelType(request);\n        };\n        this.getChannelType = (request) => {\n            return this.channelTypesApi.getChannelType(request);\n        };\n        this.listChannelTypes = () => {\n            return this.channelTypesApi.listChannelTypes();\n        };\n        this.updateChannelType = (name, updateChannelTypeRequest) => {\n            return this.channelTypesApi.updateChannelType({\n                name,\n                updateChannelTypeRequest,\n            });\n        };\n        this.queryChannels = (queryChannelsRequest) => {\n            return this.channelsApi.queryChannels({\n                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : null,\n            });\n        };\n        this.searchMessages = (payload) => {\n            return this.channelsApi.search({ payload });\n        };\n        this.exportChannels = (exportChannelsRequest) => {\n            return this.channelsApi.exportChannels({\n                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,\n            });\n        };\n        this.getExportStatus = (request) => {\n            return this.channelsApi.getExportChannelsStatus(request);\n        };\n        this.listCommands = () => {\n            return this.commandsApi.listCommands();\n        };\n        this.createCommand = (createCommandRequest) => {\n            return this.commandsApi.createCommand({ createCommandRequest });\n        };\n        this.getCommand = (getCommandRequest) => {\n            return this.commandsApi.getCommand(getCommandRequest);\n        };\n        this.updateCommand = (name, updateCommandRequest) => {\n            return this.commandsApi.updateCommand({ name, updateCommandRequest });\n        };\n        this.deleteCommand = (request) => {\n            return this.commandsApi.deleteCommand(request);\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(configuration);\n        /** @ts-expect-error */\n        this.channelTypesApi = new ChannelTypesApi(configuration);\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.commandsApi = new CustomCommandsApi(configuration);\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH = \"https://stream-io-api.com\".replace(/\\/+$/, \"\");\nclass Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n}\nconst DefaultConfig = new Configuration();\n/**\n * This is the base class for all generated API classes.\n */\nclass BaseAPI {\n    constructor(configuration = DefaultConfig) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n}\nBaseAPI.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nclass ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n}\nclass FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n}\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nfunction querystring(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nclass JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n}\nclass VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DefaultApi extends BaseAPI {\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {\n                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/block`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoBlockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.blockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {\n                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateDeviceRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {\n                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateGuestRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.endCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            if (requestParameters.membersLimit !== undefined) {\n                queryParameters['members_limit'] = requestParameters.membersLimit;\n            }\n            if (requestParameters.ring !== undefined) {\n                queryParameters['ring'] = requestParameters.ring;\n            }\n            if (requestParameters.notify !== undefined) {\n                queryParameters['notify'] = requestParameters.notify;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdgesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/edges`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdges(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getEdgesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {\n                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGetOrCreateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');\n            }\n            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {\n                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/go_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGoLiveRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.goLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordingsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/recordings`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordings(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {\n                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mute_users`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoMuteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCallsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {\n                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calls`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryCallsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCalls(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryCallsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryMembersRequest === null || requestParameters.videoQueryMembersRequest === undefined) {\n                throw new RequiredError('videoQueryMembersRequest', 'Required parameter requestParameters.videoQueryMembersRequest was null or undefined when calling queryMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/members`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.videoSendEventRequest === null || requestParameters.videoSendEventRequest === undefined) {\n                throw new RequiredError('videoSendEventRequest', 'Required parameter requestParameters.videoSendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoSendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {\n                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartRecordingRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {\n                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartTranscriptionRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {\n                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unblock`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnblockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unblockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {\n                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {\n                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/members`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {\n                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateUserPermissionsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoWSAuthMessageRequest === null || requestParameters.videoWSAuthMessageRequest === undefined) {\n                throw new RequiredError('videoWSAuthMessageRequest', 'Required parameter requestParameters.videoWSAuthMessageRequest was null or undefined when calling videoConnect.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoWSAuthMessageRequest,\n            }, initOverrides);\n            return new VoidApiResponse(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnect(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.videoConnectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {\n                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/pin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoPinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoPinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {\n                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unpin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnpinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ServerSideApi extends BaseAPI {\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}/check`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {\n                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCallTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');\n            }\n            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {\n                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');\n            }\n            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass SettingsApi extends BaseAPI {\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorageRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorage(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listExternalStorageRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamCall {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.blockUser = (videoBlockUserRequest) => {\n            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));\n        };\n        this.endCall = () => {\n            return this.apiClient.endCall(Object.assign({}, this.baseRequest));\n        };\n        this.get = (request) => {\n            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));\n        };\n        this.getOrCreate = (videoGetOrCreateCallRequest) => {\n            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));\n        };\n        this.create = (getOrCreateCallRequest) => {\n            return this.getOrCreate(getOrCreateCallRequest);\n        };\n        this.goLive = (videoGoLiveRequest) => {\n            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));\n        };\n        this.listRecordings = () => {\n            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));\n        };\n        this.listTranscriptions = () => {\n            return this.apiClient.listTranscriptions(Object.assign({}, this.baseRequest));\n        };\n        this.muteUsers = (videoMuteUsersRequest) => {\n            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.apiClient.queryMembers({\n                videoQueryMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),\n            });\n        };\n        this.sendCustomEvent = (event) => {\n            return this.apiClient.sendEvent(Object.assign({ videoSendEventRequest: { custom: event } }, this.baseRequest));\n        };\n        this.startHLSBroadcasting = () => {\n            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.startRecording = (request) => {\n            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));\n        };\n        this.startTranscription = (videoStartTranscriptionRequest = {}) => {\n            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));\n        };\n        this.stopHLSBroadcasting = () => {\n            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.stopLive = () => {\n            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));\n        };\n        this.stopRecording = () => {\n            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));\n        };\n        this.stopTranscription = () => {\n            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));\n        };\n        this.unblockUser = (videoUnblockUserRequest) => {\n            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));\n        };\n        this.update = (videoUpdateCallRequest) => {\n            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));\n        };\n        this.updateCallMembers = (videoUpdateCallMembersRequest) => {\n            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));\n        };\n        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {\n            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));\n        };\n        this.pinVideo = (videoPinRequest) => {\n            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));\n        };\n        this.unpinVideo = (videoUnpinRequest) => {\n            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));\n        };\n        this.baseRequest = { id: this.id, type: this.type };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n    }\n}\n\nclass StreamVideoClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.call = (type, id) => {\n            return new StreamCall(this.streamClient, type, id);\n        };\n        this.queryCalls = (request) => {\n            return this.apiClient.queryCalls({\n                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},\n            });\n        };\n        this.createCallType = (videoCreateCallTypeRequest) => {\n            return this.videoServerSideApiClient.createCallType({\n                videoCreateCallTypeRequest,\n            });\n        };\n        this.deleteCallType = (request) => {\n            return this.videoServerSideApiClient.deleteCallType(request);\n        };\n        this.getCallType = (request) => {\n            return this.videoServerSideApiClient.getCallType(request);\n        };\n        this.listCallTypes = () => {\n            return this.videoServerSideApiClient.listCallTypes();\n        };\n        this.updateCallType = (name, videoUpdateCallTypeRequest) => {\n            return this.videoServerSideApiClient.updateCallType({\n                name,\n                videoUpdateCallTypeRequest,\n            });\n        };\n        this.listExternalStorages = () => {\n            return this.settingsApi.listExternalStorage();\n        };\n        this.createExternalStorage = (videoCreateExternalStorageRequest) => {\n            return this.settingsApi.createExternalStorage({\n                videoCreateExternalStorageRequest,\n            });\n        };\n        this.deleteExternalStorage = (request) => {\n            return this.settingsApi.deleteExternalStorage(request);\n        };\n        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {\n            return this.videoServerSideApiClient.updateExternalStorage({\n                name,\n                videoUpdateExternalStorageRequest,\n            });\n        };\n        this.checkExternalStorage = (request) => {\n            return this.videoServerSideApiClient.checkExternalStorage(request);\n        };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n        this.settingsApi = new SettingsApi(configuration);\n        this.videoServerSideApiClient = new ServerSideApi(configuration);\n    }\n}\n\nfunction JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== 'string') {\n        throw new TypeError('userId should be a string');\n    }\n    const payload = Object.assign({ user_id: userId }, extraData);\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true,\n    };\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\n\nclass StreamClient {\n    /**\n     *\n     * @param apiKey\n     * @param secret\n     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object\n     */\n    constructor(apiKey, secret, config) {\n        var _a;\n        this.apiKey = apiKey;\n        this.secret = secret;\n        this.config = config;\n        this.options = {};\n        this.createDevice = (createDeviceRequest) => {\n            return this.devicesApi.createDevice({ createDeviceRequest });\n        };\n        this.deleteDevice = (requestParameters) => {\n            return this.devicesApi.deleteDevice(requestParameters);\n        };\n        this.listDevices = (requestParameters) => {\n            return this.devicesApi.listDevices(requestParameters);\n        };\n        this.listPushProviders = () => {\n            return this.pushApi.listPushProviders();\n        };\n        this.deletePushProvider = (request) => {\n            return this.pushApi.deletePushProvider(request);\n        };\n        this.upsertPushProvider = (request) => {\n            return this.serversideApi.upsertPushProvider({\n                upsertPushProviderRequest: { push_provider: request },\n            });\n        };\n        this.checkPush = (checkPushRequest) => {\n            return this.testingApi.checkPush({ checkPushRequest });\n        };\n        this.createGuest = (guestRequest) => __awaiter(this, void 0, void 0, function* () {\n            guestRequest.user = this.mapCustomDataBeforeSend(guestRequest.user);\n            const response = yield this.usersApi.createGuest({ guestRequest });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.banUser = (banRequest) => {\n            banRequest.user = this.mapCustomDataBeforeSend(banRequest.user);\n            banRequest.banned_by = this.mapCustomDataBeforeSend(banRequest.banned_by);\n            return this.usersApi.ban({ banRequest });\n        };\n        this.deactivateUser = (deactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deactivateUser({\n                deactivateUserRequest,\n                userId: deactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deactivateUsers = (deactivateUsersRequest) => {\n            return this.usersApi.deactivateUsers({ deactivateUsersRequest });\n        };\n        /**\n         * @deprecated use `deleteUsers` instead\n         * @param deleteUsersRequest\n         * @returns\n         */\n        this.deleteUser = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deleteUser(request);\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deleteUsers = (deleteUsersRequest) => {\n            return this.usersApi.deleteUsers({ deleteUsersRequest });\n        };\n        this.exportUser = (request) => {\n            return this.usersApi.exportUser(request);\n        };\n        this.exportUsers = (exportUsersRequest) => {\n            return this.usersApi.exportUsers({ exportUsersRequest });\n        };\n        this.flag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            flagRequest.user = this.mapCustomDataBeforeSend(flagRequest.user);\n            const response = yield this.usersApi.flag({ flagRequest });\n            if ((_b = response.flag) === null || _b === void 0 ? void 0 : _b.user) {\n                response.flag.user = this.mapCustomDataAfterReceive((_c = response.flag) === null || _c === void 0 ? void 0 : _c.user);\n            }\n            return response;\n        });\n        this.queryBannedUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryBannedUsers({ payload });\n            response.bans.forEach((b) => {\n                b.banned_by = this.mapCustomDataAfterReceive(b.banned_by);\n                b.user = this.mapCustomDataAfterReceive(b.user);\n            });\n            return response;\n        });\n        this.queryUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryUsers({ payload });\n            /** @ts-expect-error */\n            response.users = response.users.map((u) => this.mapCustomDataAfterReceive(u));\n            return response;\n        });\n        this.reactivateUser = (reactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.reactivateUser({\n                reactivateUserRequest,\n                userId: reactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n        });\n        this.reactivateUsers = (reactivateUsersRequest) => {\n            return this.usersApi.reactivateUsers({ reactivateUsersRequest });\n        };\n        this.restoreUsers = (restoreUsersRequest) => {\n            return this.usersApi.restoreUsers({ restoreUsersRequest });\n        };\n        this.unbanUser = (request) => {\n            return this.usersApi.unban(request);\n        };\n        this.unflag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            const response = yield this.usersApi.unflag({ flagRequest });\n            if ((_d = response.flag) === null || _d === void 0 ? void 0 : _d.user) {\n                response.flag.user = this.mapCustomDataAfterReceive(response.flag.user);\n            }\n            return response;\n        });\n        this.upsertUsers = (updateUsersRequest) => __awaiter(this, void 0, void 0, function* () {\n            Object.keys(updateUsersRequest.users).forEach((key) => {\n                updateUsersRequest.users[key] = this.mapCustomDataBeforeSend(updateUsersRequest.users[key]);\n            });\n            const response = yield this.usersApi.updateUsers({ updateUsersRequest });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.updateUsersPartial = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.updateUsersPartial({\n                /** @ts-expect-error */\n                updateUserPartialRequest: request,\n            });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.muteUser = (muteUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _e, _f;\n            muteUserRequest.user = this.mapCustomDataBeforeSend(muteUserRequest.user);\n            const response = yield this.usersApi.muteUser({ muteUserRequest });\n            if ((_e = response.mute) === null || _e === void 0 ? void 0 : _e.user) {\n                response.mute.user = this.mapCustomDataAfterReceive((_f = response.mute) === null || _f === void 0 ? void 0 : _f.user);\n            }\n            if (response.mutes) {\n                response.mutes = response.mutes.map((m) => {\n                    return Object.assign(Object.assign({}, m), { user: this.mapCustomDataAfterReceive(m.user) });\n                });\n            }\n            return response;\n        });\n        this.unmuteUser = (unmuteUserRequest) => {\n            unmuteUserRequest.user = this.mapCustomDataBeforeSend(unmuteUserRequest.user);\n            return this.usersApi.unmuteUser({ unmuteUserRequest });\n        };\n        this.sendCustomEventToUser = (userId, event) => {\n            return this.eventsApi.sendUserCustomEvent({\n                userId,\n                sendUserCustomEventRequest: { event },\n            });\n        };\n        this.createRole = (createRoleRequest) => {\n            return this.permissionsApi.createRole({ createRoleRequest });\n        };\n        this.deleteRole = (request) => {\n            return this.permissionsApi.deleteRole(request);\n        };\n        this.getPermission = (request) => {\n            return this.permissionsApi.getPermission(request);\n        };\n        this.listPermissions = () => {\n            return this.permissionsApi.listPermissions();\n        };\n        this.listRoles = () => {\n            return this.permissionsApi.listRoles();\n        };\n        this.getAppSettings = () => {\n            return this.settingsApi.getApp();\n        };\n        this.updateAppSettings = (updateAppRequest) => {\n            return this.settingsApi.updateApp({ updateAppRequest });\n        };\n        this.getRateLimits = () => {\n            return this.settingsApi.getRateLimits();\n        };\n        this.getTaskStatus = (request) => {\n            return this.tasksApi.getTask(request);\n        };\n        this.verifyWebhook = (requestBody, xSignature) => {\n            const key = Buffer.from(this.secret, 'utf8');\n            const hash = crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac('sha256', key)\n                .update(requestBody)\n                .digest('hex');\n            try {\n                return crypto__WEBPACK_IMPORTED_MODULE_1___default().timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));\n            }\n            catch (err) {\n                return false;\n            }\n        };\n        this.getConfiguration = (product = 'chat') => {\n            var _a;\n            return new Configuration({\n                apiKey: (name) => {\n                    const mapping = {\n                        'Stream-Auth-Type': 'jwt',\n                        api_key: this.apiKey,\n                        Authorization: this.token,\n                    };\n                    return mapping[name];\n                },\n                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'\n                    ? 'https://chat.stream-io-api.com'\n                    : 'https://video.stream-io-api.com'),\n                headers: {\n                    'X-Stream-Client': 'stream-node-' + \"0.1.13\",\n                },\n                middleware: [\n                    {\n                        pre: (context) => {\n                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(), 'Accept-Encoding': 'gzip' });\n                            return Promise.resolve(context);\n                        },\n                    },\n                    {\n                        // This should be the last post middleware because that will throw an error\n                        // The Fetch API won't throw an error for HTTP error responses, which means the \"onError\" middleware won't be called so we need to throw error from \"post\" middleware\n                        post: (context) => __awaiter(this, void 0, void 0, function* () {\n                            if ((context.response && context.response.status < 200) ||\n                                context.response.status >= 300) {\n                                const response = new JSONApiResponse(context.response);\n                                const value = (yield response.value());\n                                throw new Error(`Stream error code ${value.code}: ${value.message}`);\n                            }\n                        }),\n                    },\n                    {\n                        pre: (context) => {\n                            context.init.signal = AbortSignal.timeout(this.options.timeout);\n                            return Promise.resolve(context);\n                        },\n                        onError: (context) => {\n                            const error = context.error;\n                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {\n                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);\n                            }\n                            return Promise.resolve(context.response);\n                        },\n                    },\n                ],\n                // https://github.com/OpenAPITools/openapi-generator/issues/13222\n                queryParamsStringify: (params) => {\n                    const newParams = [];\n                    for (const k in params) {\n                        if (Array.isArray(params[k]) || typeof params[k] === 'object') {\n                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(params[k]))}`);\n                        }\n                        else {\n                            const value = params[k];\n                            if (typeof value === 'string' ||\n                                typeof value === 'number' ||\n                                typeof value === 'boolean') {\n                                newParams.push(`${k}=${encodeURIComponent(value)}`);\n                            }\n                        }\n                    }\n                    return newParams.join('&');\n                },\n            });\n        };\n        this.reservedKeywords = [\n            'ban_expires',\n            'banned',\n            'id',\n            'invisible',\n            'language',\n            'push_notifications',\n            'revoke_tokens_issued_before',\n            'role',\n            'teams',\n            'created_at',\n            'deactivated_at',\n            'deleted_at',\n            'last_active',\n            'online',\n            'updated_at',\n            'shadow_banned',\n            'name',\n            'image',\n        ];\n        this.mapCustomDataBeforeSend = (user) => {\n            if (!user) {\n                return undefined;\n            }\n            const copy = Object.assign({}, user);\n            delete copy.custom;\n            return Object.assign(Object.assign({}, copy), user.custom);\n        };\n        this.token = JWTServerToken(this.secret);\n        if (typeof config === 'string') {\n            this.options.basePath = config;\n            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;\n        }\n        else {\n            if (config) {\n                this.options = config;\n            }\n            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;\n        }\n        this.video = new StreamVideoClient(this);\n        this.chat = new StreamChatClient(this);\n        const chatConfiguration = this.getConfiguration();\n        /** @ts-expect-error */\n        this.usersApi = new UsersApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.devicesApi = new DevicesApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.pushApi = new PushApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.serversideApi = new ServerSideApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.testingApi = new TestingApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.permissionsApi = new PermissionsV2Api(chatConfiguration);\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.tasksApi = new TasksApi(chatConfiguration);\n    }\n    /**\n     *\n     * @param userID\n     * @param exp\n     * @param iat deprecated, the default date will be set internally\n     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens\n     * @returns\n     */\n    createToken(userID, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000), call_cids) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        if (call_cids) {\n            console.warn(`Use createCallToken method for creating call tokens, the \"call_cids\" param will be removed from the createToken method with version 0.2.0`);\n            extra.call_cids = call_cids;\n        }\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    /**\n     *\n     * @param userID\n     * @param call_cids\n     * @param exp\n     * @param iat this is deprecated, the current date will be set internally\n     * @returns\n     */\n    createCallToken(userID, call_cids, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000)) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        extra.call_cids = call_cids;\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    mapCustomDataAfterReceive(user) {\n        if (!user) {\n            return undefined;\n        }\n        /** @ts-expect-error */\n        const result = {};\n        Object.keys(user).forEach((key) => {\n            if (!this.reservedKeywords.includes(key)) {\n                if (!result.custom) {\n                    result.custom = {};\n                }\n                result.custom[key] = user[key];\n            }\n            else {\n                result[key] = user[key];\n            }\n        });\n        return result;\n    }\n}\nStreamClient.DEFAULT_TIMEOUT = 3000;\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3RyZWFtLWlvK25vZGUtc2RrQDAuMS4xMy9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby9ub2RlLXNkay9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDSztBQUNIOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0Esa0NBQWtDLEtBQUssWUFBWSxFQUFFLFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLHFDQUFxQyxHQUFHLFlBQVksRUFBRSxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFd25GO0FBQ3huRiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvb20vLi9ub2RlX21vZHVsZXMvLnBucG0vQHN0cmVhbS1pbytub2RlLXNka0AwLjEuMTMvbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vbm9kZS1zZGsvZGlzdC9pbmRleC5lcy5qcz9kZDNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBUE5Db25maWdSZXF1ZXN0QXV0aFR5cGVFbnVtID0ge1xuICAgIENFUlRJRklDQVRFOiAnY2VydGlmaWNhdGUnLFxuICAgIFRPS0VOOiAndG9rZW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFwcFNlYXJjaEJhY2tlbmRFbnVtID0ge1xuICAgIEVMQVNUSUNTRUFSQ0g6ICdlbGFzdGljc2VhcmNoJyxcbiAgICBQT1NUR1JFUzogJ3Bvc3RncmVzJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBOT05FOiAnQ0FMTEJBQ0tfTU9ERV9OT05FJyxcbiAgICBSRVNUOiAnQ0FMTEJBQ0tfTU9ERV9SRVNUJyxcbiAgICBUV0lSUDogJ0NBTExCQUNLX01PREVfVFdJUlAnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc0JlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc1JlcXVlc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9BdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsTWVtYmVyUm9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGVja1B1c2hSZXF1ZXN0UHVzaFByb3ZpZGVyVHlwZUVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTTlNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29uZmlnRGVmYXVsdFJvbGVFbnVtID0ge1xuICAgIEFUVEVOREVFOiAnYXR0ZW5kZWUnLFxuICAgIFBVQkxJU0hFUjogJ3B1Ymxpc2hlcicsXG4gICAgU1VCU0NSSUJFUjogJ3N1YnNjcmliZXInLFxuICAgIEFETUlOOiAnYWRtaW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbmZpZ1JlcXVlc3REZWZhdWx0Um9sZUVudW0gPSB7XG4gICAgQVRURU5ERUU6ICdhdHRlbmRlZScsXG4gICAgUFVCTElTSEVSOiAncHVibGlzaGVyJyxcbiAgICBTVUJTQ1JJQkVSOiAnc3Vic2NyaWJlcicsXG4gICAgQURNSU46ICdhZG1pbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSA9IHtcbiAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICBWSURFTzogJ3ZpZGVvJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBJTlNFUlQ6ICdpbnNlcnQnLFxuICAgIFVQU0VSVDogJ3Vwc2VydCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIEhBUkQ6ICdoYXJkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZWxldGVVc2Vyc1JlcXVlc3RNZXNzYWdlc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGV2aWNlUHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZXZpY2VGaWVsZHNQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEltYWdlU2l6ZUNyb3BFbnVtID0ge1xuICAgIFRPUDogJ3RvcCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG4gICAgQ0VOVEVSOiAnY2VudGVyJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBJbWFnZVNpemVSZXNpemVFbnVtID0ge1xuICAgIENMSVA6ICdjbGlwJyxcbiAgICBDUk9QOiAnY3JvcCcsXG4gICAgU0NBTEU6ICdzY2FsZScsXG4gICAgRklMTDogJ2ZpbGwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IExheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVR5cGVFbnVtID0ge1xuICAgIFJFR1VMQVI6ICdyZWd1bGFyJyxcbiAgICBFUEhFTUVSQUw6ICdlcGhlbWVyYWwnLFxuICAgIEVSUk9SOiAnZXJyb3InLFxuICAgIFJFUExZOiAncmVwbHknLFxuICAgIFNZU1RFTTogJ3N5c3RlbScsXG4gICAgREVMRVRFRDogJ2RlbGV0ZWQnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUGVybWlzc2lvbkxldmVsRW51bSA9IHtcbiAgICBBUFA6ICdhcHAnLFxuICAgIENIQU5ORUw6ICdjaGFubmVsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSA9IHtcbiAgICBERU5ZOiAnRGVueScsXG4gICAgQUxMT1c6ICdBbGxvdydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtID0ge1xuICAgIERFTlk6ICdEZW55JyxcbiAgICBBTExPVzogJ0FsbG93J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQdXNoQ29uZmlnUmVxdWVzdFZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtID0ge1xuICAgIEFGOiAnYWYnLFxuICAgIFNROiAnc3EnLFxuICAgIEFNOiAnYW0nLFxuICAgIEFSOiAnYXInLFxuICAgIEFaOiAnYXonLFxuICAgIEJOOiAnYm4nLFxuICAgIEJTOiAnYnMnLFxuICAgIEJHOiAnYmcnLFxuICAgIFpIOiAnemgnLFxuICAgIFpIX1RXOiAnemgtVFcnLFxuICAgIEhSOiAnaHInLFxuICAgIENTOiAnY3MnLFxuICAgIERBOiAnZGEnLFxuICAgIEZBX0FGOiAnZmEtQUYnLFxuICAgIE5MOiAnbmwnLFxuICAgIEVOOiAnZW4nLFxuICAgIEVUOiAnZXQnLFxuICAgIEZJOiAnZmknLFxuICAgIEZSOiAnZnInLFxuICAgIEZSX0NBOiAnZnItQ0EnLFxuICAgIEtBOiAna2EnLFxuICAgIERFOiAnZGUnLFxuICAgIEVMOiAnZWwnLFxuICAgIEhBOiAnaGEnLFxuICAgIEhFOiAnaGUnLFxuICAgIEhJOiAnaGknLFxuICAgIEhVOiAnaHUnLFxuICAgIElEOiAnaWQnLFxuICAgIElUOiAnaXQnLFxuICAgIEpBOiAnamEnLFxuICAgIEtPOiAna28nLFxuICAgIExWOiAnbHYnLFxuICAgIE1TOiAnbXMnLFxuICAgIE5POiAnbm8nLFxuICAgIEZBOiAnZmEnLFxuICAgIFBTOiAncHMnLFxuICAgIFBMOiAncGwnLFxuICAgIFBUOiAncHQnLFxuICAgIFJPOiAncm8nLFxuICAgIFJVOiAncnUnLFxuICAgIFNSOiAnc3InLFxuICAgIFNLOiAnc2snLFxuICAgIFNMOiAnc2wnLFxuICAgIFNPOiAnc28nLFxuICAgIEVTOiAnZXMnLFxuICAgIEVTX01YOiAnZXMtTVgnLFxuICAgIFNXOiAnc3cnLFxuICAgIFNWOiAnc3YnLFxuICAgIFRMOiAndGwnLFxuICAgIFRBOiAndGEnLFxuICAgIFRIOiAndGgnLFxuICAgIFRSOiAndHInLFxuICAgIFVLOiAndWsnLFxuICAgIFVSOiAndXInLFxuICAgIFZJOiAndmknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RFbmZvcmNlVW5pcXVlVXNlcm5hbWVzRW51bSA9IHtcbiAgICBOTzogJ25vJyxcbiAgICBBUFA6ICdhcHAnLFxuICAgIFRFQU06ICd0ZWFtJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVBcHBSZXF1ZXN0UGVybWlzc2lvblZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSA9IHtcbiAgICBBR09SQTogJ2Fnb3JhJyxcbiAgICBITVM6ICdobXMnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnXG59O1xuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0gPSB7XG4gICAgU1BFQUtFUjogJ3NwZWFrZXInLFxuICAgIEVBUlBJRUNFOiAnZWFycGllY2UnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0xheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9MYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJ1xufTtcbi8qKlxuICogQWxsIHBvc3NpYmlsaXR5IG9mIHN0cmluZyB0byB1c2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9Pd25DYXBhYmlsaXR5ID0ge1xuICAgIEJMT0NLX1VTRVJTOiAnYmxvY2stdXNlcnMnLFxuICAgIENSRUFURV9DQUxMOiAnY3JlYXRlLWNhbGwnLFxuICAgIENSRUFURV9SRUFDVElPTjogJ2NyZWF0ZS1yZWFjdGlvbicsXG4gICAgRU5EX0NBTEw6ICdlbmQtY2FsbCcsXG4gICAgSk9JTl9CQUNLU1RBR0U6ICdqb2luLWJhY2tzdGFnZScsXG4gICAgSk9JTl9DQUxMOiAnam9pbi1jYWxsJyxcbiAgICBKT0lOX0VOREVEX0NBTEw6ICdqb2luLWVuZGVkLWNhbGwnLFxuICAgIE1VVEVfVVNFUlM6ICdtdXRlLXVzZXJzJyxcbiAgICBQSU5fRk9SX0VWRVJZT05FOiAncGluLWZvci1ldmVyeW9uZScsXG4gICAgUkVBRF9DQUxMOiAncmVhZC1jYWxsJyxcbiAgICBSRU1PVkVfQ0FMTF9NRU1CRVI6ICdyZW1vdmUtY2FsbC1tZW1iZXInLFxuICAgIFNDUkVFTlNIQVJFOiAnc2NyZWVuc2hhcmUnLFxuICAgIFNFTkRfQVVESU86ICdzZW5kLWF1ZGlvJyxcbiAgICBTRU5EX1ZJREVPOiAnc2VuZC12aWRlbycsXG4gICAgU1RBUlRfQlJPQURDQVNUX0NBTEw6ICdzdGFydC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RBUlRfUkVDT1JEX0NBTEw6ICdzdGFydC1yZWNvcmQtY2FsbCcsXG4gICAgU1RBUlRfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RhcnQtdHJhbnNjcmlwdGlvbi1jYWxsJyxcbiAgICBTVE9QX0JST0FEQ0FTVF9DQUxMOiAnc3RvcC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RPUF9SRUNPUkRfQ0FMTDogJ3N0b3AtcmVjb3JkLWNhbGwnLFxuICAgIFNUT1BfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RvcC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFVQREFURV9DQUxMOiAndXBkYXRlLWNhbGwnLFxuICAgIFVQREFURV9DQUxMX01FTUJFUjogJ3VwZGF0ZS1jYWxsLW1lbWJlcicsXG4gICAgVVBEQVRFX0NBTExfUEVSTUlTU0lPTlM6ICd1cGRhdGUtY2FsbC1wZXJtaXNzaW9ucycsXG4gICAgVVBEQVRFX0NBTExfU0VUVElOR1M6ICd1cGRhdGUtY2FsbC1zZXR0aW5ncydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9SZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1JlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtID0ge1xuICAgIF8zNjBQOiAnMzYwcCcsXG4gICAgXzQ4MFA6ICc0ODBwJyxcbiAgICBfNzIwUDogJzcyMHAnLFxuICAgIF8xMDgwUDogJzEwODBwJyxcbiAgICBfMTQ0MFA6ICcxNDQwcCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9UcmFuc2NyaXB0aW9uU2V0dGluZ3NNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSA9IHtcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBCQUNLOiAnYmFjaycsXG4gICAgRVhURVJOQUw6ICdleHRlcm5hbCdcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuY29uc3QgQkFTRV9QQVRIJDEgPSBcImh0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG5sZXQgQ29uZmlndXJhdGlvbiQxID0gY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSCQxO1xuICAgIH1cbiAgICBnZXQgZmV0Y2hBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGk7XG4gICAgfVxuICAgIGdldCBtaWRkbGV3YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm1pZGRsZXdhcmUgfHwgW107XG4gICAgfVxuICAgIGdldCBxdWVyeVBhcmFtc1N0cmluZ2lmeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeSB8fCBxdWVyeXN0cmluZyQxO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXNlcm5hbWU7XG4gICAgfVxuICAgIGdldCBwYXNzd29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IGFwaUtleSgpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcGlLZXkgPT09ICdmdW5jdGlvbicgPyBhcGlLZXkgOiAoKSA9PiBhcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nID8gYWNjZXNzVG9rZW4gOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBhY2Nlc3NUb2tlbjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmNyZWRlbnRpYWxzO1xuICAgIH1cbn07XG5jb25zdCBEZWZhdWx0Q29uZmlnJDEgPSBuZXcgQ29uZmlndXJhdGlvbiQxKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmxldCBCYXNlQVBJJDEgPSBjbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uID0gRGVmYXVsdENvbmZpZyQxKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IkMShlLCAnVGhlIHJlcXVlc3QgZmFpbGVkIGFuZCB0aGUgaW50ZXJjZXB0b3JzIGRpZCBub3QgcmV0dXJuIGFuIGFsdGVybmF0aXZlIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5wb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFBhcmFtcy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSBjb25maWd1cmF0aW9uLm1pZGRsZXdhcmU7XG4gICAgfVxuICAgIHdpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG5leHQubWlkZGxld2FyZSA9IG5leHQubWlkZGxld2FyZS5jb25jYXQoLi4ubWlkZGxld2FyZXMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgd2l0aFByZU1pZGRsZXdhcmUoLi4ucHJlTWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSBwcmVNaWRkbGV3YXJlcy5tYXAoKHByZSkgPT4gKHsgcHJlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICAgIH1cbiAgICB3aXRoUG9zdE1pZGRsZXdhcmUoLi4ucG9zdE1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcG9zdE1pZGRsZXdhcmVzLm1hcCgocG9zdCkgPT4gKHsgcG9zdCB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIE1JTUUgaXMgYSBKU09OIE1JTUUuXG4gICAgICogSlNPTiBNSU1FIGV4YW1wbGVzOlxuICAgICAqICAgYXBwbGljYXRpb24vanNvblxuICAgICAqICAgYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEY4XG4gICAgICogICBBUFBMSUNBVElPTi9KU09OXG4gICAgICogICBhcHBsaWNhdGlvbi92bmQuY29tcGFueStqc29uXG4gICAgICogQHBhcmFtIG1pbWUgLSBNSU1FIChNdWx0aXB1cnBvc2UgSW50ZXJuZXQgTWFpbCBFeHRlbnNpb25zKVxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBKU09OLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNKc29uTWltZShtaW1lKSB7XG4gICAgICAgIGlmICghbWltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlQVBJLmpzb25SZWdleC50ZXN0KG1pbWUpO1xuICAgIH1cbiAgICByZXF1ZXN0KGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBpbml0IH0gPSB5aWVsZCB0aGlzLmNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoQXBpKHVybCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yJDEocmVzcG9uc2UsICdSZXNwb25zZSByZXR1cm5lZCBhbiBlcnJvciBjb2RlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5jb25maWd1cmF0aW9uLmJhc2VQYXRoICsgY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucXVlcnkgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhjb250ZXh0LnF1ZXJ5KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgcXVlcnlzdHJpbmcgdG8gdGhlIFVSTCBpZiB0aGVyZSBhcmUgcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGRvbmUgdG8gYXZvaWQgdXJscyBlbmRpbmcgd2l0aCBhIFwiP1wiIGNoYXJhY3RlciB3aGljaCBidWdneSB3ZWJzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGhhbmRsZSBjb3JyZWN0bHkgc29tZXRpbWVzLlxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkoY29udGV4dC5xdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWd1cmF0aW9uLmhlYWRlcnMsIGNvbnRleHQuaGVhZGVycyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleSA9PiBoZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCA/IGRlbGV0ZSBoZWFkZXJzW2tleV0gOiB7fSk7XG4gICAgICAgICAgICBjb25zdCBpbml0T3ZlcnJpZGVGbiA9IHR5cGVvZiBpbml0T3ZlcnJpZGVzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGluaXRPdmVycmlkZXNcbiAgICAgICAgICAgICAgICA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGluaXRPdmVycmlkZXM7IH0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogY29udGV4dC5ib2R5LFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGRlbkluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRQYXJhbXMpLCAoeWllbGQgaW5pdE92ZXJyaWRlRm4oe1xuICAgICAgICAgICAgICAgIGluaXQ6IGluaXRQYXJhbXMsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZGVuSW5pdCksIHsgYm9keTogaXNGb3JtRGF0YSQxKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iJDEob3ZlcnJpZGRlbkluaXQuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdmVycmlkZGVuSW5pdC5ib2R5XG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkob3ZlcnJpZGRlbkluaXQuYm9keSkgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB1cmwsIGluaXQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgYHRoaXNgIGJ5IGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgICAqIGFuZCB0aGVuIHNoYWxsb3cgY2xvbmluZyBkYXRhIG1lbWJlcnMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSB0aGlzLm1pZGRsZXdhcmUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxufTtcbkJhc2VBUEkkMS5qc29uUmVnZXggPSBuZXcgUmVnRXhwKCdeKDo/YXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDo/Oy4qKT8kJywgJ2knKTtcbmZ1bmN0aW9uIGlzQmxvYiQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG59XG5mdW5jdGlvbiBpc0Zvcm1EYXRhJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5sZXQgUmVzcG9uc2VFcnJvciQxID0gY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgfVxufTtcbmxldCBGZXRjaEVycm9yJDEgPSBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59O1xubGV0IFJlcXVpcmVkRXJyb3IkMSA9IGNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn07XG5jb25zdCBDT0xMRUNUSU9OX0ZPUk1BVFMgPSB7XG4gICAgY3N2OiBcIixcIixcbiAgICBzc3Y6IFwiIFwiLFxuICAgIHRzdjogXCJcXHRcIixcbiAgICBwaXBlczogXCJ8XCIsXG59O1xuZnVuY3Rpb24gcXVlcnlzdHJpbmckMShwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHBhcmFtc1trZXldLCBwcmVmaXgpKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignJicpO1xufVxuZnVuY3Rpb24gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHZhbHVlLCBrZXlQcmVmaXggPSAnJykge1xuICAgIGNvbnN0IGZ1bGxLZXkgPSBrZXlQcmVmaXggKyAoa2V5UHJlZml4Lmxlbmd0aCA/IGBbJHtrZXl9XWAgOiBrZXkpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IG11bHRpVmFsdWUgPSB2YWx1ZS5tYXAoc2luZ2xlVmFsdWUgPT4gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzaW5nbGVWYWx1ZSkpKVxuICAgICAgICAgICAgLmpvaW4oYCYke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09YCk7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7bXVsdGlWYWx1ZX1gO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBc0FycmF5ID0gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZ1NpbmdsZUtleSQxKGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmckMSh2YWx1ZSwgZnVsbEtleSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpfWA7XG59XG5mdW5jdGlvbiBjYW5Db25zdW1lRm9ybShjb25zdW1lcykge1xuICAgIGZvciAoY29uc3QgY29uc3VtZSBvZiBjb25zdW1lcykge1xuICAgICAgICBpZiAoJ211bHRpcGFydC9mb3JtLWRhdGEnID09PSBjb25zdW1lLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5sZXQgSlNPTkFwaVJlc3BvbnNlJDEgPSBjbGFzcyBKU09OQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdywgdHJhbnNmb3JtZXIgPSAoanNvblZhbHVlKSA9PiBqc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcih5aWVsZCB0aGlzLnJhdy5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubGV0IFZvaWRBcGlSZXNwb25zZSQxID0gY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDaGFubmVsVHlwZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjaGFubmVsIHR5cGVcbiAgICAgKiBDcmVhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBjaGFubmVsIHR5cGVzXG4gICAgICogTGlzdCBjaGFubmVsIHR5cGVzXG4gICAgICovXG4gICAgbGlzdENoYW5uZWxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIENoYW5uZWxzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydoYXJkX2RlbGV0ZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBkZWxldGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDaGFubmVsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRDaGFubmVsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2V4cG9ydENoYW5uZWxzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZXhwb3J0Q2hhbm5lbHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2V4cG9ydF9jaGFubmVsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydENoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHMgc3RhdHVzXG4gICAgICovXG4gICAgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnRfY2hhbm5lbHMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXhwb3J0IGNoYW5uZWxzIHN0YXR1c1xuICAgICAqL1xuICAgIGdldEV4cG9ydENoYW5uZWxzU3RhdHVzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgY2hhbm5lbCBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZSB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmNyZWF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gdXNlci53YXRjaGluZy5zdGFydFxuICAgICAqIEdldCBvciBjcmVhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcXVlcnlgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBjaGFubmVsIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcyAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuY3JlYXRlZCAtIG1lbWJlci5hZGRlZCAtIG1lbWJlci5yZW1vdmVkIC0gbWVtYmVyLnVwZGF0ZWQgLSB1c2VyLndhdGNoaW5nLnN0YXJ0XG4gICAgICogR2V0IG9yIGNyZWF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T3JDcmVhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGhpZGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhpZGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2hpZGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaGlkZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2hpZGVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGlkZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyBjaGFubmVsIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBNdXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBtdXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tdXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ211dGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbXV0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vbXV0ZS9jaGFubmVsYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIGNoYW5uZWwgZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIE11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIG11dGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncXVlcnlDaGFubmVsc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3NlYXJjaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzIGFjcm9zcyBjaGFubmVscyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzZWFyY2gocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzaG93Q2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zaG93Q2hhbm5lbFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzaG93Q2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNob3dDaGFubmVsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9zaG93YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNob3dDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnRydW5jYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQ2hhbm5lbCAtIFRydW5jYXRlQ2hhbm5lbFxuICAgICAqIFRydW5jYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB0cnVuY2F0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRydW5jYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3RydW5jYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3RydW5jYXRlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudHJ1bmNhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudHJ1bmNhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsIC0gVHJ1bmNhdGVDaGFubmVsXG4gICAgICogVHJ1bmNhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHRydW5jYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnRydW5jYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndW5tdXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5tdXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bm11dGUvY2hhbm5lbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bm11dGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VucmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bnJlYWRDb3VudHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjaGFubmVsIGRhdGEgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gbWVzc2FnZS5uZXcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZE93bkNoYW5uZWxNZW1iZXJzaGlwIC0gUmVtb3ZlT3duQ2hhbm5lbE1lbWJlcnNoaXAgLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plbiAtIFVwZGF0ZUNoYW5uZWxNZW1iZXJzXG4gICAgICogVXBkYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY2hhbm5lbCBkYXRhICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkIC0gbWVtYmVyLmFkZGVkIC0gbWVtYmVyLnJlbW92ZWQgLSBtZW1iZXIudXBkYXRlZCAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRPd25DaGFubmVsTWVtYmVyc2hpcCAtIFJlbW92ZU93bkNoYW5uZWxNZW1iZXJzaGlwIC0gVXBkYXRlQ2hhbm5lbCAtIFVwZGF0ZUNoYW5uZWxDb29sZG93biAtIFVwZGF0ZUNoYW5uZWxGcm96ZW4gLSBVcGRhdGVDaGFubmVsTWVtYmVyc1xuICAgICAqIFVwZGF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDdXN0b21Db21tYW5kc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNvbW1hbmRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY3VzdG9tIGNoYXQgY29tbWFuZFxuICAgICAqIERlbGV0ZSBjb21tYW5kXG4gICAgICovXG4gICAgZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogRGVsZXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBkZWxldGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29tbWFuZHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENvbW1hbmRzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBVcGRhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDb21tYW5kUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogVXBkYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICB1cGRhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIERldmljZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZXNcbiAgICAgKiBMaXN0IGRldmljZXNcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgZGV2aWNlc1xuICAgICAqIExpc3QgZGV2aWNlc1xuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIEV2ZW50c0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogU2VuZHMgZXZlbnQgdG8gdGhlIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBhbnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlbmRDdXN0b21FdmVudFxuICAgICAqIFNlbmQgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kRXZlbnRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2V2ZW50YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBldmVudCB0byB0aGUgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGFueSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEN1c3RvbUV2ZW50XG4gICAgICogU2VuZCBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY3VzdG9tIGV2ZW50IHRvIGEgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbVxuICAgICAqIFNlbmQgdXNlciBldmVudFxuICAgICAqL1xuICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGN1c3RvbSBldmVudCB0byBhIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjdXN0b21cbiAgICAgKiBTZW5kIHVzZXIgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kVXNlckN1c3RvbUV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFVzZXJDdXN0b21FdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIE1lc3NhZ2VzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBmaWxlXG4gICAgICovXG4gICAgZGVsZXRlRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUF0dGFjaG1lbnRcbiAgICAgKiBEZWxldGUgZmlsZVxuICAgICAqL1xuICAgIGRlbGV0ZUZpbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVGaWxlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGltYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVBdHRhY2htZW50XG4gICAgICogRGVsZXRlIGltYWdlXG4gICAgICovXG4gICAgZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlSW1hZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcHJldmlvdXNseSB1cGxvYWRlZCBpbWFnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBpbWFnZVxuICAgICAqL1xuICAgIGRlbGV0ZUltYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVkQnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlZF9ieSddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlZEJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uL3t0eXBlfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUmVhY3Rpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdmbGFnUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBmbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2ZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3QgbWVzc2FnZXMgZm91bmQgYnkgSURzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCBtYW55IG1lc3NhZ2VzXG4gICAgICovXG4gICAgZ2V0TWFueU1lc3NhZ2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWFueU1lc3NhZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRNYW55TWVzc2FnZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkcyddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG1lc3NhZ2VzIGZvdW5kIGJ5IElEcyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWFueSBtZXNzYWdlc1xuICAgICAqL1xuICAgIGdldE1hbnlNZXNzYWdlcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE1hbnlNZXNzYWdlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWVzc2FnZSBieSBJRCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWVzc2FnZVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1lc3NhZ2UgYnkgSUQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0TWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBPcGVuR3JhcGggYXR0YWNobWVudCBmb3IgYSBsaW5rXG4gICAgICogR2V0IE9HXG4gICAgICovXG4gICAgZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1cmwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9vZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIE9wZW5HcmFwaCBhdHRhY2htZW50IGZvciBhIGxpbmtcbiAgICAgKiBHZXQgT0dcbiAgICAgKi9cbiAgICBnZXRPRyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgcmVhY3Rpb25zIG9mIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlYWN0aW9uc1xuICAgICAqL1xuICAgIGdldFJlYWN0aW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRSZWFjdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydsaW1pdCddID0gcmVxdWVzdFBhcmFtZXRlcnMubGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ29mZnNldCddID0gcmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vcmVhY3Rpb25zYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIHJlYWN0aW9ucyBvZiBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZWFjdGlvbnNcbiAgICAgKi9cbiAgICBnZXRSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSZWFjdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJlcGxpZXMgKHRocmVhZCkgb2YgdGhlIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlcGxpZXNcbiAgICAgKi9cbiAgICBnZXRSZXBsaWVzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3BhcmVudElkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFJlcGxpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEd0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9ndGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfZ3QnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWRMdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfbHRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkX2x0J10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFmdGVyT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2FmdGVyX29yX2VxdWFsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBZnRlck9yRXF1YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9hZnRlciddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2JlZm9yZV9vcl9lcXVhbCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9iZWZvcmUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEJlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9hcm91bmQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkQXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2Fyb3VuZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3twYXJlbnRfaWR9L3JlcGxpZXNgLnJlcGxhY2UoYHske1wicGFyZW50X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByZXBsaWVzICh0aHJlYWQpIG9mIHRoZSBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZXBsaWVzXG4gICAgICovXG4gICAgZ2V0UmVwbGllcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFJlcGxpZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgbWVzc2FnZSBmbGFncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZE1lc3NhZ2VGbGFnc1xuICAgICAqIFF1ZXJ5IE1lc3NhZ2UgRmxhZ3NcbiAgICAgKi9cbiAgICBxdWVyeU1lc3NhZ2VGbGFnc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vZmxhZ3MvbWVzc2FnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIG1lc3NhZ2UgZmxhZ3MgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRNZXNzYWdlRmxhZ3NcbiAgICAgKiBRdWVyeSBNZXNzYWdlIEZsYWdzXG4gICAgICovXG4gICAgcXVlcnlNZXNzYWdlRmxhZ3MocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVzc2FnZUZsYWdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgbWVzc2FnZSBjb21tYW5kIGFjdGlvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLm5ldyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUnVuTWVzc2FnZUFjdGlvblxuICAgICAqIFJ1biBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uXG4gICAgICovXG4gICAgcnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtZXNzYWdlQWN0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZUFjdGlvblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L2FjdGlvbmAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5tZXNzYWdlQWN0aW9uUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSdW5NZXNzYWdlQWN0aW9uXG4gICAgICogUnVuIG1lc3NhZ2UgY29tbWFuZCBhY3Rpb25cbiAgICAgKi9cbiAgICBydW5NZXNzYWdlQWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBtZXNzYWdlcyBhY3Jvc3MgY2hhbm5lbHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzXG4gICAgICovXG4gICAgc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvc2VhcmNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbmV3IG1lc3NhZ2UgdG8gdGhlIHNwZWNpZmllZCBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5uZXcgLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gQ3JlYXRlTWVzc2FnZSAtIFBpbk1lc3NhZ2UgLSBTa2lwQ2hhbm5lbENvb2xkb3duIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXNlRnJvemVuQ2hhbm5lbFxuICAgICAqIFNlbmQgbmV3IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG5ldyBtZXNzYWdlIHRvIHRoZSBzcGVjaWZpZWQgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIENyZWF0ZU1lc3NhZ2UgLSBQaW5NZXNzYWdlIC0gU2tpcENoYW5uZWxDb29sZG93biAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIG5ldyBtZXNzYWdlXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHJlYWN0aW9uIHRvIHNwZWNpZmllZCBtZXNzYWdlICBTZW5kcyBldmVudHM6IC0gcmVhY3Rpb24ubmV3IC0gcmVhY3Rpb24udXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlUmVhY3Rpb24gLSBVc2VGcm96ZW5DaGFubmVsXG4gICAgICogU2VuZCByZWFjdGlvblxuICAgICAqL1xuICAgIHNlbmRSZWFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFJlYWN0aW9uUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kUmVhY3Rpb25SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZFJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRSZWFjdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgcmVhY3Rpb24gdG8gc3BlY2lmaWVkIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5uZXcgLSByZWFjdGlvbi51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVSZWFjdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIHJlYWN0aW9uXG4gICAgICovXG4gICAgc2VuZFJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBtZXNzYWdlIHRvIGEgZ2l2ZW4gbGFuZ3VhZ2UgdXNpbmcgYXV0b21hdGVkIHRyYW5zbGF0aW9uIHNvZnR3YXJlICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFRyYW5zbGF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHJhbnNsYXRlTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3RyYW5zbGF0ZWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy50cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG1lc3NhZ2UgdG8gYSBnaXZlbiBsYW5ndWFnZSB1c2luZyBhdXRvbWF0ZWQgdHJhbnNsYXRpb24gc29mdHdhcmUgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogVHJhbnNsYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB0cmFuc2xhdGVNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbWVzc2FnZSB3aXRoIG5ldyBkYXRhICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIFBpbk1lc3NhZ2UgLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVcGRhdGVNZXNzYWdlXG4gICAgICogVXBkYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBtZXNzYWdlIHdpdGggbmV3IGRhdGEgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gUGluTWVzc2FnZSAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVwZGF0ZU1lc3NhZ2VcbiAgICAgKiBVcGRhdGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZVBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgZmlsZVxuICAgICAqL1xuICAgIHVwbG9hZEZpbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uc3VtZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBjb250ZW50VHlwZTogJ211bHRpcGFydC9mb3JtLWRhdGEnIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogY2FuQ29uc3VtZUZvcm0gbWF5IGJlIHVudXNlZFxuICAgICAgICAgICAgY2FuQ29uc3VtZUZvcm0oY29uc3VtZXMpO1xuICAgICAgICAgICAgbGV0IGZvcm1QYXJhbXM7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5maWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JtUGFyYW1zLmFwcGVuZCgnZmlsZScsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1QYXJhbXMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBmaWxlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGxvYWRBdHRhY2htZW50XG4gICAgICogVXBsb2FkIGZpbGVcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBsb2FkRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEltYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVzID0gW1xuICAgICAgICAgICAgICAgIHsgY29udGVudFR5cGU6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGNhbkNvbnN1bWVGb3JtIG1heSBiZSB1bnVzZWRcbiAgICAgICAgICAgIGNhbkNvbnN1bWVGb3JtKGNvbnN1bWVzKTtcbiAgICAgICAgICAgIGxldCBmb3JtUGFyYW1zO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ2ZpbGUnLCByZXF1ZXN0UGFyYW1ldGVycy5maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcykge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1cGxvYWRfc2l6ZXMnLCByZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcy5qb2luKENPTExFQ1RJT05fRk9STUFUU1tcImNzdlwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtUGFyYW1zLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwbG9hZEltYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgUGVybWlzc2lvbnNWMkFwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gcm9sZVxuICAgICAqIENyZWF0ZSByb2xlXG4gICAgICovXG4gICAgY3JlYXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVSb2xlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVSb2xlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY3VzdG9tIHJvbGVcbiAgICAgKiBDcmVhdGUgcm9sZVxuICAgICAqL1xuICAgIGNyZWF0ZVJvbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVSb2xlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJvbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVJvbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1c3RvbSBwZXJtaXNzaW9uXG4gICAgICogR2V0IHBlcm1pc3Npb25cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFBlcm1pc3Npb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9ucy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXN0b20gcGVybWlzc2lvblxuICAgICAqIEdldCBwZXJtaXNzaW9uXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFBlcm1pc3Npb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIHBlcm1pc3Npb25zXG4gICAgICogTGlzdCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIGxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9uc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBwZXJtaXNzaW9uc1xuICAgICAqIExpc3QgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICBsaXN0UGVybWlzc2lvbnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSByb2xlc1xuICAgICAqIExpc3Qgcm9sZXNcbiAgICAgKi9cbiAgICBsaXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcm9sZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgcm9sZXNcbiAgICAgKiBMaXN0IHJvbGVzXG4gICAgICovXG4gICAgbGlzdFJvbGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFB1c2hBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUHVzaFByb3ZpZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnMve3R5cGV9L3tuYW1lfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXIgZnJvbSB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnQuIHYxIGlzblxcJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZGV0YWlscyBvZiBhbGwgcHVzaCBwcm92aWRlcnMuXG4gICAgICogTGlzdCBwdXNoIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGxpc3RQdXNoUHJvdmlkZXJzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xubGV0IFNlcnZlclNpZGVBcGkkMSA9IGNsYXNzIFNlcnZlclNpZGVBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXIgZm9yIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydFxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICB1cHNlcnRQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cHNlcnRQdXNoUHJvdmlkZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Vwc2VydFB1c2hQcm92aWRlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cHNlcnRQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3B1c2hfcHJvdmlkZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyIGZvciB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnRcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgdXBzZXJ0UHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBzZXJ0UHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmxldCBTZXR0aW5nc0FwaSQxID0gY2xhc3MgU2V0dGluZ3NBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IGNyZWF0ZWQgYXBwbGljYXRpb24gYmxvY2tsaXN0XG4gICAgICogRGVsZXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBkZWxldGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgY3JlYXRlZCBhcHBsaWNhdGlvbiBibG9ja2xpc3RcbiAgICAgKiBEZWxldGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyIGZyb20gdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0LiB2MSBpc25cXCd0IHN1cHBvcnRlZCBpbiB0aGlzIGVuZHBvaW50XG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIGRlbGV0ZVB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVycy97dHlwZX0ve25hbWV9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHBSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHAoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldEFwcFJhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBibG9jayBsaXN0IGJ5IGdpdmVuIG5hbWVcbiAgICAgKiBHZXQgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGdldEJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldEJsb2NrTGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYmxvY2sgbGlzdCBieSBnaXZlbiBuYW1lXG4gICAgICogR2V0IGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBnZXRCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3NlcnZlcl9zaWRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmFuZHJvaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snYW5kcm9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuYW5kcm9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaW9zJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMud2ViICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3dlYiddID0gcmVxdWVzdFBhcmFtZXRlcnMud2ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydlbmRwb2ludHMnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yYXRlX2xpbWl0c2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJsb2NrIGxpc3RzXG4gICAgICogTGlzdCBibG9jayBsaXN0c1xuICAgICAqL1xuICAgIGxpc3RCbG9ja0xpc3RzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBibG9jayBsaXN0c1xuICAgICAqIExpc3QgYmxvY2sgbGlzdHNcbiAgICAgKi9cbiAgICBsaXN0QmxvY2tMaXN0cyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdEJsb2NrTGlzdHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIGNoYW5uZWwgdHlwZXNcbiAgICAgKiBMaXN0IGNoYW5uZWwgdHlwZXNcbiAgICAgKi9cbiAgICBsaXN0Q2hhbm5lbFR5cGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Q2hhbm5lbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRldGFpbHMgb2YgYWxsIHB1c2ggcHJvdmlkZXJzLlxuICAgICAqIExpc3QgcHVzaCBwcm92aWRlcnNcbiAgICAgKi9cbiAgICBsaXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQdXNoUHJvdmlkZXJzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIG9uZSBvciBtb3JlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogVXBkYXRlIEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZUFwcFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQXBwUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUFwcC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyBvbmUgb3IgbW9yZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIFVwZGF0ZSBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVBcHAocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVBcHBSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnRzIG9mIHRoZSBibG9jayBsaXN0XG4gICAgICogVXBkYXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICB1cGRhdGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udGVudHMgb2YgdGhlIGJsb2NrIGxpc3RcbiAgICAgKiBVcGRhdGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIHVwZGF0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBUYXNrc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFRhc2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC90YXNrcy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0VGFza1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFRlc3RpbmdBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBVc2Vyc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIHVzZXIgYWN0aXZpdHkgZWl0aGVyIGluIHNwZWNpZmljIGNoYW5uZWwgb3IgZ2xvYmFsbHkgIFNlbmRzIGV2ZW50czogLSB1c2VyLmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBCYW4gdXNlclxuICAgICAqL1xuICAgIGJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnYmFuUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJhbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0cyB1c2VyIGFjdGl2aXR5IGVpdGhlciBpbiBzcGVjaWZpYyBjaGFubmVsIG9yIGdsb2JhbGx5ICBTZW5kcyBldmVudHM6IC0gdXNlci5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogQmFuIHVzZXJcbiAgICAgKi9cbiAgICBiYW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5iYW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICBjb25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29ubmVjdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBDb25uZWN0IChXZWJTb2NrZXQpXG4gICAgICovXG4gICAgY29ubmVjdChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBndWVzdCB1c2VyXG4gICAgICogQ3JlYXRlIGd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5ndWVzdFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZ3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdndWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUd1ZXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ndWVzdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGd1ZXN0IHVzZXJcbiAgICAgKiBDcmVhdGUgZ3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUd1ZXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgdXNlciB3aXRoIHBvc3NpYmlsaXR5IHRvIGFjdGl2YXRlIGl0IGJhY2sgIFNlbmRzIGV2ZW50czogLSB1c2VyLmRlYWN0aXZhdGVkXG4gICAgICogRGVhY3RpdmF0ZSB1c2VyXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlYWN0aXZhdGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9kZWFjdGl2YXRlYC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB1c2VyIHdpdGggcG9zc2liaWxpdHkgdG8gYWN0aXZhdGUgaXQgYmFjayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlYWN0aXZhdGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5kZWFjdGl2YXRlZFxuICAgICAqIERlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWFjdGl2YXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL2RlYWN0aXZhdGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGUgdXNlcnMgaW4gYmF0Y2hlcyAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJzXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVhY3RpdmF0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtNZXNzYWdlc0RlbGV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snbWFya19tZXNzYWdlc19kZWxldGVkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5tYXJrTWVzc2FnZXNEZWxldGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZF9kZWxldGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlX2NvbnZlcnNhdGlvbl9jaGFubmVscyddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9YC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHVzZXJzIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzIGFzeW5jaHJvbm91c2x5LiAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSBVc2Vyc1xuICAgICAqL1xuICAgIGRlbGV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdXNlcnMgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MgYXN5bmNocm9ub3VzbHkuICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIFVzZXJzXG4gICAgICovXG4gICAgZGVsZXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXNlcklkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBleHBvcnRVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L2V4cG9ydGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZXhwb3J0VXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdXNlciBwcm9maWxlLCByZWFjdGlvbnMgYW5kIG1lc3NhZ2VzIGZvciBsaXN0IG9mIGdpdmVuIHVzZXJzXG4gICAgICogRXhwb3J0IHVzZXJzXG4gICAgICovXG4gICAgZXhwb3J0VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0VXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdleHBvcnRVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydFVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGV4cG9ydFVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnQvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB1c2VyIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMgZm9yIGxpc3Qgb2YgZ2l2ZW4gdXNlcnNcbiAgICAgKiBFeHBvcnQgdXNlcnNcbiAgICAgKi9cbiAgICBleHBvcnRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydFVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZmxhZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9mbGFnYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb25ncG9sbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9uZ1BvbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgb25lIG9yIHNldmVyYWwgdXNlcnMgIFNlbmRzIGV2ZW50czogLSB1c2VyLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIE11dGUgdXNlclxuICAgICAqL1xuICAgIG11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbXV0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9tdXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIG9uZSBvciBzZXZlcmFsIHVzZXJzICBTZW5kcyBldmVudHM6IC0gdXNlci5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZVVzZXJcbiAgICAgKiBNdXRlIHVzZXJcbiAgICAgKi9cbiAgICBtdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3F1ZXJ5X2Jhbm5lZF91c2Vyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGZpbHRlciB1c2VycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VhcmNoVXNlclxuICAgICAqIFF1ZXJ5IHVzZXJzXG4gICAgICovXG4gICAgcXVlcnlVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgdXNlcnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlYXJjaFVzZXJcbiAgICAgKiBRdWVyeSB1c2Vyc1xuICAgICAqL1xuICAgIHF1ZXJ5VXNlcnMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdXNlciB3aG9cXCdzIGJlZW4gZGVhY3RpdmF0ZWQgcHJldmlvdXNseSAgU2VuZHMgZXZlbnRzOiAtIHVzZXIucmVhY3RpdmF0ZWRcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcmVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZWFjdGl2YXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L3JlYWN0aXZhdGVgLnJlcGxhY2UoYHske1widXNlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB1c2VyIHdob1xcJ3MgYmVlbiBkZWFjdGl2YXRlZCBwcmV2aW91c2x5ICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlclxuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJzIGluIGJhdGNoZXMgIFNlbmRzIGV2ZW50czogLSB1c2VyLnJlYWN0aXZhdGVkXG4gICAgICogUmVhY3RpdmF0ZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJlYWN0aXZhdGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvcmVhY3RpdmF0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHNvZnQgZGVsZXRlZCB1c2Vyc1xuICAgICAqIFJlc3RvcmUgdXNlcnNcbiAgICAgKi9cbiAgICByZXN0b3JlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Jlc3RvcmVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZXN0b3JlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3Jlc3RvcmVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc29mdCBkZWxldGVkIHVzZXJzXG4gICAgICogUmVzdG9yZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlc3RvcmVVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlc3RvcmVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRVc2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndGFyZ2V0X3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldFVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3R5cGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRCeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2J5J10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bmJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1bm11dGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bm11dGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VubXV0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVubXV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3IgY3JlYXRlIHVzZXJzIGluIGJ1bGsgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBVcHNlcnQgdXNlcnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBvciBjcmVhdGUgdXNlcnMgaW4gYnVsayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIFVwc2VydCB1c2Vyc1xuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2Vyc1BhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFN0cmVhbUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCwgdHlwZSwgaWQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kZWxldGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZGVsZXRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCAocmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDoge30pKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHVwZGF0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdXBkYXRlQ2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpYWwgPSAodXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsUGFydGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUgPSAoY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0OiBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0ICE9PSBudWxsICYmIGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgIT09IHZvaWQgMCA/IGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgb3BlcmF0aW9uIGlzbid0IHlldCBpbXBsZW1lbnRlZGApO1xuICAgICAgICAgICAgICAgIC8vIGlmICghY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdD8uZGF0YT8ubWVtYmVycykge1xuICAgICAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwcm92aWRlIG1lbWJlcnMgdG8gY3JlYXRlIGEgY2hhbm5lbCB3aXRob3V0IElEJyk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWxUeXBlMSh7dHlwZTogdGhpcy50eXBlLCBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0fSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5pZCA9IHJlc3BvbnNlLmNoYW5uZWw/LmlkO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya1JlYWQgPSAobWFya1JlYWRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5tYXJrUmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtSZWFkUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFya1VucmVhZCA9IChtYXJrVW5yZWFkUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubWFya1VucmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtVbnJlYWRSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93ID0gKHNob3dDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2hvd0NoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBzaG93Q2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhpZGUgPSAoaGlkZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5oaWRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IGhpZGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJ1bmNhdGUgPSAodHJ1bmNhdGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudHJ1bmNhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdHJ1bmNhdGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVlcnlNZW1iZXJzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgcmVxdWVzdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlID0gKG11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubXV0ZUNoYW5uZWwoe1xuICAgICAgICAgICAgICAgIG11dGVDaGFubmVsUmVxdWVzdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkczogW3RoaXMuY2lkXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVubXV0ZSA9ICh1bm11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudW5tdXRlQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgdW5tdXRlQ2hhbm5lbFJlcXVlc3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdW5tdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkOiB0aGlzLmNpZCwgY2hhbm5lbF9jaWRzOiBbXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiB0aGVyZSBpcyBwcm9iYWJseSBhbiBpc3N1ZSB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZSBoZXJlXG4gICAgICAgIC8vIHVwbG9hZEZpbGUgPSAob3B0aW9uczogT21pdDxPbWl0VHlwZUlkPFVwbG9hZEZpbGVSZXF1ZXN0PiwgJ2ZpbGUnPiwgZmlsZTogQnVmZmVyKSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBsb2FkRmlsZSh7Li4ub3B0aW9ucywgLi4udGhpcy5iYXNlUmVxdWVzdCwgZmlsZTogZmlsZSBhcyBhbnkgYXMgc3RyaW5nfSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZGVsZXRlRmlsZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPERlbGV0ZUZpbGVSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUZpbGUoey4uLnJlcXVlc3QsIC4uLnRoaXMuYmFzZVJlcXVlc3R9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB1cGxvYWRJbWFnZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPFVwbG9hZEltYWdlUmVxdWVzdD4pID0+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS51cGxvYWRJbWFnZSh7Li4ucmVxdWVzdCwgLi4udGhpcy5iYXNlUmVxdWVzdH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGRlbGV0ZUltYWdlID0gKHJlcXVlc3Q6IE9taXRUeXBlSWQ8RGVsZXRlSW1hZ2VSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUltYWdlKHsuLi5yZXF1ZXN0LCAuLi50aGlzLmJhc2VSZXF1ZXN0fSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IChzZW5kTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZE1lc3NhZ2VSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVNZXNzYWdlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZU1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZSA9IChpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnVwZGF0ZU1lc3NhZ2UoeyBpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWwgPSAoaWQsIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBkYXRlTWVzc2FnZVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNYW55TWVzc2FnZXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWFueU1lc3NhZ2VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGVNZXNzYWdlID0gKGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudHJhbnNsYXRlTWVzc2FnZSh7IGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlc0Fyb3VuZCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRSZXBsaWVzKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9wZW5HcmFwaERhdGEgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0T0cocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VSZWFjdGlvbiA9IChtZXNzYWdlSWQsIHNlbmRSZWFjdGlvblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRSZWFjdGlvbih7XG4gICAgICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBzZW5kUmVhY3Rpb25SZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlTWVzc2FnZVJlYWN0aW9uID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlUmVhY3Rpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlUmVhY3Rpb25zID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0UmVhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHsgaWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEN1c3RvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZEV2ZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZEV2ZW50UmVxdWVzdDogeyBldmVudCB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuc3RyZWFtQ2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsc0FwaSA9IG5ldyBDaGFubmVsc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlc0FwaSA9IG5ldyBNZXNzYWdlc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5ldmVudHNBcGkgPSBuZXcgRXZlbnRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBnZXQgY2lkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlUmVxdWVzdC50eXBlfToke3RoaXMuYmFzZVJlcXVlc3QuaWR9YDtcbiAgICB9XG4gICAgZ2V0IGJhc2VSZXF1ZXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGUgY2hhbm5lbCB3aXRoIGBnZXRPckNyZWF0ZWAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1DaGF0Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1DbGllbnQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1DaGFubmVsKHRoaXMuc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQmxvY2tMaXN0ID0gKGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmNyZWF0ZUJsb2NrTGlzdCh7IGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEJsb2NrTGlzdHMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0QmxvY2tMaXN0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEJsb2NrTGlzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5nZXRCbG9ja0xpc3QocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQmxvY2tMaXN0ID0gKG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUJsb2NrTGlzdCh7IG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQmxvY2tMaXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDaGFubmVsVHlwZSA9IChjcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlc0FwaS5jcmVhdGVDaGFubmVsVHlwZSh7IGNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDaGFubmVsVHlwZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkuZGVsZXRlQ2hhbm5lbFR5cGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q2hhbm5lbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLmdldENoYW5uZWxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RDaGFubmVsVHlwZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkubGlzdENoYW5uZWxUeXBlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNoYW5uZWxUeXBlID0gKG5hbWUsIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLnVwZGF0ZUNoYW5uZWxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXJ5Q2hhbm5lbHMgPSAocXVlcnlDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5Q2hhbm5lbHMoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0OiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gdm9pZCAwID8gcXVlcnlDaGFubmVsc1JlcXVlc3QgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VhcmNoTWVzc2FnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2VhcmNoKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRDaGFubmVscyA9IChleHBvcnRDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLmV4cG9ydENoYW5uZWxzKHtcbiAgICAgICAgICAgICAgICBleHBvcnRDaGFubmVsc1JlcXVlc3Q6IGV4cG9ydENoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBleHBvcnRDaGFubmVsc1JlcXVlc3QgIT09IHZvaWQgMCA/IGV4cG9ydENoYW5uZWxzUmVxdWVzdCA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFeHBvcnRTdGF0dXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdENvbW1hbmRzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkubGlzdENvbW1hbmRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tbWFuZCA9IChjcmVhdGVDb21tYW5kUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkuY3JlYXRlQ29tbWFuZCh7IGNyZWF0ZUNvbW1hbmRSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbW1hbmQgPSAoZ2V0Q29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmdldENvbW1hbmQoZ2V0Q29tbWFuZFJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbW1hbmQgPSAobmFtZSwgdXBkYXRlQ29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLnVwZGF0ZUNvbW1hbmQoeyBuYW1lLCB1cGRhdGVDb21tYW5kUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDb21tYW5kID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmRlbGV0ZUNvbW1hbmQocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3NBcGkgPSBuZXcgU2V0dGluZ3NBcGkkMShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsVHlwZXNBcGkgPSBuZXcgQ2hhbm5lbFR5cGVzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxzQXBpID0gbmV3IENoYW5uZWxzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRzQXBpID0gbmV3IEN1c3RvbUNvbW1hbmRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjEwMC40LjNcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5jb25zdCBCQVNFX1BBVEggPSBcImh0dHBzOi8vc3RyZWFtLWlvLWFwaS5jb21cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSDtcbiAgICB9XG4gICAgZ2V0IGZldGNoQXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmZldGNoQXBpO1xuICAgIH1cbiAgICBnZXQgbWlkZGxld2FyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5taWRkbGV3YXJlIHx8IFtdO1xuICAgIH1cbiAgICBnZXQgcXVlcnlQYXJhbXNTdHJpbmdpZnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkgfHwgcXVlcnlzdHJpbmc7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi51c2VybmFtZTtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBhc3N3b3JkO1xuICAgIH1cbiAgICBnZXQgYXBpS2V5KCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5O1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFwaUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGFwaUtleSA6ICgpID0+IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5jb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbicgPyBhY2Nlc3NUb2tlbiA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGFjY2Vzc1Rva2VuOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHM7XG4gICAgfVxufVxuY29uc3QgRGVmYXVsdENvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24gPSBEZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoZSwgJ1RoZSByZXF1ZXN0IGZhaWxlZCBhbmQgdGhlIGludGVyY2VwdG9ycyBkaWQgbm90IHJldHVybiBhbiBhbHRlcm5hdGl2ZSByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWlkZGxld2FyZS5wb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gKHlpZWxkIG1pZGRsZXdhcmUucG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogZmV0Y2hQYXJhbXMuaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gY29uZmlndXJhdGlvbi5taWRkbGV3YXJlO1xuICAgIH1cbiAgICB3aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSBuZXh0Lm1pZGRsZXdhcmUuY29uY2F0KC4uLm1pZGRsZXdhcmVzKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHdpdGhQcmVNaWRkbGV3YXJlKC4uLnByZU1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcHJlTWlkZGxld2FyZXMubWFwKChwcmUpID0+ICh7IHByZSB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgd2l0aFBvc3RNaWRkbGV3YXJlKC4uLnBvc3RNaWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHBvc3RNaWRkbGV3YXJlcy5tYXAoKHBvc3QpID0+ICh7IHBvc3QgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBNSU1FIGlzIGEgSlNPTiBNSU1FLlxuICAgICAqIEpTT04gTUlNRSBleGFtcGxlczpcbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGOFxuICAgICAqICAgQVBQTElDQVRJT04vSlNPTlxuICAgICAqICAgYXBwbGljYXRpb24vdm5kLmNvbXBhbnkranNvblxuICAgICAqIEBwYXJhbSBtaW1lIC0gTUlNRSAoTXVsdGlwdXJwb3NlIEludGVybmV0IE1haWwgRXh0ZW5zaW9ucylcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIE1JTUUgaXMgSlNPTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSnNvbk1pbWUobWltZSkge1xuICAgICAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFzZUFQSS5qc29uUmVnZXgudGVzdChtaW1lKTtcbiAgICB9XG4gICAgcmVxdWVzdChjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgaW5pdCB9ID0geWllbGQgdGhpcy5jcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mZXRjaEFwaSh1cmwsIGluaXQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgJ1Jlc3BvbnNlIHJldHVybmVkIGFuIGVycm9yIGNvZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggKyBjb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5xdWVyeSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKGNvbnRleHQucXVlcnkpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBxdWVyeXN0cmluZyB0byB0aGUgVVJMIGlmIHRoZXJlIGFyZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCB1cmxzIGVuZGluZyB3aXRoIGEgXCI/XCIgY2hhcmFjdGVyIHdoaWNoIGJ1Z2d5IHdlYnNlcnZlcnNcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaGFuZGxlIGNvcnJlY3RseSBzb21ldGltZXMuXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeShjb250ZXh0LnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycywgY29udGV4dC5oZWFkZXJzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkID8gZGVsZXRlIGhlYWRlcnNba2V5XSA6IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRPdmVycmlkZUZuID0gdHlwZW9mIGluaXRPdmVycmlkZXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gaW5pdE92ZXJyaWRlc1xuICAgICAgICAgICAgICAgIDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gaW5pdE92ZXJyaWRlczsgfSk7XG4gICAgICAgICAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBjb250ZXh0LmJvZHksXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY29uZmlndXJhdGlvbi5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZGVuSW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFBhcmFtcyksICh5aWVsZCBpbml0T3ZlcnJpZGVGbih7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRkZW5Jbml0KSwgeyBib2R5OiBpc0Zvcm1EYXRhKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iKG92ZXJyaWRkZW5Jbml0LmJvZHkpXG4gICAgICAgICAgICAgICAgICAgID8gb3ZlcnJpZGRlbkluaXQuYm9keVxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG92ZXJyaWRkZW5Jbml0LmJvZHkpIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsLCBpbml0IH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNsb25lIG9mIGB0aGlzYCBieSBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICAgKiBhbmQgdGhlbiBzaGFsbG93IGNsb25pbmcgZGF0YSBtZW1iZXJzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXcgY29uc3RydWN0b3IodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICAgICAgbmV4dC5taWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbn1cbkJhc2VBUEkuanNvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig6P2FwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig6PzsuKik/JCcsICdpJyk7XG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYjtcbn1cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWVyeXN0cmluZyhwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkoa2V5LCBwYXJhbXNba2V5XSwgcHJlZml4KSlcbiAgICAgICAgLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJyYnKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWUsIGtleVByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZnVsbEtleSA9IGtleVByZWZpeCArIChrZXlQcmVmaXgubGVuZ3RoID8gYFske2tleX1dYCA6IGtleSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgbXVsdGlWYWx1ZSA9IHZhbHVlLm1hcChzaW5nbGVWYWx1ZSA9PiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNpbmdsZVZhbHVlKSkpXG4gICAgICAgICAgICAuam9pbihgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT1gKTtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHttdWx0aVZhbHVlfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUFzQXJyYXkgPSBBcnJheS5mcm9tKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmcodmFsdWUsIGZ1bGxLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKX1gO1xufVxuY2xhc3MgSlNPTkFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcsIHRyYW5zZm9ybWVyID0gKGpzb25WYWx1ZSkgPT4ganNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtZXIoeWllbGQgdGhpcy5yYXcuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2MTAwLjQuM1xuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgRGVmYXVsdEFwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9CbG9ja1VzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9CbG9ja1VzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vYmxvY2tgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVEZXZpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgR3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlR3Vlc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2d1ZXN0YCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIEd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgb25lIGRldmljZVxuICAgICAqIERlbGV0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBkZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG9uZSBkZXZpY2VcbiAgICAgKiBEZWxldGUgZGV2aWNlXG4gICAgICovXG4gICAgZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLmVuZGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBFbmRDYWxsXG4gICAgICogRW5kIGNhbGxcbiAgICAgKi9cbiAgICBlbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGVuZENhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBlbmRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9tYXJrX2VuZGVkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuZW5kZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEVuZENhbGxcbiAgICAgKiBFbmQgY2FsbFxuICAgICAqL1xuICAgIGVuZENhbGwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5lbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIEdldCBDYWxsXG4gICAgICovXG4gICAgZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0Q2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc0xpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ21lbWJlcnNfbGltaXQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLm1lbWJlcnNMaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3JpbmcnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ25vdGlmeSddID0gcmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogR2V0IENhbGxcbiAgICAgKi9cbiAgICBnZXRDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGF2YWlsYWJsZSBmb3IgdmlkZW8gY2FsbHMuXG4gICAgICogR2V0IEVkZ2VzXG4gICAgICovXG4gICAgZ2V0RWRnZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZWRnZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBlZGdlcyBhdmFpbGFibGUgZm9yIHZpZGVvIGNhbGxzLlxuICAgICAqIEdldCBFZGdlc1xuICAgICAqL1xuICAgIGdldEVkZ2VzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRFZGdlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgbmV3IGNhbGwgIFNlbmRzIGV2ZW50czogLSBjYWxsLmNyZWF0ZWQgLSBjYWxsLm5vdGlmaWNhdGlvbiAtIGNhbGwucmluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlQ2FsbCAtIFJlYWRDYWxsIC0gVXBkYXRlQ2FsbFNldHRpbmdzXG4gICAgICogR2V0IG9yIGNyZWF0ZSBhIGNhbGxcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIGNyZWF0ZXMgYSBuZXcgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuY3JlYXRlZCAtIGNhbGwubm90aWZpY2F0aW9uIC0gY2FsbC5yaW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVDYWxsIC0gUmVhZENhbGwgLSBVcGRhdGVDYWxsU2V0dGluZ3NcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEgY2FsbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2FsbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE9yQ3JlYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR29MaXZlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvR29MaXZlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ29MaXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L2dvX2xpdmVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dvTGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3REZXZpY2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5nc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBsaXN0UmVjb3JkaW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGxpc3RSZWNvcmRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9yZWNvcmRpbmdzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5ncyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RSZWNvcmRpbmdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdHJhbnNjcmlwdGlvbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIExpc3RUcmFuc2NyaXB0aW9uc1xuICAgICAqIExpc3QgdHJhbnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBsaXN0VHJhbnNjcmlwdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS90cmFuc2NyaXB0aW9uc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRyYW5zY3JpcHRpb25zICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBMaXN0VHJhbnNjcmlwdGlvbnNcbiAgICAgKiBMaXN0IHRyYW5zY3JpcHRpb25zXG4gICAgICovXG4gICAgbGlzdFRyYW5zY3JpcHRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFRyYW5zY3JpcHRpb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9NdXRlVXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9NdXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbXV0ZV91c2Vyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvTXV0ZVVzZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbHMgd2l0aCBmaWx0ZXIgcXVlcnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogUXVlcnkgY2FsbFxuICAgICAqL1xuICAgIHF1ZXJ5Q2FsbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDYWxscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGxzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGxcbiAgICAgKi9cbiAgICBxdWVyeUNhbGxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlDYWxsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVycyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENhbGxcbiAgICAgKiBRdWVyeSBjYWxsIG1lbWJlcnNcbiAgICAgKi9cbiAgICBxdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBxdWVyeU1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlNZW1iZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVyc1xuICAgICAqL1xuICAgIHF1ZXJ5TWVtYmVycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGN1c3RvbSBldmVudCB0byB0aGUgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEV2ZW50XG4gICAgICogU2VuZCBjdXN0b20gZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1NlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgY3VzdG9tIGV2ZW50IHRvIHRoZSBjYWxsICBTZW5kcyBldmVudHM6IC0gY3VzdG9tICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZW5kRXZlbnRcbiAgICAgKiBTZW5kIGN1c3RvbSBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBITFMgYnJvYWRjYXN0aW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydEJyb2FkY2FzdGluZ1xuICAgICAqIFN0YXJ0IEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdGFydEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0SExTQnJvYWRjYXN0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9zdGFydF9icm9hZGNhc3RpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0QnJvYWRjYXN0aW5nXG4gICAgICogU3RhcnQgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0YXJ0SExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcmVjb3JkaW5nICBTZW5kcyBldmVudHM6IC0gY2FsbC5yZWNvcmRpbmdfc3RhcnRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRSZWNvcmRpbmdcbiAgICAgKiBTdGFydCByZWNvcmRpbmdcbiAgICAgKi9cbiAgICBzdGFydFJlY29yZGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RhcnRfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyByZWNvcmRpbmcgIFNlbmRzIGV2ZW50czogLSBjYWxsLnJlY29yZGluZ19zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFJlY29yZGluZ1xuICAgICAqIFN0YXJ0IHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0YXJ0UmVjb3JkaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJhbnNjcmlwdGlvbiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRUcmFuc2NyaXB0aW9uXG4gICAgICogU3RhcnQgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0YXJ0VHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0YXJ0X3RyYW5zY3JpcHRpb25gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0cmFuc2NyaXB0aW9uICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFRyYW5zY3JpcHRpb25cbiAgICAgKiBTdGFydCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RhcnRUcmFuc2NyaXB0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgSExTIGJyb2FkY2FzdGluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcEJyb2FkY2FzdGluZ1xuICAgICAqIFN0b3AgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0b3BITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BITFNCcm9hZGNhc3RpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfYnJvYWRjYXN0aW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BCcm9hZGNhc3RpbmdcbiAgICAgKiBTdG9wIEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdG9wSExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RvcEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcExpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF9saXZlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wUmVjb3JkaW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdHJhbnNjcmlwdGlvbiAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudHJhbnNjcmlwdGlvbl9zdG9wcGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdG9wVHJhbnNjcmlwdGlvblxuICAgICAqIFN0b3AgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0b3BUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfdHJhbnNjcmlwdGlvbmAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFuc2NyaXB0aW9uICBTZW5kcyBldmVudHM6IC0gY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BUcmFuc2NyaXB0aW9uXG4gICAgICogU3RvcCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RvcFRyYW5zY3JpcHRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wVHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5ibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bmJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91bmJsb2NrYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5ibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBVcGRhdGUgQ2FsbFxuICAgICAqL1xuICAgIHVwZGF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogVXBkYXRlIENhbGxcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubWVtYmVyX2FkZGVkIC0gY2FsbC5tZW1iZXJfcmVtb3ZlZCAtIGNhbGwubWVtYmVyX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlbW92ZUNhbGxNZW1iZXIgLSBVcGRhdGVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlclJvbGVcbiAgICAgKiBVcGRhdGUgQ2FsbCBNZW1iZXJcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsTWVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGxNZW1iZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbE1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbWVtYmVyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLm1lbWJlcl9hZGRlZCAtIGNhbGwubWVtYmVyX3JlbW92ZWQgLSBjYWxsLm1lbWJlcl91cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZW1vdmVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlciAtIFVwZGF0ZUNhbGxNZW1iZXJSb2xlXG4gICAgICogVXBkYXRlIENhbGwgTWVtYmVyXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbE1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBwZXJtaXNzaW9ucyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucGVybWlzc2lvbnNfdXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFBlcm1pc3Npb25zXG4gICAgICogVXBkYXRlIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyUGVybWlzc2lvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZVVzZXJQZXJtaXNzaW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91c2VyX3Blcm1pc3Npb25zYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgcGVybWlzc2lvbnMgIFNlbmRzIGV2ZW50czogLSBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxQZXJtaXNzaW9uc1xuICAgICAqIFVwZGF0ZSB1c2VyIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgdXBkYXRlVXNlclBlcm1pc3Npb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgdG8gdmlkZW8gIFNlbmRzIGV2ZW50czogLSBjb25uZWN0aW9uLm9rIC0gaGVhbHRoLmNoZWNrXG4gICAgICogVmlkZW8gQ29ubmVjdCAoV2ViU29ja2V0KVxuICAgICAqL1xuICAgIHZpZGVvQ29ubmVjdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb0Nvbm5lY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2Nvbm5lY3RgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyIHRvIHZpZGVvICBTZW5kcyBldmVudHM6IC0gY29ubmVjdGlvbi5vayAtIGhlYWx0aC5jaGVja1xuICAgICAqIFZpZGVvIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICB2aWRlb0Nvbm5lY3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmlkZW9Db25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9QaW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9QaW5SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9QaW5SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9waW5gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1BpblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9VbnBpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvVW5waW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VucGluUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1VucGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3VucGluYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1VucGluUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXJ2ZXJTaWRlQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tFeHRlcm5hbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlL3tuYW1lfS9jaGVja2AucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja0V4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlbGV0ZSBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBkZWxldGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVsZXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldCBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBnZXRDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IENhbGwgVHlwZVxuICAgICAqL1xuICAgIGdldENhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXR0aW5nc0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBDcmVhdGUgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGNyZWF0ZUV4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIENyZWF0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogRGVsZXRlIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBkZWxldGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIERlbGV0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIExpc3QgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGxpc3RFeHRlcm5hbFN0b3JhZ2VSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBMaXN0IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBsaXN0RXh0ZXJuYWxTdG9yYWdlKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RXh0ZXJuYWxTdG9yYWdlUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtQ2FsbCB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmJsb2NrVXNlciA9ICh2aWRlb0Jsb2NrVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5ibG9ja1VzZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0Jsb2NrVXNlclJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZENhbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuZW5kQ2FsbChPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRDYWxsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPckNyZWF0ZSA9ICh2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRPckNyZWF0ZUNhbGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3Q6IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCAhPT0gbnVsbCAmJiB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgIT09IHZvaWQgMCA/IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA6IHt9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSAoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JDcmVhdGUoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29MaXZlID0gKHZpZGVvR29MaXZlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmdvTGl2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvR29MaXZlUmVxdWVzdDogdmlkZW9Hb0xpdmVSZXF1ZXN0ICE9PSBudWxsICYmIHZpZGVvR29MaXZlUmVxdWVzdCAhPT0gdm9pZCAwID8gdmlkZW9Hb0xpdmVSZXF1ZXN0IDoge30gfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RSZWNvcmRpbmdzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50Lmxpc3RSZWNvcmRpbmdzKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0VHJhbnNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubGlzdFRyYW5zY3JpcHRpb25zKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlVXNlcnMgPSAodmlkZW9NdXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubXV0ZVVzZXJzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9NdXRlVXNlcnNSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgdmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSkpLCB0aGlzLmJhc2VSZXF1ZXN0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnNlbmRFdmVudChPYmplY3QuYXNzaWduKHsgdmlkZW9TZW5kRXZlbnRSZXF1ZXN0OiB7IGN1c3RvbTogZXZlbnQgfSB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5zdGFydFJlY29yZGluZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uID0gKHZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wSExTQnJvYWRjYXN0aW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BMaXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BMaXZlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BSZWNvcmRpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BUcmFuc2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmJsb2NrVXNlciA9ICh2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVuYmxvY2tVc2VyKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHZpZGVvVXBkYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC51cGRhdGVDYWxsKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsTWVtYmVycyA9ICh2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNhbGxNZW1iZXJzKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zID0gKHZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyhPYmplY3QuYXNzaWduKHsgdmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waW5WaWRlbyA9ICh2aWRlb1BpblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC52aWRlb1BpbihPYmplY3QuYXNzaWduKHsgdmlkZW9QaW5SZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnBpblZpZGVvID0gKHZpZGVvVW5waW5SZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudmlkZW9VbnBpbihPYmplY3QuYXNzaWduKHsgdmlkZW9VbnBpblJlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhc2VSZXF1ZXN0ID0geyBpZDogdGhpcy5pZCwgdHlwZTogdGhpcy50eXBlIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCd2aWRlbycpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBEZWZhdWx0QXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtVmlkZW9DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy5jYWxsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUNhbGwodGhpcy5zdHJlYW1DbGllbnQsIHR5cGUsIGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeUNhbGxzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5xdWVyeUNhbGxzKHtcbiAgICAgICAgICAgICAgICB2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxUeXBlID0gKHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQuY3JlYXRlQ2FsbFR5cGUoe1xuICAgICAgICAgICAgICAgIHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FsbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmRlbGV0ZUNhbGxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC5nZXRDYWxsVHlwZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Q2FsbFR5cGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50Lmxpc3RDYWxsVHlwZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsVHlwZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LnVwZGF0ZUNhbGxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEV4dGVybmFsU3RvcmFnZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0RXh0ZXJuYWxTdG9yYWdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlID0gKHZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHtcbiAgICAgICAgICAgICAgICB2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC51cGRhdGVFeHRlcm5hbFN0b3JhZ2Uoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmNoZWNrRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5zdHJlYW1DbGllbnQuZ2V0Q29uZmlndXJhdGlvbigndmlkZW8nKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgRGVmYXVsdEFwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0FwaSA9IG5ldyBTZXR0aW5nc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQgPSBuZXcgU2VydmVyU2lkZUFwaShjb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEpXVFVzZXJUb2tlbihhcGlTZWNyZXQsIHVzZXJJZCwgZXh0cmFEYXRhID0ge30sIGp3dE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2VySWQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgdXNlcl9pZDogdXNlcklkIH0sIGV4dHJhRGF0YSk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIGNsZWFyIGVycm9yIHdoZW4gand0IGlzIHNoaW1tZWQgKGllLiBicm93c2VyIGJ1aWxkKVxuICAgIGlmIChqd3QgPT0gbnVsbCB8fCBqd3Quc2lnbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBqd3QgY3J5cHRvLCBpZiB5b3UgYXJlIGdldHRpbmcgdGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIHRva2VucyBvbiBicm93c2VyIG9yIFJlYWN0IE5hdGl2ZSAob3Igb3RoZXIgZW52aXJvbm1lbnQgd2hlcmUgY3J5cHRvIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSkuIFBsZWFzZSBOb3RlOiB0b2tlbiBzaG91bGQgb25seSBiZSBnZW5lcmF0ZWQgc2VydmVyLXNpZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgYWxnb3JpdGhtOiAnSFMyNTYnLCBub1RpbWVzdGFtcDogdHJ1ZSB9LCBqd3RPcHRpb25zKTtcbiAgICBpZiAocGF5bG9hZC5pYXQpIHtcbiAgICAgICAgb3B0cy5ub1RpbWVzdGFtcCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgYXBpU2VjcmV0LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIEpXVFNlcnZlclRva2VuKGFwaVNlY3JldCwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuXG5jbGFzcyBTdHJlYW1DbGllbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwaUtleVxuICAgICAqIEBwYXJhbSBzZWNyZXRcbiAgICAgKiBAcGFyYW0gY29uZmlnIGNhbiBiZSBhIHN0cmluZywgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlIHBhdGggKGRlcHJlY2F0ZWQpLCBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIHNlY3JldCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY3JlYXRlRGV2aWNlID0gKGNyZWF0ZURldmljZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuY3JlYXRlRGV2aWNlKHsgY3JlYXRlRGV2aWNlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVEZXZpY2UgPSAocmVxdWVzdFBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0RGV2aWNlcyA9IChyZXF1ZXN0UGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlc0FwaS5saXN0RGV2aWNlcyhyZXF1ZXN0UGFyYW1ldGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdFB1c2hQcm92aWRlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoQXBpLmxpc3RQdXNoUHJvdmlkZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hBcGkuZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwc2VydFB1c2hQcm92aWRlciA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzaWRlQXBpLnVwc2VydFB1c2hQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgdXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdDogeyBwdXNoX3Byb3ZpZGVyOiByZXF1ZXN0IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGVja1B1c2ggPSAoY2hlY2tQdXNoUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdGluZ0FwaS5jaGVja1B1c2goeyBjaGVja1B1c2hSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUd1ZXN0ID0gKGd1ZXN0UmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZ3Vlc3RSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGd1ZXN0UmVxdWVzdC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5jcmVhdGVHdWVzdCh7IGd1ZXN0UmVxdWVzdCB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UudXNlcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhblVzZXIgPSAoYmFuUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgYmFuUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChiYW5SZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgYmFuUmVxdWVzdC5iYW5uZWRfYnkgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGJhblJlcXVlc3QuYmFubmVkX2J5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmJhbih7IGJhblJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZVVzZXIgPSAoZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXIoe1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGRlYWN0aXZhdGVVc2VyUmVxdWVzdC51c2VyX2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlVXNlcnMgPSAoZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXJzKHsgZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZGVsZXRlVXNlcnNgIGluc3RlYWRcbiAgICAgICAgICogQHBhcmFtIGRlbGV0ZVVzZXJzUmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVVc2VyID0gKHJlcXVlc3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5kZWxldGVVc2VyKHJlcXVlc3QpO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsZXRlVXNlcnMgPSAoZGVsZXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5kZWxldGVVc2Vycyh7IGRlbGV0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRVc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmV4cG9ydFVzZXIocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXhwb3J0VXNlcnMgPSAoZXhwb3J0VXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5leHBvcnRVc2Vycyh7IGV4cG9ydFVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mbGFnID0gKGZsYWdSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgZmxhZ1JlcXVlc3QudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQoZmxhZ1JlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfYiA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKChfYyA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlCYW5uZWRVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlCYW5uZWRVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5iYW5zLmZvckVhY2goKGIpID0+IHtcbiAgICAgICAgICAgICAgICBiLmJhbm5lZF9ieSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShiLmJhbm5lZF9ieSk7XG4gICAgICAgICAgICAgICAgYi51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKGIudXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlcnMgPSByZXNwb25zZS51c2Vycy5tYXAoKHUpID0+IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZSh1KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWN0aXZhdGVVc2VyID0gKHJlYWN0aXZhdGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2VyKHtcbiAgICAgICAgICAgICAgICByZWFjdGl2YXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdXNlcklkOiByZWFjdGl2YXRlVXNlclJlcXVlc3QudXNlcl9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhY3RpdmF0ZVVzZXJzID0gKHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2Vycyh7IHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzdG9yZVVzZXJzID0gKHJlc3RvcmVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlc3RvcmVVc2Vycyh7IHJlc3RvcmVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5iYW5Vc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnVuYmFuKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuZmxhZyA9IChmbGFnUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfZCA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLmZsYWcudXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwc2VydFVzZXJzID0gKHVwZGF0ZVVzZXJzUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVVc2Vyc1JlcXVlc3QudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQodXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkudXBkYXRlVXNlcnMoeyB1cGRhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXNwb25zZS51c2VycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2Vyc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVVc2Vyc1BhcnRpYWwgPSAocmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVwZGF0ZVVzZXJzUGFydGlhbCh7XG4gICAgICAgICAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB1cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS51c2Vyc1trZXldID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11dGVVc2VyID0gKG11dGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9lLCBfZjtcbiAgICAgICAgICAgIG11dGVVc2VyUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChtdXRlVXNlclJlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkubXV0ZVVzZXIoeyBtdXRlVXNlclJlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoKF9lID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tdXRlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUoKF9mID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm11dGVzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UubXV0ZXMgPSByZXNwb25zZS5tdXRlcy5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdXNlcjogdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKG0udXNlcikgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVubXV0ZVVzZXIgPSAodW5tdXRlVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkudW5tdXRlVXNlcih7IHVubXV0ZVVzZXJSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudFRvVXNlciA9ICh1c2VySWQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZFVzZXJDdXN0b21FdmVudCh7XG4gICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0OiB7IGV2ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVSb2xlID0gKGNyZWF0ZVJvbGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5jcmVhdGVSb2xlKHsgY3JlYXRlUm9sZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUm9sZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5kZWxldGVSb2xlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFBlcm1pc3Npb24gPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVybWlzc2lvbnNBcGkuZ2V0UGVybWlzc2lvbihyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0UGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0UGVybWlzc2lvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Um9sZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0Um9sZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRBcHBTZXR0aW5ncyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldEFwcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUFwcFNldHRpbmdzID0gKHVwZGF0ZUFwcFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUFwcCh7IHVwZGF0ZUFwcFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmF0ZUxpbWl0cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldFJhdGVMaW1pdHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYXNrU3RhdHVzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhc2tzQXBpLmdldFRhc2socmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmVyaWZ5V2ViaG9vayA9IChyZXF1ZXN0Qm9keSwgeFNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20odGhpcy5zZWNyZXQsICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvXG4gICAgICAgICAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChCdWZmZXIuZnJvbShoYXNoKSwgQnVmZmVyLmZyb20oeFNpZ25hdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb25maWd1cmF0aW9uID0gKHByb2R1Y3QgPSAnY2hhdCcpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1N0cmVhbS1BdXRoLVR5cGUnOiAnand0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbbmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogKF9hID0gdGhpcy5vcHRpb25zLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocHJvZHVjdCA9PT0gJ2NoYXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbSdcbiAgICAgICAgICAgICAgICAgICAgOiAnaHR0cHM6Ly92aWRlby5zdHJlYW0taW8tYXBpLmNvbScpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1gtU3RyZWFtLUNsaWVudCc6ICdzdHJlYW0tbm9kZS0nICsgXCIwLjEuMTNcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5pdC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmluaXQuaGVhZGVycyksIHsgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiB2NCgpLCAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgbGFzdCBwb3N0IG1pZGRsZXdhcmUgYmVjYXVzZSB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBGZXRjaCBBUEkgd29uJ3QgdGhyb3cgYW4gZXJyb3IgZm9yIEhUVFAgZXJyb3IgcmVzcG9uc2VzLCB3aGljaCBtZWFucyB0aGUgXCJvbkVycm9yXCIgbWlkZGxld2FyZSB3b24ndCBiZSBjYWxsZWQgc28gd2UgbmVlZCB0byB0aHJvdyBlcnJvciBmcm9tIFwicG9zdFwiIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q6IChjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZXh0LnJlc3BvbnNlICYmIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzIDwgMjAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgSlNPTkFwaVJlc3BvbnNlKGNvbnRleHQucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICh5aWVsZCByZXNwb25zZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW0gZXJyb3IgY29kZSAke3ZhbHVlLmNvZGV9OiAke3ZhbHVlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZTogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmluaXQuc2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dCh0aGlzLm9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY29udGV4dC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKGVycm9yLCBgVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQgZHVlIHRvIHRvIHRoZSAke3RoaXMub3B0aW9ucy50aW1lb3V0fW1zIHRpbWVvdXQsIHlvdSBjYW4gc2V0IHRoZSB0aW1lb3V0IGluIHRoZSBTdHJlYW1DbGllbnQgY29uc3RydWN0b3JgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT3BlbkFQSVRvb2xzL29wZW5hcGktZ2VuZXJhdG9yL2lzc3Vlcy8xMzIyMlxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zU3RyaW5naWZ5OiAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNba10pIHx8IHR5cGVvZiBwYXJhbXNba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2goYCR7a309JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tdKSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKGAke2t9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2VydmVkS2V5d29yZHMgPSBbXG4gICAgICAgICAgICAnYmFuX2V4cGlyZXMnLFxuICAgICAgICAgICAgJ2Jhbm5lZCcsXG4gICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgJ2ludmlzaWJsZScsXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnLFxuICAgICAgICAgICAgJ3B1c2hfbm90aWZpY2F0aW9ucycsXG4gICAgICAgICAgICAncmV2b2tlX3Rva2Vuc19pc3N1ZWRfYmVmb3JlJyxcbiAgICAgICAgICAgICdyb2xlJyxcbiAgICAgICAgICAgICd0ZWFtcycsXG4gICAgICAgICAgICAnY3JlYXRlZF9hdCcsXG4gICAgICAgICAgICAnZGVhY3RpdmF0ZWRfYXQnLFxuICAgICAgICAgICAgJ2RlbGV0ZWRfYXQnLFxuICAgICAgICAgICAgJ2xhc3RfYWN0aXZlJyxcbiAgICAgICAgICAgICdvbmxpbmUnLFxuICAgICAgICAgICAgJ3VwZGF0ZWRfYXQnLFxuICAgICAgICAgICAgJ3NoYWRvd19iYW5uZWQnLFxuICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZCA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIHVzZXIpO1xuICAgICAgICAgICAgZGVsZXRlIGNvcHkuY3VzdG9tO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weSksIHVzZXIuY3VzdG9tKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbiA9IEpXVFNlcnZlclRva2VuKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFzZVBhdGggPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGltZW91dCA9IFN0cmVhbUNsaWVudC5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXQgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZGVvID0gbmV3IFN0cmVhbVZpZGVvQ2xpZW50KHRoaXMpO1xuICAgICAgICB0aGlzLmNoYXQgPSBuZXcgU3RyZWFtQ2hhdENsaWVudCh0aGlzKTtcbiAgICAgICAgY29uc3QgY2hhdENvbmZpZ3VyYXRpb24gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy51c2Vyc0FwaSA9IG5ldyBVc2Vyc0FwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuZGV2aWNlc0FwaSA9IG5ldyBEZXZpY2VzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5wdXNoQXBpID0gbmV3IFB1c2hBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNlcnZlcnNpZGVBcGkgPSBuZXcgU2VydmVyU2lkZUFwaSQxKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy50ZXN0aW5nQXBpID0gbmV3IFRlc3RpbmdBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zQXBpID0gbmV3IFBlcm1pc3Npb25zVjJBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzQXBpID0gbmV3IFNldHRpbmdzQXBpJDEoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmV2ZW50c0FwaSA9IG5ldyBFdmVudHNBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnRhc2tzQXBpID0gbmV3IFRhc2tzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcklEXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgZGVwcmVjYXRlZCwgdGhlIGRlZmF1bHQgZGF0ZSB3aWxsIGJlIHNldCBpbnRlcm5hbGx5XG4gICAgICogQHBhcmFtIGNhbGxfY2lkcyB0aGlzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHVzZSBgY3JlYXRlQ2FsbFRva2VuYCBmb3IgY2FsbCB0b2tlbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCksIGNhbGxfY2lkcykge1xuICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlhdCkge1xuICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsX2NpZHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNlIGNyZWF0ZUNhbGxUb2tlbiBtZXRob2QgZm9yIGNyZWF0aW5nIGNhbGwgdG9rZW5zLCB0aGUgXCJjYWxsX2NpZHNcIiBwYXJhbSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3JlYXRlVG9rZW4gbWV0aG9kIHdpdGggdmVyc2lvbiAwLjIuMGApO1xuICAgICAgICAgICAgZXh0cmEuY2FsbF9jaWRzID0gY2FsbF9jaWRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySURcbiAgICAgKiBAcGFyYW0gY2FsbF9jaWRzXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgdGhpcyBpcyBkZXByZWNhdGVkLCB0aGUgY3VycmVudCBkYXRlIHdpbGwgYmUgc2V0IGludGVybmFsbHlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUb2tlbih1c2VySUQsIGNhbGxfY2lkcywgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgZXh0cmEuZXhwID0gZXhwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpYXQpIHtcbiAgICAgICAgICAgIGV4dHJhLmlhdCA9IGlhdDtcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jYWxsX2NpZHMgPSBjYWxsX2NpZHM7XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICBtYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHVzZXIpIHtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1c2VyKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNlcnZlZEtleXdvcmRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5jdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN1c3RvbSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuY3VzdG9tW2tleV0gPSB1c2VyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHVzZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVCA9IDMwMDA7XG5cbmV4cG9ydCB7IEFQTkNvbmZpZ1JlcXVlc3RBdXRoVHlwZUVudW0sIEFwcFNlYXJjaEJhY2tlbmRFbnVtLCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSwgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtLCBCbG9ja0xpc3RPcHRpb25zQmVoYXZpb3JFbnVtLCBCbG9ja0xpc3RPcHRpb25zUmVxdWVzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdBdXRvbW9kRW51bSwgQ2hhbm5lbENvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QXV0b21vZEVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0sIENoYW5uZWxNZW1iZXJSb2xlRW51bSwgQ2hhbm5lbFR5cGVDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hlY2tQdXNoUmVxdWVzdFB1c2hQcm92aWRlclR5cGVFbnVtLCBDaGVja1NOU1Jlc3BvbnNlU3RhdHVzRW51bSwgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0sIENvbmZpZ0RlZmF1bHRSb2xlRW51bSwgQ29uZmlnUmVxdWVzdERlZmF1bHRSb2xlRW51bSwgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0sIENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0sIERlbGV0ZVVzZXJzUmVxdWVzdE1lc3NhZ2VzRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0sIERldmljZUZpZWxkc1B1c2hQcm92aWRlckVudW0sIERldmljZVB1c2hQcm92aWRlckVudW0sIERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtLCBJbWFnZVNpemVDcm9wRW51bSwgSW1hZ2VTaXplUmVzaXplRW51bSwgTGF5b3V0U2V0dGluZ3NOYW1lRW51bSwgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0sIE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0sIE1lc3NhZ2VUeXBlRW51bSwgUGVybWlzc2lvbkxldmVsRW51bSwgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtLCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSwgUHVzaENvbmZpZ1JlcXVlc3RWZXJzaW9uRW51bSwgU3RyZWFtQ2FsbCwgU3RyZWFtQ2hhbm5lbCwgU3RyZWFtQ2hhdENsaWVudCwgU3RyZWFtQ2xpZW50LCBTdHJlYW1WaWRlb0NsaWVudCwgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0sIFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtLCBVcGRhdGVBcHBSZXF1ZXN0RW5mb3JjZVVuaXF1ZVVzZXJuYW1lc0VudW0sIFVwZGF0ZUFwcFJlcXVlc3RQZXJtaXNzaW9uVmVyc2lvbkVudW0sIFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSwgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgVmlkZW9MYXlvdXRTZXR0aW5nc05hbWVFbnVtLCBWaWRlb0xheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtLCBWaWRlb093bkNhcGFiaWxpdHksIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0sIFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/@stream-io+node-sdk@0.1.13/node_modules/@stream-io/node-sdk/dist/index.es.js\n");

/***/ })

};
;