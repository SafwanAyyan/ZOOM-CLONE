"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!**************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \**************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/.pnpm/@floating-ui+dom@1.6.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/.pnpm/@floating-ui+react-dom@2.0.9_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@14.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\n\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n    if (true) {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (true) {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      return firstCellIndex + sizes[index].width - 1;\n    case 'bl':\n      return firstCellIndex + (sizes[index].height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nvar index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(props) {\n  const {\n    children,\n    elementsRef,\n    labelsRef\n  } = props;\n  const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new Map());\n  const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    label\n  } = props;\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n  const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that aren’t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(props, forwardedRef) {\n  const {\n    render,\n    orientation = 'both',\n    loop = true,\n    cols = 1,\n    disabledIndices = [],\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    itemSizes,\n    dense = false,\n    ...domProps\n  } = props;\n  const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n      nextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')\n      })]; // navigated cell will never be nullish\n    }\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      domProps.onKeyDown == null || domProps.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(props, forwardedRef) {\n  const {\n    render,\n    ...domProps\n  } = props;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      domProps.onFocus == null || domProps.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => // Ensure the id is unique with multiple independent versions of Floating UI\n// on <React 18\n\"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    serverHandoffComplete = true;\n  }, []);\n  return id;\n}\nconst useReactId = SafeReact.useId;\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\nlet devMessageSet;\nif (true) {\n  devMessageSet = /*#__PURE__*/new Set();\n}\nfunction warn() {\n  var _devMessageSet;\n  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n    messages[_key] = arguments[_key];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n    console.warn(message);\n  }\n}\nfunction error() {\n  var _devMessageSet3;\n  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    messages[_key2] = arguments[_key2];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n    console.error(message);\n  }\n}\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(props, ref) {\n  const {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = props;\n  if (true) {\n    if (!ref) {\n      warn('The `ref` prop is required for `FloatingArrow`.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  const computedStrokeWidth = strokeWidth * 2;\n  const halfStrokeWidth = computedStrokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + computedStrokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), computedStrokeWidth > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: computedStrokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + computedStrokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(props) {\n  const {\n    children,\n    id\n  } = props;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(props) {\n  const {\n    children\n  } = props;\n  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});\n  const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = window.setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          function handleMouseMove() {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }\n          if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current)) {\n            return;\n          }\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          if (pointerTypeRef.current === 'touch') {\n            handleMouseMove();\n          } else {\n            restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);\n          }\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, mouseOnly, open, restMs, onOpenChange, closeWithDelay]);\n}\n\nconst NOOP = () => {};\nconst FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: NOOP,\n  setState: NOOP,\n  isInstantPhase: false\n});\n\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */\nconst useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction FloatingDelayGroup(props) {\n  const {\n    children,\n    delay,\n    timeoutMs = 0\n  } = props;\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction useDelayGroup(context, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    floatingId\n  } = context;\n  const {\n    id: optionId\n  } = options;\n  const id = optionId != null ? optionId : floatingId;\n  const groupContext = useDelayGroupContext();\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = groupContext;\n  index(() => {\n    if (!currentId) return;\n    setState({\n      delay: {\n        open: 1,\n        close: getDelay(initialDelay, 'close')\n      }\n    });\n    if (currentId !== id) {\n      onOpenChange(false);\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!currentId) return;\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (setCurrentId === NOOP || !open) return;\n    setCurrentId(id);\n  }, [open, setCurrentId, id]);\n  return groupContext;\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  index(() => {\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    id,\n    root\n  } = props;\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(props) {\n  const {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = props;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  let tabbableEl = element;\n  if (!tabbableEl || (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getNodeName)(tabbableEl) === 'body') return;\n  if (!(0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(tabbableEl, getTabbableOptions())) {\n    const tabbableChild = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(tabbableEl, getTabbableOptions())[0];\n    if (tabbableChild) {\n      tabbableEl = tabbableChild;\n    }\n  }\n  previouslyFocusedElements.push(tabbableEl);\n  if (previouslyFocusedElements.length > LIST_LIMIT) {\n    previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        }\n        const els = getTabbableElements();\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n    const contextData = dataRef.current;\n    let openEvent = contextData.openEvent;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        open,\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (open) {\n        openEvent = event;\n      }\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n      const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored — leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst activeLocks = /*#__PURE__*/new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(props, ref) {\n  const {\n    lockScroll = false,\n    ...rest\n  } = props;\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getPlatform)());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType) ? floating : open;\n  const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getWindow)(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isReactEvent)(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target) ? target : null;\n    while (targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isLastTraversableNode)(targetRootAncestor)) {\n      const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getParentNode)(targetRootAncestor);\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isRootElement)(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getComputedStyle)(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(domReference)) {\n        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(domReference);\n      }\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(floating)) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(floating));\n      }\n      if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getOverflowAncestors)(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const [positionReference, _setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const optionDomReference = (_options$elements = options.elements) == null ? void 0 : _options$elements.reference;\n  const domReference = optionDomReference || _domReference;\n  if (true) {\n    if (optionDomReference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(optionDomReference)) {\n      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');\n    }\n  }\n  index(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)({\n    ...options,\n    elements: {\n      ...options.elements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    dataRef.current.openEvent = open ? event : undefined;\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    const computedPositionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    _setPositionReference(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.getWindow)(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [domReference, open, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event.nativeEvent);\n          if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            // We can not rely on relatedTarget to point to the correct element\n            // as it will only point to the shadow host of the newly focused element\n            // and not the element that actually has received focus if it is located\n            // inside a shadow root.\n            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, activeEl) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\n\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (true) {\n    if (allowEscape) {\n      if (!loop) {\n        warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n  const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n  const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n        indexRef.current = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl'),\n          stopEvent: true\n        })]; // navigated cell will never be nullish\n\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp),\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined,\n        ...(ariaRole === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(ariaRole === 'menu' && {\n          id: referenceId\n        }),\n        ...(ariaRole === 'menu' && isNested && {\n          role: 'menuitem'\n        }),\n        ...(role === 'select' && {\n          'aria-autocomplete': 'none'\n        }),\n        ...(role === 'combobox' && {\n          'aria-autocomplete': 'list'\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(ariaRole === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      },\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = {\n          role: 'option',\n          ...(active && {\n            id: floatingId + \"-option\"\n          })\n        };\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return {\n              ...commonProps,\n              'aria-selected': active && selected\n            };\n          case 'combobox':\n            {\n              return {\n                ...commonProps,\n                ...(active && {\n                  'aria-selected': true\n                })\n              };\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setInitiated(true);\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\n  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (true) {\n      if (!state.placement.startsWith('bottom')) {\n        warn('`placement` side must be \"bottom\" when using the `inner`', 'middleware.');\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onFallbackChange(true));\n      } else {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getUserAgent)())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync)(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, target);\n      const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK3JlYWN0QDAuMjYuMTNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUM0QjtBQUMrTztBQUMvUDtBQUNtRjtBQUNrRTtBQUM5QztBQUNsRztBQUNJOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUsseUxBQUs7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUFZO0FBQzFCLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsOENBQWlCO0FBQzFCLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QjtBQUNBLCtCQUErQixrRUFBUTtBQUN2QyxnQ0FBZ0Msa0VBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixpRUFBUyx5QkFBeUIsa0VBQVE7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b29tLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmbG9hdGluZy11aStyZWFjdEAwLjI2LjEzX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0Lm1qcz82NmYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdG9wRXZlbnQsIGdldERvY3VtZW50LCBpc01vdXNlTGlrZVBvaW50ZXJUeXBlLCBjb250YWlucywgYWN0aXZlRWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNWaXJ0dWFsQ2xpY2ssIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgZ2V0VGFyZ2V0LCBnZXRQbGF0Zm9ybSwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNNYWMsIGdldFVzZXJBZ2VudCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC91dGlscyc7XG5pbXBvcnQgeyBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBwbGF0Zm9ybSwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHVzZUZsb2F0aW5nIGFzIHVzZUZsb2F0aW5nJDEsIG9mZnNldCwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBnZXROb2RlTmFtZSwgZ2V0V2luZG93LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGdldFBhcmVudE5vZGUsIGdldENvbXB1dGVkU3R5bGUgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmltcG9ydCB7IHRhYmJhYmxlLCBpc1RhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiByZWZzIGludG8gYSBzaW5nbGUgbWVtb2l6ZWQgY2FsbGJhY2sgcmVmIG9yIGBudWxsYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdC11dGlscyN1c2VtZXJnZXJlZnNcbiAqL1xuZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWZzLmV2ZXJ5KHJlZiA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT4ge1xuICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCByZWZzKTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9pc3N1ZXMvNDExOTAjaXNzdWVjb21tZW50LTIwNDA4NzMzNzlcbmNvbnN0IFNhZmVSZWFjdCA9IHtcbiAgLi4uUmVhY3Rcbn07XG5cbmNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IFNhZmVSZWFjdC51c2VJbnNlcnRpb25FZmZlY3Q7XG5jb25zdCB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0ID0gdXNlSW5zZXJ0aW9uRWZmZWN0IHx8IChmbiA9PiBmbigpKTtcbmZ1bmN0aW9uIHVzZUVmZmVjdEV2ZW50KGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBhbiBldmVudCBoYW5kbGVyIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICB9XG4gIH0pO1xuICB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogcmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gIH0sIFtdKTtcbn1cblxuY29uc3QgQVJST1dfVVAgPSAnQXJyb3dVcCc7XG5jb25zdCBBUlJPV19ET1dOID0gJ0Fycm93RG93bic7XG5jb25zdCBBUlJPV19MRUZUID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVCA9ICdBcnJvd1JpZ2h0JztcbmZ1bmN0aW9uIGlzRGlmZmVyZW50Um93KGluZGV4LCBjb2xzLCBwcmV2Um93KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGluZGV4IC8gY29scykgIT09IHByZXZSb3c7XG59XG5mdW5jdGlvbiBpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4IDwgMCB8fCBpbmRleCA+PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoO1xufVxuZnVuY3Rpb24gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgZGVjcmVtZW50OiB0cnVlLFxuICAgIHN0YXJ0aW5nSW5kZXg6IGxpc3RSZWYuY3VycmVudC5sZW5ndGgsXG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuZnVuY3Rpb24gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBzdGFydGluZ0luZGV4ID0gLTEsXG4gICAgZGVjcmVtZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgIGFtb3VudCA9IDFcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBsaXN0ID0gbGlzdFJlZi5jdXJyZW50O1xuICBjb25zdCBpc0Rpc2FibGVkSW5kZXggPSBkaXNhYmxlZEluZGljZXMgPyBpbmRleCA9PiBkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpIDogaW5kZXggPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBsaXN0W2luZGV4XTtcbiAgICByZXR1cm4gZWxlbWVudCA9PSBudWxsIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJztcbiAgfTtcbiAgbGV0IGluZGV4ID0gc3RhcnRpbmdJbmRleDtcbiAgZG8ge1xuICAgIGluZGV4ICs9IGRlY3JlbWVudCA/IC1hbW91bnQgOiBhbW91bnQ7XG4gIH0gd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPD0gbGlzdC5sZW5ndGggLSAxICYmIGlzRGlzYWJsZWRJbmRleChpbmRleCkpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBnZXRHcmlkTmF2aWdhdGVkSW5kZXgoZWxlbWVudHNSZWYsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBldmVudCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBsb29wLFxuICAgIGNvbHMsXG4gICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgIG1pbkluZGV4LFxuICAgIG1heEluZGV4LFxuICAgIHByZXZJbmRleCxcbiAgICBzdG9wRXZlbnQ6IHN0b3AgPSBmYWxzZVxuICB9ID0gX3JlZjtcbiAgbGV0IG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfVVApIHtcbiAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICBzdGFydGluZ0luZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgKHByZXZJbmRleCAtIGNvbHMgPCBtaW5JbmRleCB8fCBuZXh0SW5kZXggPCAwKSkge1xuICAgICAgICBjb25zdCBjb2wgPSBwcmV2SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBtYXhDb2wgPSBtYXhJbmRleCAlIGNvbHM7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1heEluZGV4IC0gKG1heENvbCAtIGNvbCk7XG4gICAgICAgIGlmIChtYXhDb2wgPT09IGNvbCkge1xuICAgICAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRJbmRleCA9IG1heENvbCA+IGNvbCA/IG9mZnNldCA6IG9mZnNldCAtIGNvbHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19ET1dOKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgfSk7XG4gICAgICBpZiAobG9vcCAmJiBwcmV2SW5kZXggKyBjb2xzID4gbWF4SW5kZXgpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggJSBjb2xzIC0gY29scyxcbiAgICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtYWlucyBvbiB0aGUgc2FtZSByb3cvY29sdW1uLlxuICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgIGNvbnN0IHByZXZSb3cgPSBmbG9vcihwcmV2SW5kZXggLyBjb2xzKTtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCkge1xuICAgICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IGNvbHMgLSAxKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0xFRlQpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSAwKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSb3cgPSBmbG9vcihtYXhJbmRleCAvIGNvbHMpID09PSBwcmV2Um93O1xuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGlmIChsb29wICYmIGxhc3RSb3cpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZXZlbnQua2V5ID09PSBBUlJPV19MRUZUID8gbWF4SW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRJbmRleDtcbn1cblxuLyoqIEZvciBlYWNoIGNlbGwgaW5kZXgsIGdldHMgdGhlIGl0ZW0gaW5kZXggdGhhdCBvY2N1cGllcyB0aGF0IGNlbGwgKi9cbmZ1bmN0aW9uIGJ1aWxkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpIHtcbiAgY29uc3QgY2VsbE1hcCA9IFtdO1xuICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gIHNpemVzLmZvckVhY2goKF9yZWYyLCBpbmRleCkgPT4ge1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAod2lkdGggPiBjb2xzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltGbG9hdGluZyBVSV06IEludmFsaWQgZ3JpZCAtIGl0ZW0gd2lkdGggYXQgaW5kZXggXCIgKyBpbmRleCArIFwiIGlzIGdyZWF0ZXIgdGhhbiBncmlkIGNvbHVtbnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpdGVtUGxhY2VkID0gZmFsc2U7XG4gICAgaWYgKGRlbnNlKSB7XG4gICAgICBzdGFydEluZGV4ID0gMDtcbiAgICB9XG4gICAgd2hpbGUgKCFpdGVtUGxhY2VkKSB7XG4gICAgICBjb25zdCB0YXJnZXRDZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICB0YXJnZXRDZWxscy5wdXNoKHN0YXJ0SW5kZXggKyBpICsgaiAqIGNvbHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRJbmRleCAlIGNvbHMgKyB3aWR0aCA8PSBjb2xzICYmIHRhcmdldENlbGxzLmV2ZXJ5KGNlbGwgPT4gY2VsbE1hcFtjZWxsXSA9PSBudWxsKSkge1xuICAgICAgICB0YXJnZXRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIGNlbGxNYXBbY2VsbF0gPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1QbGFjZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gY29udmVydCBpbnRvIGEgbm9uLXNwYXJzZSBhcnJheVxuICByZXR1cm4gWy4uLmNlbGxNYXBdO1xufVxuXG4vKiogR2V0cyBjZWxsIGluZGV4IG9mIGFuIGl0ZW0ncyBjb3JuZXIgb3IgLTEgd2hlbiBpbmRleCBpcyAtMS4gKi9cbmZ1bmN0aW9uIGdldENlbGxJbmRleE9mQ29ybmVyKGluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scywgY29ybmVyKSB7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAtMTtcbiAgY29uc3QgZmlyc3RDZWxsSW5kZXggPSBjZWxsTWFwLmluZGV4T2YoaW5kZXgpO1xuICBzd2l0Y2ggKGNvcm5lcikge1xuICAgIGNhc2UgJ3RsJzpcbiAgICAgIHJldHVybiBmaXJzdENlbGxJbmRleDtcbiAgICBjYXNlICd0cic6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyBzaXplc1tpbmRleF0ud2lkdGggLSAxO1xuICAgIGNhc2UgJ2JsJzpcbiAgICAgIHJldHVybiBmaXJzdENlbGxJbmRleCArIChzaXplc1tpbmRleF0uaGVpZ2h0IC0gMSkgKiBjb2xzO1xuICAgIGNhc2UgJ2JyJzpcbiAgICAgIHJldHVybiBjZWxsTWFwLmxhc3RJbmRleE9mKGluZGV4KTtcbiAgfVxufVxuXG4vKiogR2V0cyBhbGwgY2VsbCBpbmRpY2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgc3BlY2lmaWVkIGluZGljZXMgKi9cbmZ1bmN0aW9uIGdldENlbGxJbmRpY2VzKGluZGljZXMsIGNlbGxNYXApIHtcbiAgcmV0dXJuIGNlbGxNYXAuZmxhdE1hcCgoaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kaWNlcy5pbmNsdWRlcyhpbmRleCkgPyBbY2VsbEluZGV4XSA6IFtdKTtcbn1cblxubGV0IHJhZklkID0gMDtcbmZ1bmN0aW9uIGVucXVldWVGb2N1cyhlbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2UsXG4gICAgY2FuY2VsUHJldmlvdXMgPSB0cnVlLFxuICAgIHN5bmMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY2FuY2VsUHJldmlvdXMgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICBjb25zdCBleGVjID0gKCkgPT4gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmZvY3VzKHtcbiAgICBwcmV2ZW50U2Nyb2xsXG4gIH0pO1xuICBpZiAoc3luYykge1xuICAgIGV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShleGVjKTtcbiAgfVxufVxuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5mdW5jdGlvbiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uKGEsIGIpIHtcbiAgY29uc3QgcG9zaXRpb24gPSBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpO1xuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIHx8IHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gYXJlTWFwc0VxdWFsKG1hcDEsIG1hcDIpIHtcbiAgaWYgKG1hcDEuc2l6ZSAhPT0gbWFwMi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcDEuZW50cmllcygpKSB7XG4gICAgaWYgKHZhbHVlICE9PSBtYXAyLmdldChrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgRmxvYXRpbmdMaXN0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXI6ICgpID0+IHt9LFxuICB1bnJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgbWFwOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBlbGVtZW50c1JlZjoge1xuICAgIGN1cnJlbnQ6IFtdXG4gIH1cbn0pO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGxpc3Qgb2YgaXRlbXMgd2l0aGluIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nTGlzdFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0xpc3QocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRzUmVmLFxuICAgIGxhYmVsc1JlZlxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IG5ldyBNYXAocHJldk1hcCkuc2V0KG5vZGUsIG51bGwpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcChwcmV2TWFwKTtcbiAgICAgIG1hcC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKG1hcCk7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5ld01hcC5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGlmICghYXJlTWFwc0VxdWFsKG1hcCwgbmV3TWFwKSkge1xuICAgICAgc2V0TWFwKG5ld01hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBVc2VkIHRvIHJlZ2lzdGVyIGEgbGlzdCBpdGVtIGFuZCBpdHMgaW5kZXggKERPTSBwb3NpdGlvbikgaW4gdGhlXG4gKiBgRmxvYXRpbmdMaXN0YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3QjdXNlbGlzdGl0ZW1cbiAqL1xuZnVuY3Rpb24gdXNlTGlzdEl0ZW0ocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsYWJlbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RlcixcbiAgICB1bnJlZ2lzdGVyLFxuICAgIG1hcCxcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdMaXN0Q29udGV4dCk7XG4gIGNvbnN0IFtpbmRleCQxLCBzZXRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb21wb25lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKGluZGV4JDEgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBpc0xhYmVsRGVmaW5lZCA/IGxhYmVsIDogKF9ub2RlJHRleHRDb250ZW50ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0Q29udGVudCkgIT0gbnVsbCA/IF9ub2RlJHRleHRDb250ZW50IDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbmRleCQxLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudFJlZi5jdXJyZW50ID8gbWFwLmdldChjb21wb25lbnRSZWYuY3VycmVudCkgOiBudWxsO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmLFxuICAgIGluZGV4OiBpbmRleCQxID09IG51bGwgPyAtMSA6IGluZGV4JDFcbiAgfSksIFtpbmRleCQxLCByZWZdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykge1xuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZW5kZXIoY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIGNvbXB1dGVkUHJvcHMpO1xufVxuY29uc3QgQ29tcG9zaXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IDAsXG4gIG9uTmF2aWdhdGU6ICgpID0+IHt9XG59KTtcbmNvbnN0IGhvcml6b250YWxLZXlzID0gW0FSUk9XX0xFRlQsIEFSUk9XX1JJR0hUXTtcbmNvbnN0IHZlcnRpY2FsS2V5cyA9IFtBUlJPV19VUCwgQVJST1dfRE9XTl07XG5jb25zdCBhbGxLZXlzID0gWy4uLmhvcml6b250YWxLZXlzLCAuLi52ZXJ0aWNhbEtleXNdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGUgdGFiIHN0b3Agd2hvc2UgaXRlbXMgYXJlIG5hdmlnYXRlZCBieSBhcnJvdyBrZXlzLCB3aGljaFxuICogcHJvdmlkZXMgbGlzdCBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgZmxvYXRpbmcgZWxlbWVudCBjb250ZXh0cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBlbmFibGUgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBhcmVu4oCZdCBwYXJ0IG9mIGFcbiAqIGZsb2F0aW5nIGVsZW1lbnQuIEEgbWVudWJhciBpcyBhbiBleGFtcGxlIG9mIGEgY29tcG9zaXRlLCB3aXRoIGVhY2ggcmVmZXJlbmNlXG4gKiBlbGVtZW50IGJlaW5nIGFuIGl0ZW0uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZShwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHtcbiAgICByZW5kZXIsXG4gICAgb3JpZW50YXRpb24gPSAnYm90aCcsXG4gICAgbG9vcCA9IHRydWUsXG4gICAgY29scyA9IDEsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gW10sXG4gICAgYWN0aXZlSW5kZXg6IGV4dGVybmFsQWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCxcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZSxcbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtpbnRlcm5hbEFjdGl2ZUluZGV4LCBpbnRlcm5hbFNldEFjdGl2ZUluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGV4dGVybmFsQWN0aXZlSW5kZXggIT0gbnVsbCA/IGV4dGVybmFsQWN0aXZlSW5kZXggOiBpbnRlcm5hbEFjdGl2ZUluZGV4O1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQoZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCA6IGludGVybmFsU2V0QWN0aXZlSW5kZXgpO1xuICBjb25zdCBlbGVtZW50c1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0pLCBbYWN0aXZlSW5kZXgsIG9uTmF2aWdhdGVdKTtcbiAgY29uc3QgaXNHcmlkID0gY29scyA+IDE7XG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWFsbEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkgcmV0dXJuO1xuICAgIGxldCBuZXh0SW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICBpZiAoaXNHcmlkKSB7XG4gICAgICBjb25zdCBzaXplcyA9IGl0ZW1TaXplcyB8fCBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBlbGVtZW50c1JlZi5jdXJyZW50Lmxlbmd0aFxuICAgICAgfSwgKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfSkpO1xuICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgIC8vIGFzIGlmIGV2ZXJ5IGl0ZW0gd2FzIDF4MSwgdGhlbiBjb252ZXJ0IGJhY2sgdG8gcmVhbCBpbmRpY2VzLlxuICAgICAgY29uc3QgY2VsbE1hcCA9IGJ1aWxkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpO1xuICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSk7XG4gICAgICAvLyBsYXN0IGVuYWJsZWQgaW5kZXhcbiAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICBuZXh0SW5kZXggPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgIGN1cnJlbnQ6IGNlbGxNYXAubWFwKGl0ZW1JbmRleCA9PiBpdGVtSW5kZXggPyBlbGVtZW50c1JlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGluIHRoZW1cbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzOiBnZXRDZWxsSW5kaWNlcyhbLi4uZGlzYWJsZWRJbmRpY2VzLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgbWluSW5kZXg6IG1pbkdyaWRJbmRleCxcbiAgICAgICAgbWF4SW5kZXg6IG1heEdyaWRJbmRleCxcbiAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihhY3RpdmVJbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsXG4gICAgICAgIC8vIHVzZSBhIGNvcm5lciBtYXRjaGluZyB0aGUgZWRnZSBjbG9zZXN0IHRvIHRoZSBkaXJlY3Rpb24gd2UncmVcbiAgICAgICAgLy8gbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgLy8gdG9wL2xlZnQgb3ZlciBib3R0b20vcmlnaHQuXG4gICAgICAgIGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTiA/ICdibCcgOiBldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUID8gJ3RyJyA6ICd0bCcpXG4gICAgICB9KV07IC8vIG5hdmlnYXRlZCBjZWxsIHdpbGwgbmV2ZXIgYmUgbnVsbGlzaFxuICAgIH1cbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgdG9FbmRLZXlzID0ge1xuICAgICAgaG9yaXpvbnRhbDogW0FSUk9XX1JJR0hUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfRE9XTl0sXG4gICAgICBib3RoOiBbQVJST1dfUklHSFQsIEFSUk9XX0RPV05dXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgdG9TdGFydEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfTEVGVF0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX1VQXSxcbiAgICAgIGJvdGg6IFtBUlJPV19MRUZULCBBUlJPV19VUF1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCBwcmV2ZW50ZWRLZXlzID0gaXNHcmlkID8gYWxsS2V5cyA6IHtcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxLZXlzLFxuICAgICAgdmVydGljYWw6IHZlcnRpY2FsS2V5cyxcbiAgICAgIGJvdGg6IGFsbEtleXNcbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBpZiAobmV4dEluZGV4ID09PSBhY3RpdmVJbmRleCAmJiBbLi4udG9FbmRLZXlzLCAuLi50b1N0YXJ0S2V5c10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtYXhJbmRleCAmJiB0b0VuZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1pbkluZGV4ICYmIHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSksXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dEluZGV4ICE9PSBhY3RpdmVJbmRleCAmJiAhaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChwcmV2ZW50ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIG9uTmF2aWdhdGUobmV4dEluZGV4KTtcblxuICAgICAgLy8gV2FpdCBmb3IgRm9jdXNNYW5hZ2VyIGByZXR1cm5Gb2N1c2AgdG8gZXhlY3V0ZS5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsZW1lbnRzUmVmLmN1cnJlbnRbbmV4dEluZGV4XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5kb21Qcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbiA9PT0gJ2JvdGgnID8gdW5kZWZpbmVkIDogb3JpZW50YXRpb24sXG4gICAgb25LZXlEb3duKGUpIHtcbiAgICAgIGRvbVByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IGRvbVByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgaGFuZGxlS2V5RG93bihlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NpdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3QsIHtcbiAgICBlbGVtZW50c1JlZjogZWxlbWVudHNSZWZcbiAgfSwgcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykpKTtcbn0pO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZUl0ZW0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVJdGVtKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIHJlbmRlcixcbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLmRvbVByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIGRvbVByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBkb21Qcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiAvLyBFbnN1cmUgdGhlIGlkIGlzIHVuaXF1ZSB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IHZlcnNpb25zIG9mIEZsb2F0aW5nIFVJXG4vLyBvbiA8UmVhY3QgMThcblwiZmxvYXRpbmctdWktXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA2KSArIGNvdW50Kys7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ0lkKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkKCkgOiB1bmRlZmluZWQpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHNldElkKGdlbklkKCkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSB0cnVlO1xuICB9LCBbXSk7XG4gIHJldHVybiBpZDtcbn1cbmNvbnN0IHVzZVJlYWN0SWQgPSBTYWZlUmVhY3QudXNlSWQ7XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdC11dGlscyN1c2VpZFxuICovXG5jb25zdCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcblxubGV0IGRldk1lc3NhZ2VTZXQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGRldk1lc3NhZ2VTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gd2FybigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVzc2FnZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQgPSBkZXZNZXNzYWdlU2V0KSAhPSBudWxsICYmIF9kZXZNZXNzYWdlU2V0LmhhcyhtZXNzYWdlKSkpIHtcbiAgICB2YXIgX2Rldk1lc3NhZ2VTZXQyO1xuICAgIChfZGV2TWVzc2FnZVNldDIgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0Mi5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0MztcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIG1lc3NhZ2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQzID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldDMuaGFzKG1lc3NhZ2UpKSkge1xuICAgIHZhciBfZGV2TWVzc2FnZVNldDQ7XG4gICAgKF9kZXZNZXNzYWdlU2V0NCA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQ0LmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3cocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvd1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGggPSAxNCxcbiAgICBoZWlnaHQgPSA3LFxuICAgIHRpcFJhZGl1cyA9IDAsXG4gICAgc3Ryb2tlV2lkdGggPSAwLFxuICAgIHN0YXRpY09mZnNldCxcbiAgICBzdHJva2UsXG4gICAgZCxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfSA9IHt9LFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHdhcm4oJ1RoZSBgcmVmYCBwcm9wIGlzIHJlcXVpcmVkIGZvciBgRmxvYXRpbmdBcnJvd2AuJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNsaXBQYXRoSWQgPSB1c2VJZCgpO1xuICBpZiAoIWZsb2F0aW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBTdHJva2VzIG11c3QgYmUgZG91YmxlIHRoZSBib3JkZXIgd2lkdGgsIHRoaXMgZW5zdXJlcyB0aGUgc3Ryb2tlJ3Mgd2lkdGhcbiAgLy8gd29ya3MgYXMgeW91J2QgZXhwZWN0LlxuICBjb25zdCBjb21wdXRlZFN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggKiAyO1xuICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBjb21wdXRlZFN0cm9rZVdpZHRoIC8gMjtcbiAgY29uc3Qgc3ZnWCA9IHdpZHRoIC8gMiAqICh0aXBSYWRpdXMgLyAtOCArIDEpO1xuICBjb25zdCBzdmdZID0gaGVpZ2h0IC8gMiAqIHRpcFJhZGl1cyAvIDQ7XG4gIGNvbnN0IFtzaWRlLCBhbGlnbm1lbnRdID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XG4gIGNvbnN0IGlzUlRMID0gcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpO1xuICBjb25zdCBpc0N1c3RvbVNoYXBlID0gISFkO1xuICBjb25zdCBpc1ZlcnRpY2FsU2lkZSA9IHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICBjb25zdCB5T2Zmc2V0UHJvcCA9IHN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgbGV0IHhPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICBpZiAoc3RhdGljT2Zmc2V0ICYmIGlzUlRMKSB7XG4gICAgeE9mZnNldFByb3AgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBjb25zdCBhcnJvd1ggPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LngpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueCA6ICcnO1xuICBjb25zdCBhcnJvd1kgPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LnkpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueSA6ICcnO1xuICBjb25zdCBkVmFsdWUgPSBkIHx8ICdNMCwwJyArIChcIiBIXCIgKyB3aWR0aCkgKyAoXCIgTFwiICsgKHdpZHRoIC0gc3ZnWCkgKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAoXCIgUVwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgKyBcIiBcIiArIHN2Z1ggKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAnIFonO1xuICBjb25zdCByb3RhdGlvbiA9IHtcbiAgICB0b3A6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDE4MGRlZyknIDogJycsXG4gICAgbGVmdDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgYm90dG9tOiBpc0N1c3RvbVNoYXBlID8gJycgOiAncm90YXRlKDE4MGRlZyknLFxuICAgIHJpZ2h0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJ1xuICB9W3NpZGVdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgd2lkdGg6IGlzQ3VzdG9tU2hhcGUgPyB3aWR0aCA6IHdpZHRoICsgY29tcHV0ZWRTdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoLFxuICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIChoZWlnaHQgPiB3aWR0aCA/IGhlaWdodCA6IHdpZHRoKSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBbeE9mZnNldFByb3BdOiBhcnJvd1gsXG4gICAgICBbeU9mZnNldFByb3BdOiBhcnJvd1ksXG4gICAgICBbc2lkZV06IGlzVmVydGljYWxTaWRlIHx8IGlzQ3VzdG9tU2hhcGUgPyAnMTAwJScgOiBcImNhbGMoMTAwJSAtIFwiICsgY29tcHV0ZWRTdHJva2VXaWR0aCAvIDIgKyBcInB4KVwiLFxuICAgICAgdHJhbnNmb3JtOiBcIlwiICsgcm90YXRpb24gKyAodHJhbnNmb3JtICE9IG51bGwgPyB0cmFuc2Zvcm0gOiAnJyksXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9XG4gIH0pLCBjb21wdXRlZFN0cm9rZVdpZHRoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsaXBQYXRoOiBcInVybCgjXCIgKyBjbGlwUGF0aElkICsgXCIpXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlOiBzdHJva2VcbiAgICAvLyBBY2NvdW50IGZvciB0aGUgc3Ryb2tlIG9uIHRoZSBmaWxsIHBhdGggcmVuZGVyZWQgYmVsb3cuXG4gICAgLFxuICAgIHN0cm9rZVdpZHRoOiBjb21wdXRlZFN0cm9rZVdpZHRoICsgKGQgPyAwIDogMSksXG4gICAgZDogZFZhbHVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIHN0cm9rZTogY29tcHV0ZWRTdHJva2VXaWR0aCAmJiAhZCA/IHJlc3QuZmlsbCA6ICdub25lJyxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwge1xuICAgIGlkOiBjbGlwUGF0aElkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgeDogLWhhbGZTdHJva2VXaWR0aCxcbiAgICB5OiBoYWxmU3Ryb2tlV2lkdGggKiAoaXNDdXN0b21TaGFwZSA/IC0xIDogMSksXG4gICAgd2lkdGg6IHdpZHRoICsgY29tcHV0ZWRTdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoXG4gIH0pKSk7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgfHwgX21hcCRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBbLi4uKG1hcC5nZXQoZXZlbnQpIHx8IFtdKSwgbGlzdGVuZXJdKTtcbiAgICB9LFxuICAgIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICBtYXAuc2V0KGV2ZW50LCAoKF9tYXAkZ2V0MiA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKSkgfHwgW10pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudCBub2RlIGlkIGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMsIGlmIGF2YWlsYWJsZS5cbiAqIFJldHVybnMgYG51bGxgIGZvciB0b3AtbGV2ZWwgZmxvYXRpbmcgZWxlbWVudHMuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGZsb2F0aW5nIHRyZWUgY29udGV4dCwgaWYgYXZhaWxhYmxlLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1RyZWUgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nVHJlZUNvbnRleHQpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG5vZGUgaW50byB0aGUgYEZsb2F0aW5nVHJlZWAsIHJldHVybmluZyBpdHMgaWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nTm9kZUlkKGN1c3RvbVBhcmVudElkKSB7XG4gIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCByZWFjdFBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSBjdXN0b21QYXJlbnRJZCB8fCByZWFjdFBhcmVudElkO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9O1xuICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfTtcbiAgfSwgW3RyZWUsIGlkLCBwYXJlbnRJZF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHdoZW4gdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mXG4gKiBlYWNoIG90aGVyIG9uIHRoZSBET00uXG4gKiBUaGlzIGlzIG5vdCBuZWNlc3NhcnkgaW4gYWxsIGNhc2VzLCBleGNlcHQgd2hlbiB0aGVyZSBtdXN0IGJlIGV4cGxpY2l0IGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzLiBJdCBpcyBuZWNlc3NhcnkgZm9yOlxuICogLSBUaGUgYGJ1YmJsZXNgIG9wdGlvbiBpbiB0aGUgYHVzZURpc21pc3MoKWAgSG9va1xuICogLSBOZXN0ZWQgdmlydHVhbCBsaXN0IG5hdmlnYXRpb25cbiAqIC0gTmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgZWFjaCBvcGVuIG9uIGhvdmVyXG4gKiAtIEN1c3RvbSBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50c1xuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1RyZWUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBub2Rlc1JlZixcbiAgICAgIGFkZE5vZGUsXG4gICAgICByZW1vdmVOb2RlLFxuICAgICAgZXZlbnRzXG4gICAgfSksIFthZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBcImRhdGEtZmxvYXRpbmctdWktXCIgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgaG92ZXJpbmcgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIGxpa2VcbiAqIENTUyBgOmhvdmVyYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlclxuICovXG5mdW5jdGlvbiB1c2VIb3Zlcihjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgcmVmc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGhhbmRsZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgcmVzdFRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICBjb25zdCBibG9ja01vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdW5iaW5kTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHt9KTtcbiAgY29uc3QgaXNIb3Zlck9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICBjb25zdCB0eXBlID0gKF9kYXRhUmVmJGN1cnJlbnQkb3BlbiA9IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JG9wZW4udHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoJ21vdXNlJykpICYmIHR5cGUgIT09ICdtb3VzZWRvd24nO1xuICB9LCBbZGF0YVJlZl0pO1xuXG4gIC8vIFdoZW4gY2xvc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBvcGVuXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmICghb3Blbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCB8fCAhaGFuZGxlQ2xvc2VSZWYuY3VycmVudCB8fCAhb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50KGZsb2F0aW5nKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGh0bWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIH07XG4gIH0sIFtmbG9hdGluZywgb3Blbiwgb25PcGVuQ2hhbmdlLCBlbmFibGVkLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgY29uc3QgY2xvc2VXaXRoRGVsYXkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIHJ1bkVsc2VCcmFuY2gsIHJlYXNvbikge1xuICAgIGlmIChydW5FbHNlQnJhbmNoID09PSB2b2lkIDApIHtcbiAgICAgIHJ1bkVsc2VCcmFuY2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICAgIHJlYXNvbiA9ICdob3Zlcic7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbiksIGNsb3NlRGVsYXkpO1xuICAgIH0gZWxzZSBpZiAocnVuRWxzZUJyYW5jaCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pO1xuICAgIH1cbiAgfSwgW2RlbGF5UmVmLCBvbk9wZW5DaGFuZ2VdKTtcbiAgY29uc3QgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH0sIFtdKTtcbiAgY29uc3QgY2xlYXJQb2ludGVyRXZlbnRzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KHJlZnMuZmxvYXRpbmcuY3VycmVudCkuYm9keTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgYm9keS5yZW1vdmVBdHRyaWJ1dGUoc2FmZVBvbHlnb25JZGVudGlmaWVyKTtcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbcmVmc10pO1xuXG4gIC8vIFJlZ2lzdGVyaW5nIHRoZSBtb3VzZSBldmVudHMgb24gdGhlIHJlZmVyZW5jZSBkaXJlY3RseSB0byBieXBhc3MgUmVhY3Qnc1xuICAvLyBkZWxlZ2F0aW9uIHN5c3RlbS4gSWYgdGhlIGN1cnNvciB3YXMgb24gYSBkaXNhYmxlZCBlbGVtZW50IGFuZCB0aGVuIGVudGVyZWRcbiAgLy8gdGhlIHJlZmVyZW5jZSAobm8gZ2FwKSwgYG1vdXNlZW50ZXJgIGRvZXNuJ3QgZmlyZSBpbiB0aGUgZGVsZWdhdGlvbiBzeXN0ZW0uXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkge1xuICAgICAgcmV0dXJuIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBbJ2NsaWNrJywgJ21vdXNlZG93biddLmluY2x1ZGVzKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSkgOiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUVudGVyKGV2ZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChtb3VzZU9ubHkgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCkgfHwgcmVzdE1zID4gMCAmJiAhZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgfSwgb3BlbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xlYXJpbmcgYG9uU2Nyb2xsTW91c2VMZWF2ZWAgdGltZW91dC5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQsIHRydWUsICdzYWZlLXBvbHlnb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlclJlZi5jdXJyZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBpbnRlcmFjdGl2aXR5IHdpdGhvdXQgYHNhZmVQb2x5Z29uYCBvbiB0b3VjaCBkZXZpY2VzLiBXaXRoIGFcbiAgICAgIC8vIHBvaW50ZXIsIGEgc2hvcnQgY2xvc2UgZGVsYXkgaXMgYW4gYWx0ZXJuYXRpdmUsIHNvIGl0IHNob3VsZCB3b3JrXG4gICAgICAvLyBjb25zaXN0ZW50bHkuXG4gICAgICBjb25zdCBzaG91bGRDbG9zZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcgPyAhY29udGFpbnMoZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsIHx8IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICB0cmVlLFxuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KShldmVudCk7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgY29uc3QgcmVmID0gZG9tUmVmZXJlbmNlO1xuICAgICAgb3BlbiAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBmbG9hdGluZyA9PSBudWxsIHx8IGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgbW92ZSAmJiByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb3BlbiAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIG1vdmUgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VFbnRlcik7XG4gICAgICAgIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3BlbiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX2hhbmRsZUNsb3NlUmVmJGN1cnJlO1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmJvZHk7XG4gICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChpc0VsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZykge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gX3RyZWUkbm9kZXNSZWYkY3VycmVuLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfVxuICB9LCBbb3BlbiwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZG9tUmVmZXJlbmNlLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclJlZihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJSZWYsXG4gICAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSgpIHtcbiAgICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuIHx8IHJlc3RNcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgaWYgKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlTW91c2VNb3ZlLCByZXN0TXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQubmF0aXZlRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBtb3VzZU9ubHksIG9wZW4sIHJlc3RNcywgb25PcGVuQ2hhbmdlLCBjbG9zZVdpdGhEZWxheV0pO1xufVxuXG5jb25zdCBOT09QID0gKCkgPT4ge307XG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiBOT09QLFxuICBzZXRTdGF0ZTogTk9PUCxcbiAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgYHVzZURlbGF5R3JvdXAoKWAgaW5zdGVhZC5cbiAqL1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRGVsYXlHcm91cChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlUmVkdWNlcigocHJldiwgbmV4dCkgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm5leHRcbiAgfSksIHtcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5OiBkZWxheSxcbiAgICBjdXJyZW50SWQ6IG51bGwsXG4gICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbml0aWFsQ3VycmVudElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRDdXJyZW50SWQgPSBSZWFjdC51c2VDYWxsYmFjayhjdXJyZW50SWQgPT4ge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRJZFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudElkKSB7XG4gICAgICBpZiAoaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IHN0YXRlLmN1cnJlbnRJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0luc3RhbnRQaGFzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50SWRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHNldEN1cnJlbnRJZFxuICAgIH0pLCBbc3RhdGUsIHNldEN1cnJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIHVzZURlbGF5R3JvdXAoY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBmbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgaWQ6IG9wdGlvbklkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZCA9IG9wdGlvbklkICE9IG51bGwgPyBvcHRpb25JZCA6IGZsb2F0aW5nSWQ7XG4gIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IGdyb3VwQ29udGV4dDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghY3VycmVudElkKSByZXR1cm47XG4gICAgc2V0U3RhdGUoe1xuICAgICAgZGVsYXk6IHtcbiAgICAgICAgb3BlbjogMSxcbiAgICAgICAgY2xvc2U6IGdldERlbGF5KGluaXRpYWxEZWxheSwgJ2Nsb3NlJylcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY3VycmVudElkICE9PSBpZCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpZCwgb25PcGVuQ2hhbmdlLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpbml0aWFsRGVsYXldKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50SWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4gJiYgY3VycmVudElkID09PSBpZCkge1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodW5zZXQsIHRpbWVvdXRNcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdW5zZXQoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpZCwgb25PcGVuQ2hhbmdlLCBpbml0aWFsRGVsYXksIHRpbWVvdXRNc10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHNldEN1cnJlbnRJZCA9PT0gTk9PUCB8fCAhb3BlbikgcmV0dXJuO1xuICAgIHNldEN1cnJlbnRJZChpZCk7XG4gIH0sIFtvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG4gIHJldHVybiBncm91cENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlcywgaWQpIHtcbiAgbGV0IGFsbENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pO1xuICB9KTtcbiAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGFsbENoaWxkcmVuO1xuICB3aGlsZSAoY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIGN1cnJlbnRDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHZhciBfY3VycmVudENoaWxkcmVuO1xuICAgICAgcmV0dXJuIChfY3VycmVudENoaWxkcmVuID0gY3VycmVudENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRDaGlsZHJlbi5zb21lKG4gPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDI7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBuLmlkICYmICgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5vcGVuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFsbENoaWxkcmVuID0gYWxsQ2hpbGRyZW4uY29uY2F0KGN1cnJlbnRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGFsbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0RGVlcGVzdE5vZGUobm9kZXMsIGlkKSB7XG4gIGxldCBkZWVwZXN0Tm9kZUlkO1xuICBsZXQgbWF4RGVwdGggPSAtMTtcbiAgZnVuY3Rpb24gZmluZERlZXBlc3Qobm9kZUlkLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICBkZWVwZXN0Tm9kZUlkID0gbm9kZUlkO1xuICAgICAgbWF4RGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihub2Rlcywgbm9kZUlkKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGZpbmREZWVwZXN0KGNoaWxkLmlkLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG4gIGZpbmREZWVwZXN0KGlkLCAwKTtcbiAgcmV0dXJuIG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBkZWVwZXN0Tm9kZUlkKTtcbn1cblxuLy8gTW9kaWZpZWQgdG8gYWRkIGNvbmRpdGlvbmFsIGBhcmlhLWhpZGRlbmAgc3VwcG9ydDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vYmxvYi85MjIwYzhmNGE0ZmQzNWY2M2JlZTU1MTBhOWY0MWEzNzI2NDM4MmQ0L3NyYy9pbmRleC50c1xubGV0IGNvdW50ZXJNYXAgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmxldCB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xubGV0IG1hcmtlck1hcCA9IHt9O1xubGV0IGxvY2tDb3VudCA9IDA7XG5jb25zdCBzdXBwb3J0c0luZXJ0ID0gKCkgPT4gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaW5lcnQnIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHVud3JhcEhvc3QgPSBub2RlID0+IG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xuY29uc3QgY29ycmVjdEVsZW1lbnRzID0gKHBhcmVudCwgdGFyZ2V0cykgPT4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gIGlmIChwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVUb090aGVycyh1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMsIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGNvbnN0IG1hcmtlck5hbWUgPSAnZGF0YS1mbG9hdGluZy11aS1pbmVydCc7XG4gIGNvbnN0IGNvbnRyb2xBdHRyaWJ1dGUgPSBpbmVydCA/ICdpbmVydCcgOiBhcmlhSGlkZGVuID8gJ2FyaWEtaGlkZGVuJyA6IG51bGw7XG4gIGNvbnN0IGF2b2lkRWxlbWVudHMgPSBjb3JyZWN0RWxlbWVudHMoYm9keSwgdW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldChhdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgaWYgKCFtYXJrZXJNYXBbbWFya2VyTmFtZV0pIHtcbiAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNvbnN0IG1hcmtlckNvdW50ZXIgPSBtYXJrZXJNYXBbbWFya2VyTmFtZV07XG4gIGF2b2lkRWxlbWVudHMuZm9yRWFjaChrZWVwKTtcbiAgZGVlcChib2R5KTtcbiAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgZnVuY3Rpb24ga2VlcChlbCkge1xuICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgIGVsLnBhcmVudE5vZGUgJiYga2VlcChlbC5wYXJlbnROb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWVwKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlIaWRkZW4gJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2NrQ291bnQrKztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvdW50ZXJNYXAuc2V0KGVsZW1lbnQsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICBtYXJrZXJDb3VudGVyLnNldChlbGVtZW50LCBtYXJrZXJWYWx1ZSk7XG4gICAgICBpZiAoIWNvdW50ZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NrQ291bnQtLTtcbiAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtPdGhlcnMoYXZvaWRFbGVtZW50cywgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgaWYgKGFyaWFIaWRkZW4gPT09IHZvaWQgMCkge1xuICAgIGFyaWFIaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5lcnQgPT09IHZvaWQgMCkge1xuICAgIGluZXJ0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGF2b2lkRWxlbWVudHNbMF0pLmJvZHk7XG4gIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKGF2b2lkRWxlbWVudHMuY29uY2F0KEFycmF5LmZyb20oYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChjb250YWluZXIpKSk7XG4gIGNvbnN0IG5leHRUYWJiYWJsZUVsZW1lbnRzID0gYWxsVGFiYmFibGUuc2xpY2UoYWN0aXZlSW5kZXggKyAxKTtcbiAgcmV0dXJuIG5leHRUYWJiYWJsZUVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAnbmV4dCcpO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ3ByZXYnKTtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFNlZSBEaWVnbyBIYXoncyBTYW5kYm94IGZvciBtYWtpbmcgdGhpcyBsb2dpYyB3b3JrIHdlbGwgb24gU2FmYXJpL2lPUzpcbi8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL0ZvY3VzVHJhcC50c3hcblxuY29uc3QgSElEREVOX1NUWUxFUyA9IHtcbiAgYm9yZGVyOiAwLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBhZGRpbmc6IDAsXG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgd2lkdGg6ICcxcHgnLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDBcbn07XG5sZXQgdGltZW91dElkO1xuZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudE9uVGFiKGV2ZW50KSB7XG4gIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgZXZlbnQudGFyZ2V0O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9XG59XG5jb25zdCBGb2N1c0d1YXJkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9jdXNHdWFyZChwcm9wcywgcmVmKSB7XG4gIGNvbnN0IFtyb2xlLCBzZXRSb2xlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgLy8gVW5saWtlIG90aGVyIHNjcmVlbiByZWFkZXJzIHN1Y2ggYXMgTlZEQSBhbmQgSkFXUywgdGhlIHZpcnR1YWwgY3Vyc29yXG4gICAgICAvLyBvbiBWb2ljZU92ZXIgZG9lcyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LCBzbyB3ZSBjYW4gdXNlIHRoZSBmb2N1c1xuICAgICAgLy8gdHJhcCBlbGVtZW50LiBPbiBTYWZhcmksIG9ubHkgYnV0dG9ucyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LlxuICAgICAgLy8gTkI6IFwiZ3JvdXBcIiByb2xlIGluIHRoZSBTYW5kYm94IG5vIGxvbmdlciBhcHBlYXJzIHRvIHdvcmssIG11c3QgYmUgYVxuICAgICAgLy8gYnV0dG9uIHJvbGUuXG4gICAgICBzZXRSb2xlKCdidXR0b24nKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzdFByb3BzID0ge1xuICAgIHJlZixcbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBSb2xlIGlzIG9ubHkgZm9yIFZvaWNlT3ZlclxuICAgIHJvbGUsXG4gICAgJ2FyaWEtaGlkZGVuJzogcm9sZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgW2NyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKV06ICcnLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHByb3BzLCByZXN0UHJvcHMpKTtcbn0pO1xuXG5jb25zdCBQb3J0YWxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBhdHRyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJyk7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsI3VzZWZsb2F0aW5ncG9ydGFsbm9kZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ1BvcnRhbE5vZGUocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICByb290XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcG9ydGFsTm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxOb2RlID09IG51bGwgfHwgcG9ydGFsTm9kZS5yZW1vdmUoKTtcbiAgICAgIC8vIEFsbG93IHRoZSBzdWJzZXF1ZW50IGxheW91dCBlZmZlY3RzIHRvIGNyZWF0ZSBhIG5ldyBub2RlIG9uIHVwZGF0ZXMuXG4gICAgICAvLyBUaGUgcG9ydGFsIG5vZGUgd2lsbCBzdGlsbCBiZSBjbGVhbmVkIHVwIG9uIHVubW91bnQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI0NTRcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocG9ydGFsTm9kZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdJZFJvb3QgPSBpZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IG51bGw7XG4gICAgaWYgKCFleGlzdGluZ0lkUm9vdCkgcmV0dXJuO1xuICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgIGV4aXN0aW5nSWRSb290LmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHN1YlJvb3Q7XG4gICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgfSwgW2lkLCB1bmlxdWVJZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGxldCBjb250YWluZXIgPSByb290IHx8IChwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpO1xuICAgIGlmIChjb250YWluZXIgJiYgIWlzRWxlbWVudChjb250YWluZXIpKSBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBsZXQgaWRXcmFwcGVyID0gbnVsbDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGlkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWRXcmFwcGVyLmlkID0gaWQ7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWRXcmFwcGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgY29udGFpbmVyID0gaWRXcmFwcGVyIHx8IGNvbnRhaW5lcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHJvb3QsIHVuaXF1ZUlkLCBwb3J0YWxDb250ZXh0XSk7XG4gIHJldHVybiBwb3J0YWxOb2RlO1xufVxuLyoqXG4gKiBQb3J0YWxzIHRoZSBmbG9hdGluZyBlbGVtZW50IGludG8gYSBnaXZlbiBjb250YWluZXIgZWxlbWVudCDigJQgYnkgZGVmYXVsdCxcbiAqIG91dHNpZGUgb2YgdGhlIGFwcCByb290IGFuZCBpbnRvIHRoZSBib2R5LlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBhcHBlYXIgb3V0c2lkZSBhbnlcbiAqIHBvdGVudGlhbCBwYXJlbnQgY29udGFpbmVycyB0aGF0IGNhdXNlIGNsaXBwaW5nIChzdWNoIGFzIGBvdmVyZmxvdzogaGlkZGVuYCksXG4gKiB3aGlsZSByZXRhaW5pbmcgaXRzIGxvY2F0aW9uIGluIHRoZSBSZWFjdCB0cmVlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nUG9ydGFsKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICByb290ID0gbnVsbCxcbiAgICBwcmVzZXJ2ZVRhYk9yZGVyID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvcnRhbE5vZGUgPSB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoe1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSk7XG4gIGNvbnN0IFtmb2N1c01hbmFnZXJTdGF0ZSwgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGJlZm9yZU91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVyT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYmVmb3JlSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlckluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID1cbiAgLy8gVGhlIEZvY3VzTWFuYWdlciBhbmQgdGhlcmVmb3JlIGZsb2F0aW5nIGVsZW1lbnQgYXJlIGN1cnJlbnRseSBvcGVuL1xuICAvLyByZW5kZXJlZC5cbiAgISFmb2N1c01hbmFnZXJTdGF0ZSAmJlxuICAvLyBHdWFyZHMgYXJlIG9ubHkgZm9yIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50LlxuICAhZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwgJiZcbiAgLy8gRG9uJ3QgcmVuZGVyIGlmIHVubW91bnQgaXMgdHJhbnNpdGlvbmluZy5cbiAgZm9jdXNNYW5hZ2VyU3RhdGUub3BlbiAmJiBwcmVzZXJ2ZVRhYk9yZGVyICYmICEhKHJvb3QgfHwgcG9ydGFsTm9kZSk7XG5cbiAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvVGFiYmFibGVQb3J0YWwudHN4XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlIHx8ICFwcmVzZXJ2ZVRhYk9yZGVyIHx8IGZvY3VzTWFuYWdlclN0YXRlICE9IG51bGwgJiYgZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pXG4gIH0sIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAoX2JlZm9yZUluc2lkZVJlZiRjdXJyID0gYmVmb3JlSW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2JlZm9yZUluc2lkZVJlZiRjdXJyLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtb3duc1wiOiBwb3J0YWxOb2RlLmlkLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pLCBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAoX2FmdGVySW5zaWRlUmVmJGN1cnJlID0gYWZ0ZXJJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYWZ0ZXJJbnNpZGVSZWYkY3VycmUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLmNsb3NlT25Gb2N1c091dCkgJiYgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5jb25zdCB1c2VQb3J0YWxDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChQb3J0YWxDb250ZXh0KTtcblxuY29uc3QgTElTVF9MSU1JVCA9IDIwO1xubGV0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChlbGVtZW50KSB7XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG4gIGxldCB0YWJiYWJsZUVsID0gZWxlbWVudDtcbiAgaWYgKCF0YWJiYWJsZUVsIHx8IGdldE5vZGVOYW1lKHRhYmJhYmxlRWwpID09PSAnYm9keScpIHJldHVybjtcbiAgaWYgKCFpc1RhYmJhYmxlKHRhYmJhYmxlRWwsIGdldFRhYmJhYmxlT3B0aW9ucygpKSkge1xuICAgIGNvbnN0IHRhYmJhYmxlQ2hpbGQgPSB0YWJiYWJsZSh0YWJiYWJsZUVsLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSlbMF07XG4gICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgIHRhYmJhYmxlRWwgPSB0YWJiYWJsZUNoaWxkO1xuICAgIH1cbiAgfVxuICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnB1c2godGFiYmFibGVFbCk7XG4gIGlmIChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmxlbmd0aCA+IExJU1RfTElNSVQpIHtcbiAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgtTElTVF9MSU1JVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHtcbiAgcmV0dXJuIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuc2xpY2UoKS5yZXZlcnNlKCkuZmluZChlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG59XG5jb25zdCBWaXN1YWxseUhpZGRlbkRpc21pc3MgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBWaXN1YWxseUhpZGRlbkRpc21pc3MocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfSkpO1xufSk7XG4vKipcbiAqIFByb3ZpZGVzIGZvY3VzIG1hbmFnZW1lbnQgZm9yIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRm9jdXNNYW5hZ2VyXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRm9jdXNNYW5hZ2VyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgb3JkZXIgPSBbJ2NvbnRlbnQnXSxcbiAgICBndWFyZHM6IF9ndWFyZHMgPSB0cnVlLFxuICAgIGluaXRpYWxGb2N1cyA9IDAsXG4gICAgcmV0dXJuRm9jdXMgPSB0cnVlLFxuICAgIG1vZGFsID0gdHJ1ZSxcbiAgICB2aXN1YWxseUhpZGRlbkRpc21pc3MgPSBmYWxzZSxcbiAgICBjbG9zZU9uRm9jdXNPdXQgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgcmVmcyxcbiAgICBub2RlSWQsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGlnbm9yZUluaXRpYWxGb2N1cyA9IHR5cGVvZiBpbml0aWFsRm9jdXMgPT09ICdudW1iZXInICYmIGluaXRpYWxGb2N1cyA8IDA7XG4gIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgYSBjb21ib2JveCBhbmQgaXMgdHlwZWFibGUgKGUuZy4gaW5wdXQvdGV4dGFyZWEpLFxuICAvLyB0aGVyZSBhcmUgZGlmZmVyZW50IGZvY3VzIHNlbWFudGljcy4gVGhlIGd1YXJkcyBzaG91bGQgbm90IGJlIHJlbmRlcmVkLCBidXRcbiAgLy8gYXJpYS1oaWRkZW4gc2hvdWxkIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHN0aWxsLiBGdXJ0aGVyLCB0aGUgdmlzdWFsbHlcbiAgLy8gaGlkZGVuIGRpc21pc3MgYnV0dG9uIHNob3VsZCBvbmx5IGFwcGVhciBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBub3QgdGhlXG4gIC8vIHN0YXJ0LlxuICBjb25zdCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPSBpc1R5cGVhYmxlQ29tYm9ib3goZG9tUmVmZXJlbmNlKSAmJiBpZ25vcmVJbml0aWFsRm9jdXM7XG5cbiAgLy8gRm9yY2UgdGhlIGd1YXJkcyB0byBiZSByZW5kZXJlZCBpZiB0aGUgYGluZXJ0YCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgY29uc3QgZ3VhcmRzID0gc3VwcG9ydHNJbmVydCgpID8gX2d1YXJkcyA6IHRydWU7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgaW5pdGlhbEZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKGluaXRpYWxGb2N1cyk7XG4gIGNvbnN0IHJldHVybkZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKHJldHVybkZvY3VzKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBzdGFydERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVuZERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZlbnRSZXR1cm5Gb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0luc2lkZVBvcnRhbCA9IHBvcnRhbENvbnRleHQgIT0gbnVsbDtcbiAgY29uc3QgZ2V0VGFiYmFibGVDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgY29udGFpbmVyID0gZmxvYXRpbmc7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXIgPyB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKSA6IFtdO1xuICB9LCBbZmxvYXRpbmddKTtcbiAgY29uc3QgZ2V0VGFiYmFibGVFbGVtZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKGNvbnRhaW5lciA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudChjb250YWluZXIpO1xuICAgIHJldHVybiBvcmRlclJlZi5jdXJyZW50Lm1hcCh0eXBlID0+IHtcbiAgICAgIGlmIChkb21SZWZlcmVuY2UgJiYgdHlwZSA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgcmV0dXJuIGRvbVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlID09PSAnZmxvYXRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmbG9hdGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmZpbHRlcihCb29sZWFuKS5mbGF0KCk7XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBvcmRlclJlZiwgZ2V0VGFiYmFibGVDb250ZW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFtb2RhbCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICAgICAgLy8gVGhlIGZvY3VzIGd1YXJkcyBoYXZlIG5vdGhpbmcgdG8gZm9jdXMsIHNvIHdlIG5lZWQgdG8gc3RvcCB0aGUgZXZlbnQuXG4gICAgICAgIGlmIChjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpKSAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDAgJiYgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxzID0gZ2V0VGFiYmFibGVFbGVtZW50cygpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFswXSA9PT0gJ3JlZmVyZW5jZScgJiYgdGFyZ2V0ID09PSBkb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnRbMV0gPT09ICdmbG9hdGluZycgJiYgdGFyZ2V0ID09PSBmbG9hdGluZyAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGdldFRhYmJhYmxlQ29udGVudCwgZ2V0VGFiYmFibGVFbGVtZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhY2xvc2VPbkZvY3VzT3V0KSByZXR1cm47XG5cbiAgICAvLyBJbiBTYWZhcmksIGJ1dHRvbnMgbG9zZSBmb2N1cyB3aGVuIHByZXNzaW5nIHRoZW0uXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oKSB7XG4gICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzT3V0c2lkZShldmVudCkge1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVkVG9VbnJlbGF0ZWROb2RlID0gIShjb250YWlucyhkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhyZWxhdGVkVGFyZ2V0LCBmbG9hdGluZykgfHwgY29udGFpbnMocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlLCByZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSB8fCB0cmVlICYmIChnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgICB2YXIgX25vZGUkY29udGV4dCwgX25vZGUkY29udGV4dDI7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIuZWxlbWVudHMuZG9tUmVmZXJlbmNlLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfSkgfHwgZ2V0QW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0MywgX25vZGUkY29udGV4dDQ7XG4gICAgICAgICAgcmV0dXJuICgoX25vZGUkY29udGV4dDMgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0My5lbGVtZW50cy5mbG9hdGluZykgPT09IHJlbGF0ZWRUYXJnZXQgfHwgKChfbm9kZSRjb250ZXh0NCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IHJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH0pKSk7XG5cbiAgICAgICAgLy8gRm9jdXMgZGlkIG5vdCBtb3ZlIGluc2lkZSB0aGUgZmxvYXRpbmcgdHJlZSwgYW5kIHRoZXJlIGFyZSBubyB0YWJiYWJsZVxuICAgICAgICAvLyBwb3J0YWwgZ3VhcmRzIHRvIGhhbmRsZSBjbG9zaW5nLlxuICAgICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiBtb3ZlZFRvVW5yZWxhdGVkTm9kZSAmJiAhaXNQb2ludGVyRG93blJlZi5jdXJyZW50ICYmXG4gICAgICAgIC8vIEZpeCBSZWFjdCAxOCBTdHJpY3QgTW9kZSByZXR1cm5Gb2N1cyBkdWUgdG8gZG91YmxlIHJlbmRlcmluZy5cbiAgICAgICAgcmVsYXRlZFRhcmdldCAhPT0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBub2RlSWQsIHRyZWUsIHBvcnRhbENvbnRleHQsIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9wb3J0YWxDb250ZXh0JHBvcnRhbDtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERvbid0IGhpZGUgcG9ydGFscyBuZXN0ZWQgd2l0aGluIHRoZSBwYXJlbnQgcG9ydGFsLlxuICAgIGNvbnN0IHBvcnRhbE5vZGVzID0gQXJyYXkuZnJvbSgocG9ydGFsQ29udGV4dCA9PSBudWxsIHx8IChfcG9ydGFsQ29udGV4dCRwb3J0YWwgPSBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfcG9ydGFsQ29udGV4dCRwb3J0YWwucXVlcnlTZWxlY3RvckFsbChcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJykgKyBcIl1cIikpIHx8IFtdKTtcbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIGNvbnN0IGluc2lkZUVsZW1lbnRzID0gW2Zsb2F0aW5nLCAuLi5wb3J0YWxOb2Rlcywgc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgb3JkZXJSZWYuY3VycmVudC5pbmNsdWRlcygncmVmZXJlbmNlJykgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gZG9tUmVmZXJlbmNlIDogbnVsbF0uZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBtb2RhbCB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzLCBndWFyZHMsICFndWFyZHMpIDogbWFya090aGVycyhpbnNpZGVFbGVtZW50cyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIHBvcnRhbENvbnRleHQsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ3VhcmRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcblxuICAgIC8vIFdhaXQgZm9yIGFueSBsYXlvdXQgZWZmZWN0IHN0YXRlIHNldHRlcnMgdG8gZXhlY3V0ZSB0byBzZXQgYHRhYkluZGV4YC5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldFRhYmJhYmxlRWxlbWVudHMoZmxvYXRpbmcpO1xuICAgICAgY29uc3QgaW5pdGlhbEZvY3VzVmFsdWUgPSBpbml0aWFsRm9jdXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGVsVG9Gb2N1cyA9ICh0eXBlb2YgaW5pdGlhbEZvY3VzVmFsdWUgPT09ICdudW1iZXInID8gZm9jdXNhYmxlRWxlbWVudHNbaW5pdGlhbEZvY3VzVmFsdWVdIDogaW5pdGlhbEZvY3VzVmFsdWUuY3VycmVudCkgfHwgZmxvYXRpbmc7XG4gICAgICBjb25zdCBmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsID0gY29udGFpbnMoZmxvYXRpbmcsIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICBpZiAoIWlnbm9yZUluaXRpYWxGb2N1cyAmJiAhZm9jdXNBbHJlYWR5SW5zaWRlRmxvYXRpbmdFbCAmJiBvcGVuKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhlbFRvRm9jdXMsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBlbFRvRm9jdXMgPT09IGZsb2F0aW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZGlzYWJsZWQsIG9wZW4sIGZsb2F0aW5nLCBpZ25vcmVJbml0aWFsRm9jdXMsIGdldFRhYmJhYmxlRWxlbWVudHMsIGluaXRpYWxGb2N1c1JlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZykgcmV0dXJuO1xuICAgIGxldCBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgIGNvbnN0IGNvbnRleHREYXRhID0gZGF0YVJlZi5jdXJyZW50O1xuICAgIGxldCBvcGVuRXZlbnQgPSBjb250ZXh0RGF0YS5vcGVuRXZlbnQ7XG4gICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBldmVudCxcbiAgICAgICAgbmVzdGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIG9wZW5FdmVudCA9IGV2ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknICYmIHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2hvdmVyJyAmJiBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiAhPT0gJ291dHNpZGUtcHJlc3MnKSByZXR1cm47XG4gICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9ICEoaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA9IGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbCkgfHwgdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQ1O1xuICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQ1ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDUuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2hvdWxkRm9jdXNSZWZlcmVuY2UgPSBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIHx8IG9wZW5FdmVudCAmJiBbJ2NsaWNrJywgJ21vdXNlZG93biddLmluY2x1ZGVzKG9wZW5FdmVudC50eXBlKTtcbiAgICAgIGlmIChzaG91bGRGb2N1c1JlZmVyZW5jZSAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHVybkVsZW1lbnQgPSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIHJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgIXByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ICYmIGlzSFRNTEVsZW1lbnQocmV0dXJuRWxlbWVudCkgJiYgKFxuICAgICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVkIHNvbWV3aGVyZSBlbHNlIGFmdGVyIG1vdW50LCBhdm9pZCByZXR1cm5pbmcgZm9jdXNcbiAgICAgIC8vIHNpbmNlIGl0IGxpa2VseSBlbnRlcmVkIGEgZGlmZmVyZW50IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlXG4gICAgICAvLyByZXNwZWN0ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjYwN1xuICAgICAgcmV0dXJuRWxlbWVudCAhPT0gYWN0aXZlRWwgJiYgYWN0aXZlRWwgIT09IGRvYy5ib2R5ID8gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA6IHRydWUpKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhyZXR1cm5FbGVtZW50LCB7XG4gICAgICAgICAgLy8gV2hlbiBkaXNtaXNzaW5nIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cywgYnkgdGhlIHRpbWUgdGhlIHJBRiBoYXNcbiAgICAgICAgICAvLyBleGVjdXRlZCwgdGhlIG1lbnVzIHdpbGwgYWxsIGhhdmUgYmVlbiB1bm1vdW50ZWQuIFdoZW4gdGhleSB0cnlcbiAgICAgICAgICAvLyB0byBnZXQgZm9jdXNlZCwgdGhlIGNhbGxzIGdldCBpZ25vcmVkIOKAlCBsZWF2aW5nIHRoZSByb290XG4gICAgICAgICAgLy8gcmVmZXJlbmNlIGZvY3VzZWQgYXMgZGVzaXJlZC5cbiAgICAgICAgICBjYW5jZWxQcmV2aW91czogZmFsc2UsXG4gICAgICAgICAgcHJldmVudFNjcm9sbDogcHJldmVudFJldHVybkZvY3VzU2Nyb2xsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJldHVybkZvY3VzUmVmLCBkYXRhUmVmLCByZWZzLCBldmVudHMsIHRyZWUsIG5vZGVJZF0pO1xuXG4gIC8vIFN5bmNocm9uaXplIHRoZSBgY29udGV4dGAgJiBgbW9kYWxgIHZhbHVlIHRvIHRoZSBGbG9hdGluZ1BvcnRhbCBjb250ZXh0LlxuICAvLyBJdCB3aWxsIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCBpdCBuZWVkcyB0byByZW5kZXIgaXRzIG93biBndWFyZHMuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIXBvcnRhbENvbnRleHQpIHJldHVybjtcbiAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKHtcbiAgICAgIG1vZGFsLFxuICAgICAgY2xvc2VPbkZvY3VzT3V0LFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgIHJlZnNcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsQ29udGV4dC5zZXRGb2N1c01hbmFnZXJTdGF0ZShudWxsKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIHBvcnRhbENvbnRleHQsIG1vZGFsLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGNsb3NlT25Gb2N1c091dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZyB8fCB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ2Z1bmN0aW9uJyB8fCBpZ25vcmVJbml0aWFsRm9jdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlTXV0YXRpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YWJJbmRleCA9IGZsb2F0aW5nLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdmbG9hdGluZycpIHx8IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKSAhPT0gcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAnMCcpIHtcbiAgICAgICAgICBmbG9hdGluZy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWJJbmRleCAhPT0gJy0xJykge1xuICAgICAgICBmbG9hdGluZy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVNdXRhdGlvbigpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb24pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCByZWZzLCBvcmRlclJlZiwgZ2V0VGFiYmFibGVDb250ZW50LCBpZ25vcmVJbml0aWFsRm9jdXNdKTtcbiAgZnVuY3Rpb24gcmVuZGVyRGlzbWlzc0J1dHRvbihsb2NhdGlvbikge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhdmlzdWFsbHlIaWRkZW5EaXNtaXNzIHx8ICFtb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaXN1YWxseUhpZGRlbkRpc21pc3MsIHtcbiAgICAgIHJlZjogbG9jYXRpb24gPT09ICdzdGFydCcgPyBzdGFydERpc21pc3NCdXR0b25SZWYgOiBlbmREaXNtaXNzQnV0dG9uUmVmLFxuICAgICAgb25DbGljazogZXZlbnQgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudClcbiAgICB9LCB0eXBlb2YgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID09PSAnc3RyaW5nJyA/IHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA6ICdEaXNtaXNzJyk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID0gIWRpc2FibGVkICYmIGd1YXJkcyAmJiAoaXNJbnNpZGVQb3J0YWwgfHwgbW9kYWwpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYmVmb3JlSW5zaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGVucXVldWVGb2N1cyhvcmRlclswXSA9PT0gJ3JlZmVyZW5jZScgPyBlbHNbMF0gOiBlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKCkgfHwgZG9tUmVmZXJlbmNlO1xuICAgICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9ydGFsQ29udGV4dCRiZWZvcmU7XG4gICAgICAgICAgKF9wb3J0YWxDb250ZXh0JGJlZm9yZSA9IHBvcnRhbENvbnRleHQuYmVmb3JlT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGJlZm9yZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCAmJiByZW5kZXJEaXNtaXNzQnV0dG9uKCdzdGFydCcpLCBjaGlsZHJlbiwgcmVuZGVyRGlzbWlzc0J1dHRvbignZW5kJyksIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICByZWY6IHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYWZ0ZXJJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhnZXRUYWJiYWJsZUVsZW1lbnRzKClbMF0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBpZiAoY2xvc2VPbkZvY3VzT3V0KSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGFmdGVyTztcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYWZ0ZXJPID0gcG9ydGFsQ29udGV4dC5hZnRlck91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfcG9ydGFsQ29udGV4dCRhZnRlck8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuXG5jb25zdCBhY3RpdmVMb2NrcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG4vKipcbiAqIFByb3ZpZGVzIGJhc2Ugc3R5bGluZyBmb3IgYSBmaXhlZCBvdmVybGF5IGVsZW1lbnQgdG8gZGltIGNvbnRlbnQgb3IgYmxvY2tcbiAqIHBvaW50ZXIgZXZlbnRzIGJlaGluZCBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBJdCdzIGEgcmVndWxhciBgPGRpdj5gLCBzbyBpdCBjYW4gYmUgc3R5bGVkIHZpYSBhbnkgQ1NTIHNvbHV0aW9uIHlvdSBwcmVmZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdPdmVybGF5XG4gKi9cbmNvbnN0IEZsb2F0aW5nT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nT3ZlcmxheShwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHtcbiAgICBsb2NrU2Nyb2xsID0gZmFsc2UsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxvY2tJZCA9IHVzZUlkKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWxvY2tTY3JvbGwpIHJldHVybjtcbiAgICBhY3RpdmVMb2Nrcy5hZGQobG9ja0lkKTtcbiAgICBjb25zdCBpc0lPUyA9IC9pUChob25lfGFkfG9kKXxpT1MvLnRlc3QoZ2V0UGxhdGZvcm0oKSk7XG4gICAgY29uc3QgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhclxuICAgIGNvbnN0IHNjcm9sbGJhclggPSBNYXRoLnJvdW5kKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHBhZGRpbmdQcm9wID0gc2Nyb2xsYmFyWCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHNjcm9sbFggPSBib2R5U3R5bGUubGVmdCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLmxlZnQpIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFkgPSBib2R5U3R5bGUudG9wID8gcGFyc2VGbG9hdChib2R5U3R5bGUudG9wKSA6IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBib2R5U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgIGJvZHlTdHlsZVtwYWRkaW5nUHJvcF0gPSBzY3JvbGxiYXJXaWR0aCArIFwicHhcIjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGlPUyBkb2Vzbid0IHJlc3BlY3QgYG92ZXJmbG93OiBoaWRkZW5gIG9uIGRvY3VtZW50LmJvZHksIGFuZCB0aGlzXG4gICAgLy8gdGVjaG5pcXVlIGhhcyBmZXdlciBzaWRlIGVmZmVjdHMuXG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICB2YXIgX3dpbmRvdyR2aXN1YWxWaWV3cG9yLCBfd2luZG93JHZpc3VhbFZpZXdwb3IyO1xuICAgICAgLy8gaU9TIDEyIGRvZXMgbm90IHN1cHBvcnQgYHZpc3VhbFZpZXdwb3J0YC5cbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvciA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3Bvci5vZmZzZXRMZWZ0KSB8fCAwO1xuICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IyID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yMi5vZmZzZXRUb3ApIHx8IDA7XG4gICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgdG9wOiAtKHNjcm9sbFkgLSBNYXRoLmZsb29yKG9mZnNldFRvcCkpICsgXCJweFwiLFxuICAgICAgICBsZWZ0OiAtKHNjcm9sbFggLSBNYXRoLmZsb29yKG9mZnNldExlZnQpKSArIFwicHhcIixcbiAgICAgICAgcmlnaHQ6ICcwJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhY3RpdmVMb2Nrcy5kZWxldGUobG9ja0lkKTtcbiAgICAgIGlmIChhY3RpdmVMb2Nrcy5zaXplID09PSAwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgICAgcmlnaHQ6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2xvY2tJZCwgbG9ja1Njcm9sbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgLi4ucmVzdC5zdHlsZVxuICAgIH1cbiAgfSkpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xufVxuZnVuY3Rpb24gaXNTcGFjZUlnbm9yZWQoZWxlbWVudCkge1xuICByZXR1cm4gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG4vKipcbiAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGNsaWNraW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGlja1xuICovXG5mdW5jdGlvbiB1c2VDbGljayhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBldmVudDogZXZlbnRPcHRpb24gPSAnY2xpY2snLFxuICAgIHRvZ2dsZSA9IHRydWUsXG4gICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICBrZXlib2FyZEhhbmRsZXJzID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGRpZEtleURvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgYnV0dG9ucyBleGNlcHQgZm9yIHRoZSBcIm1haW5cIiBidXR0b24uXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlICYmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlID09PSAnbW91c2Vkb3duJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzdGVhbGluZyBmb2N1cyBmcm9tIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdtb3VzZWRvd24nICYmIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQsIHRydWUpICYmIGlnbm9yZU1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiAhaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB8fCBpc1NwYWNlSWdub3JlZChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiBkaWRLZXlEb3duUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZGF0YVJlZiwgZXZlbnRPcHRpb24sIGlnbm9yZU1vdXNlLCBrZXlib2FyZEhhbmRsZXJzLCBkb21SZWZlcmVuY2UsIHRvZ2dsZSwgb3Blbiwgb25PcGVuQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbVJlZiwgZGF0YSkge1xuICBsZXQgb2Zmc2V0WCA9IG51bGw7XG4gIGxldCBvZmZzZXRZID0gbnVsbDtcbiAgbGV0IGlzQXV0b1VwZGF0ZUV2ZW50ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29udGV4dEVsZW1lbnQ6IGRvbVJlZi5jdXJyZW50IHx8IHVuZGVmaW5lZCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICB2YXIgX2RvbVJlZiRjdXJyZW50LCBfZGF0YSRkYXRhUmVmJGN1cnJlbnQ7XG4gICAgICBjb25zdCBkb21SZWN0ID0gKChfZG9tUmVmJGN1cnJlbnQgPSBkb21SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb21SZWYkY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgfHwge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3gnIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3knIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUgPSBbJ21vdXNlZW50ZXInLCAnbW91c2Vtb3ZlJ10uaW5jbHVkZXMoKChfZGF0YSRkYXRhUmVmJGN1cnJlbnQgPSBkYXRhLmRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRkYXRhUmVmJGN1cnJlbnQudHlwZSkgfHwgJycpICYmIGRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCc7XG4gICAgICBsZXQgd2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgbGV0IHggPSBkb21SZWN0Lng7XG4gICAgICBsZXQgeSA9IGRvbVJlY3QueTtcbiAgICAgIGlmIChvZmZzZXRYID09IG51bGwgJiYgZGF0YS54ICYmIGlzWEF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WCA9IGRvbVJlY3QueCAtIGRhdGEueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRZID09IG51bGwgJiYgZGF0YS55ICYmIGlzWUF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WSA9IGRvbVJlY3QueSAtIGRhdGEueTtcbiAgICAgIH1cbiAgICAgIHggLT0gb2Zmc2V0WCB8fCAwO1xuICAgICAgeSAtPSBvZmZzZXRZIHx8IDA7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc0F1dG9VcGRhdGVFdmVudCB8fCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IDA7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiAwO1xuICAgICAgICB4ID0gaXNYQXhpcyAmJiBkYXRhLnggIT0gbnVsbCA/IGRhdGEueCA6IHg7XG4gICAgICAgIHkgPSBpc1lBeGlzICYmIGRhdGEueSAhPSBudWxsID8gZGF0YS55IDogeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdXRvVXBkYXRlRXZlbnQgJiYgIWNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogd2lkdGg7XG4gICAgICB9XG4gICAgICBpc0F1dG9VcGRhdGVFdmVudCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgICAgbGVmdDogeFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc01vdXNlQmFzZWRFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgIT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGw7XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCByZWxhdGl2ZSB0byBhIGNsaWVudCBwb2ludCAoaW4gdGhlIHZpZXdwb3J0KSxcbiAqIHN1Y2ggYXMgdGhlIG1vdXNlIHBvc2l0aW9uLiBCeSBkZWZhdWx0LCBpdCBmb2xsb3dzIHRoZSBtb3VzZSBjdXJzb3IuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpZW50UG9pbnRcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpZW50UG9pbnQoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIHJlZnMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgYXhpcyA9ICdib3RoJyxcbiAgICB4ID0gbnVsbCxcbiAgICB5ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbGVhbnVwTGlzdGVuZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwb2ludGVyVHlwZSwgc2V0UG9pbnRlclR5cGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgW3JlYWN0aXZlLCBzZXRSZWFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IHVzZUVmZmVjdEV2ZW50KCh4LCB5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBzZXR0aW5nIGlmIHRoZSBvcGVuIGV2ZW50IHdhcyBub3QgYSBtb3VzZS1saWtlIG9uZVxuICAgIC8vIChlLmcuIGZvY3VzIHRvIG9wZW4sIHRoZW4gaG92ZXIgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQpLlxuICAgIC8vIE9ubHkgYXBwbHkgaWYgdGhlIGV2ZW50IGV4aXN0cy5cbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiAhaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShjcmVhdGVWaXJ0dWFsRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZSwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBheGlzLFxuICAgICAgZGF0YVJlZixcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKCFjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBjbGVhbnVwLCB0aGVyZSdzIG5vIGxpc3RlbmVyLCBidXQgd2Ugd2FudCB0byBlbnN1cmVcbiAgICAgIC8vIHdlIGFkZCB0aGUgbGlzdGVuZXIgaWYgdGhlIGN1cnNvciBsYW5kZWQgb24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgYW5kXG4gICAgICAvLyB0aGVuIGJhY2sgb24gdGhlIHJlZmVyZW5jZSAoaS5lLiBpdCdzIGludGVyYWN0aXZlKS5cbiAgICAgIHNldFJlYWN0aXZlKFtdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBwb2ludGVyIGlzIGEgbW91c2UtbGlrZSBwb2ludGVyLCB3ZSB3YW50IHRvIGNvbnRpbnVlIGZvbGxvd2luZyB0aGVcbiAgLy8gbW91c2UgZXZlbiBpZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nIG91dC4gT24gdG91Y2hcbiAgLy8gZGV2aWNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdpbGwgbW92ZSB0b1xuICAvLyB0aGUgZGlzbWlzc2FsIHRvdWNoIHBvaW50LlxuICBjb25zdCBvcGVuQ2hlY2sgPSBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSA/IGZsb2F0aW5nIDogb3BlbjtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHhgL2B5YCBjb29yZGluYXRlcyBzaG91bGRuJ3QgYWRkIGEgbGlzdGVuZXIuXG4gICAgaWYgKCFvcGVuQ2hlY2sgfHwgIWVuYWJsZWQgfHwgeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICghY29udGFpbnMocmVmcy5mbG9hdGluZy5jdXJyZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCB8fCBpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gY2xlYW51cDtcbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICB9LCBbZGF0YVJlZiwgZW5hYmxlZCwgb3BlbkNoZWNrLCByZWZzLCBzZXRSZWZlcmVuY2UsIHgsIHldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2UsXG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChmbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBkb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnYW5jZXN0b3Itc2Nyb2xsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChyZWZlcmVuY2UpICYmIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXNjYXBlS2V5ICYmIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCByZWZlcmVuY2UsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgW2J1YmJsZUhhbmRsZXJLZXlzW3JlZmVyZW5jZVByZXNzRXZlbnRdXTogZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChyZWZlcmVuY2VQcmVzcykge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ3JlZmVyZW5jZS1wcmVzcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgICAgIG9uTW91c2VEb3duKCkge1xuICAgICAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlVXAoKSB7XG4gICAgICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIFtjYXB0dXJlSGFuZGxlcktleXNbb3V0c2lkZVByZXNzRXZlbnRdXTogKCkgPT4ge1xuICAgICAgICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByZWZlcmVuY2VQcmVzcywgb3V0c2lkZVByZXNzRXZlbnQsIHJlZmVyZW5jZVByZXNzRXZlbnQsIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkVzY2FwZUtleURvd25dKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudCBhbmQgY29udGV4dCB0byBhZGQgaW50ZXJhY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnRzO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuID0gZmFsc2UsXG4gICAgb25PcGVuQ2hhbmdlOiB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbX2RvbVJlZmVyZW5jZSwgc2V0RG9tUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcG9zaXRpb25SZWZlcmVuY2UsIF9zZXRQb3NpdGlvblJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgb3B0aW9uRG9tUmVmZXJlbmNlID0gKF9vcHRpb25zJGVsZW1lbnRzID0gb3B0aW9ucy5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzLnJlZmVyZW5jZTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlID0gb3B0aW9uRG9tUmVmZXJlbmNlIHx8IF9kb21SZWZlcmVuY2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAob3B0aW9uRG9tUmVmZXJlbmNlICYmICFpc0VsZW1lbnQob3B0aW9uRG9tUmVmZXJlbmNlKSkge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBwYXNzIGEgdmlydHVhbCBlbGVtZW50IHRvIHRoZSBgZWxlbWVudHMucmVmZXJlbmNlYCBvcHRpb24sJywgJ2FzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiBVc2UgYHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoKWAnLCAnaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkb21SZWZlcmVuY2UpIHtcbiAgICAgIGRvbVJlZmVyZW5jZVJlZi5jdXJyZW50ID0gZG9tUmVmZXJlbmNlO1xuICAgIH1cbiAgfSwgW2RvbVJlZmVyZW5jZV0pO1xuICBjb25zdCBwb3NpdGlvbiA9IHVzZUZsb2F0aW5nJDEoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIC4uLm9wdGlvbnMuZWxlbWVudHMsXG4gICAgICAuLi4ocG9zaXRpb25SZWZlcmVuY2UgJiYge1xuICAgICAgICByZWZlcmVuY2U6IHBvc2l0aW9uUmVmZXJlbmNlXG4gICAgICB9KVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgbmVzdGVkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKSAhPSBudWxsO1xuICBjb25zdCBvbk9wZW5DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCgob3BlbiwgZXZlbnQsIHJlYXNvbikgPT4ge1xuICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBvcGVuID8gZXZlbnQgOiB1bmRlZmluZWQ7XG4gICAgZXZlbnRzLmVtaXQoJ29wZW5jaGFuZ2UnLCB7XG4gICAgICBvcGVuLFxuICAgICAgZXZlbnQsXG4gICAgICByZWFzb24sXG4gICAgICBuZXN0ZWRcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UgPT0gbnVsbCB8fCB1bnN0YWJsZV9vbk9wZW5DaGFuZ2Uob3BlbiwgZXZlbnQsIHJlYXNvbik7XG4gIH0pO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IGNvbXB1dGVkUG9zaXRpb25SZWZlcmVuY2UgPSBpc0VsZW1lbnQobm9kZSkgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBjb250ZXh0RWxlbWVudDogbm9kZVxuICAgIH0gOiBub2RlO1xuICAgIC8vIFN0b3JlIHRoZSBwb3NpdGlvblJlZmVyZW5jZSBpbiBzdGF0ZSBpZiB0aGUgRE9NIHJlZmVyZW5jZSBpcyBzcGVjaWZpZWQgZXh0ZXJuYWxseSB2aWEgdGhlXG4gICAgLy8gYGVsZW1lbnRzLnJlZmVyZW5jZWAgb3B0aW9uLiBUaGlzIGVuc3VyZXMgdGhhdCBpdCB3b24ndCBiZSBvdmVycmlkZGVuIG9uIGZ1dHVyZSByZW5kZXJzLlxuICAgIF9zZXRQb3NpdGlvblJlZmVyZW5jZShjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlKTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlKTtcbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKGlzRWxlbWVudChub2RlKSB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBzZXREb21SZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHBhc3NpbmcgYSB2aXJ0dWFsIGVsZW1lbnQgdG8gYHJlZmVyZW5jZWBcbiAgICAvLyBhZnRlciBpdCBoYXMgc2V0IHRoZSBET00gcmVmZXJlbmNlLlxuICAgIGlmIChpc0VsZW1lbnQocG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCkgfHwgcG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCA9PT0gbnVsbCB8fFxuICAgIC8vIERvbid0IGFsbG93IHNldHRpbmcgdmlydHVhbCBlbGVtZW50cyB1c2luZyB0aGUgb2xkIHRlY2huaXF1ZSBiYWNrIHRvXG4gICAgLy8gYG51bGxgIHRvIHN1cHBvcnQgYHBvc2l0aW9uUmVmZXJlbmNlYCArIGFuIHVuc3RhYmxlIGByZWZlcmVuY2VgXG4gICAgLy8gY2FsbGJhY2sgcmVmLlxuICAgIG5vZGUgIT09IG51bGwgJiYgIWlzRWxlbWVudChub2RlKSkge1xuICAgICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbcG9zaXRpb24ucmVmc10pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLnJlZnMsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldFBvc2l0aW9uUmVmZXJlbmNlLFxuICAgIGRvbVJlZmVyZW5jZTogZG9tUmVmZXJlbmNlUmVmXG4gIH0pLCBbcG9zaXRpb24ucmVmcywgc2V0UmVmZXJlbmNlLCBzZXRQb3NpdGlvblJlZmVyZW5jZV0pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5lbGVtZW50cyxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uLmVsZW1lbnRzLCBkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgbm9kZUlkLFxuICAgIGZsb2F0aW5nSWQsXG4gICAgZXZlbnRzLFxuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlXG4gIH0pLCBbcG9zaXRpb24sIG5vZGVJZCwgZmxvYXRpbmdJZCwgZXZlbnRzLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGVsZW1lbnRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgY29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzXG4gIH0pLCBbcG9zaXRpb24sIHJlZnMsIGVsZW1lbnRzLCBjb250ZXh0XSk7XG59XG5cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBmb2N1cywgbGlrZSBDU1NcbiAqIGA6Zm9jdXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZvY3VzXG4gKi9cbmZ1bmN0aW9uIHVzZUZvY3VzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICB2aXNpYmxlT25seSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBibG9ja0ZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBrZXlib2FyZE1vZGFsaXR5UmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tUmVmZXJlbmNlKTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2Ugd2FzIGZvY3VzZWQgYW5kIHRoZSB1c2VyIGxlZnQgdGhlIHRhYi93aW5kb3csIGFuZCB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHdhcyBub3Qgb3BlbiwgdGhlIGZvY3VzIHNob3VsZCBiZSBibG9ja2VkIHdoZW4gdGhleVxuICAgIC8vIHJldHVybiB0byB0aGUgdGFiL3dpbmRvdy5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoIW9wZW4gJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpICYmIGRvbVJlZmVyZW5jZSA9PT0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChkb21SZWZlcmVuY2UpKSkge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbktleURvd24oKSB7XG4gICAgICBrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1cik7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgb3BlbiwgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdyZWZlcmVuY2UtcHJlc3MnIHx8IHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtldmVudHMsIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIGlmIChpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSByZXR1cm47XG4gICAgICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1cyhldmVudCkge1xuICAgICAgICAgIGlmIChibG9ja0ZvY3VzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICAgIGlmICh2aXNpYmxlT25seSAmJiBpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gTWFjIFNhZmFyaSB1bnJlbGlhYmx5IG1hdGNoZXMgYDpmb2N1cy12aXNpYmxlYCBvbiB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIC8vIGlmIGZvY3VzIHdhcyBvdXRzaWRlIHRoZSBwYWdlIGluaXRpYWxseSAtIHVzZSB0aGUgZmFsbGJhY2tcbiAgICAgICAgICAgICAgLy8gaW5zdGVhZC5cbiAgICAgICAgICAgICAgaWYgKGlzU2FmYXJpKCkgJiYgaXNNYWMoKSkgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXQubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkgcmV0dXJuO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAvLyBPbGQgYnJvd3NlcnMgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIHVzaW5nIGA6Zm9jdXMtdmlzaWJsZWAuXG4gICAgICAgICAgICAgIGlmICgha2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ICYmICFpc1R5cGVhYmxlRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cihldmVudCkge1xuICAgICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgICAgLy8gSGl0IHRoZSBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudCBwb3J0YWwgZ3VhcmQuIEZvY3VzIHdpbGwgYmVcbiAgICAgICAgICAvLyBtb3ZlZCBpbnRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgICAgICAgIGNvbnN0IG1vdmVkVG9Gb2N1c0d1YXJkID0gaXNFbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgJiYgcmVsYXRlZFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnb3V0c2lkZSc7XG5cbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2luZG93IGJsdXIgbGlzdGVuZXIgdG8gZmlyZS5cbiAgICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZG9tUmVmZXJlbmNlID8gZG9tUmVmZXJlbmNlLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCk7XG5cbiAgICAgICAgICAgIC8vIEZvY3VzIGxlZnQgdGhlIHBhZ2UsIGtlZXAgaXQgb3Blbi5cbiAgICAgICAgICAgIGlmICghcmVsYXRlZFRhcmdldCAmJiBhY3RpdmVFbCA9PT0gZG9tUmVmZXJlbmNlKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIFdoZW4gZm9jdXNpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50IChlLmcuIHJlZ3VsYXIgY2xpY2spLCB0aGVuXG4gICAgICAgICAgICAvLyBjbGlja2luZyBpbnRvIHRoZSBmbG9hdGluZyBlbGVtZW50LCBwcmV2ZW50IGl0IGZyb20gaGlkaW5nLlxuICAgICAgICAgICAgLy8gTm90ZTogaXQgbXVzdCBiZSBmb2N1c2FibGUsIGUuZy4gYHRhYmluZGV4PVwiLTFcImAuXG4gICAgICAgICAgICAvLyBXZSBjYW4gbm90IHJlbHkgb24gcmVsYXRlZFRhcmdldCB0byBwb2ludCB0byB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgICAgICAvLyBhcyBpdCB3aWxsIG9ubHkgcG9pbnQgdG8gdGhlIHNoYWRvdyBob3N0IG9mIHRoZSBuZXdseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGFuZCBub3QgdGhlIGVsZW1lbnQgdGhhdCBhY3R1YWxseSBoYXMgcmVjZWl2ZWQgZm9jdXMgaWYgaXQgaXMgbG9jYXRlZFxuICAgICAgICAgICAgLy8gaW5zaWRlIGEgc2hhZG93IHJvb3QuXG4gICAgICAgICAgICBpZiAoY29udGFpbnMocmVmcy5mbG9hdGluZy5jdXJyZW50LCBhY3RpdmVFbCkgfHwgY29udGFpbnMoZG9tUmVmZXJlbmNlLCBhY3RpdmVFbCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgdmlzaWJsZU9ubHksIGRvbVJlZmVyZW5jZSwgcmVmcywgb25PcGVuQ2hhbmdlXSk7XG59XG5cbmNvbnN0IEFDVElWRV9LRVkgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVEVEX0tFWSA9ICdzZWxlY3RlZCc7XG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gJ2l0ZW0nO1xuICBsZXQgZG9tVXNlclByb3BzID0gdXNlclByb3BzO1xuICBpZiAoaXNJdGVtICYmIHVzZXJQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIFtBQ1RJVkVfS0VZXTogXyxcbiAgICAgIFtTRUxFQ1RFRF9LRVldOiBfXyxcbiAgICAgIC4uLnZhbGlkUHJvcHNcbiAgICB9ID0gdXNlclByb3BzO1xuICAgIGRvbVVzZXJQcm9wcyA9IHZhbGlkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi4oZWxlbWVudEtleSA9PT0gJ2Zsb2F0aW5nJyAmJiB7XG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9KSxcbiAgICAuLi5kb21Vc2VyUHJvcHMsXG4gICAgLi4ucHJvcHNMaXN0Lm1hcCh2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBwcm9wc09yR2V0UHJvcHMgPSB2YWx1ZSA/IHZhbHVlW2VsZW1lbnRLZXldIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNPckdldFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB1c2VyUHJvcHMgPyBwcm9wc09yR2V0UHJvcHModXNlclByb3BzKSA6IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcHNPckdldFByb3BzO1xuICAgIH0pLmNvbmNhdCh1c2VyUHJvcHMpLnJlZHVjZSgoYWNjLCBwcm9wcykgPT4ge1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmVudHJpZXMocHJvcHMpLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgICBpZiAoaXNJdGVtICYmIFtBQ1RJVkVfS0VZLCBTRUxFQ1RFRF9LRVldLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdvbicpID09PSAwKSB7XG4gICAgICAgICAgaWYgKCFtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgICAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCB8fCBfbWFwJGdldC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGFjY1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoX21hcCRnZXQyID0gbWFwLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLm1hcChmbiA9PiBmbiguLi5hcmdzKSkuZmluZCh2YWwgPT4gdmFsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KVxuICB9O1xufVxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuICBjb25zdCBnZXRSZWZlcmVuY2VQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAncmVmZXJlbmNlJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEZsb2F0aW5nUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2Zsb2F0aW5nJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEl0ZW1Qcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnaXRlbScpLFxuICAvLyBHcmFudWxhcmx5IGNoZWNrIGZvciBgaXRlbWAgY2hhbmdlcywgYmVjYXVzZSB0aGUgYGdldEl0ZW1Qcm9wc2AgZ2V0dGVyXG4gIC8vIHNob3VsZCBiZSBhcyByZWZlcmVudGlhbGx5IHN0YWJsZSBhcyBwb3NzaWJsZSBzaW5jZSBpdCBtYXkgYmUgcGFzc2VkIGFzXG4gIC8vIGEgcHJvcCB0byBtYW55IGNvbXBvbmVudHMuIEFsbCBgaXRlbWAga2V5IHZhbHVlcyBtdXN0IHRoZXJlZm9yZSBiZVxuICAvLyBtZW1vaXplZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZSxcbiAgICB2aXJ0dWFsSXRlbVJlZixcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICB3YXJuKCdgdXNlTGlzdE5hdmlnYXRpb25gIGxvb3BpbmcgbXVzdCBiZSBlbmFibGVkIHRvIGFsbG93IGVzY2FwaW5nLicpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIHdhcm4oJ2B1c2VMaXN0TmF2aWdhdGlvbmAgbXVzdCBiZSB2aXJ0dWFsIHRvIGFsbG93IGVzY2FwaW5nLicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIHdhcm4oJ0luIGdyaWQgbGlzdCBuYXZpZ2F0aW9uIG1vZGUgKGBjb2xzYCA+IDEpLCB0aGUgYG9yaWVudGF0aW9uYCBzaG91bGQnLCAnYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwiYm90aFwiLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFmbG9hdGluZyk7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBpdGVtKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5IGluIG9yZGVyIHRvIHByZXZlbnQgdW53YW50ZWRcbiAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgLy8gc3Vic2VxdWVudCBjYWxscy4gYHByZXZlbnRTY3JvbGxgIGlzIHN1cHBvcnRlZCBpbiBtb2Rlcm4gU2FmYXJpLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgIHN5bmM6IGlzTWFjKCkgJiYgaXNTYWZhcmkoKSA/IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCB8fCBmb3JjZVN5bmNGb2N1cy5jdXJyZW50IDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShzZWxlY3RlZEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB0aGUgdXNlciBjYW4gc3BlY2lmeSBgb25OYXZpZ2F0ZWAgY29uZGl0aW9uYWxseVxuICAgICAgLy8gKG9uTmF2aWdhdGU6IG9wZW4gPyBzZXRBY3RpdmVJbmRleCA6IHNldFNlbGVjdGVkSW5kZXgpLFxuICAgICAgLy8gd2Ugc3RvcmUgYW5kIGNhbGwgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQobnVsbCk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmcsIHNlbGVjdGVkSW5kZXgsIG9uTmF2aWdhdGVdKTtcblxuICAvLyBTeW5jIGBhY3RpdmVJbmRleGAgdG8gYmUgdGhlIGZvY3VzZWQgaXRlbSB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICAvLyBvcGVuLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICghcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgICAgY29uc3Qgd2FpdEZvckxpc3RQb3B1bGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgbGV0dGluZyB0aGUgYnJvd3NlciBwYWludCBpZiBwb3NzaWJsZSBvbiB0aGUgZmlyc3QgdHJ5LFxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHJBRi4gRG9uJ3QgdHJ5IG1vcmUgdGhhbiB0d2ljZSwgc2luY2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgaWYgKHJ1bnMgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gcnVucyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVucysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGtleVJlZi5jdXJyZW50ID09IG51bGwgfHwgaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXlSZWYuY3VycmVudCwgb3JpZW50YXRpb24sIHJ0bCkgfHwgbmVzdGVkID8gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpIDogZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0Rm9yTGlzdFBvcHVsYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXgsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX25vZGVzJGZpbmQ7XG4gICAgaWYgKCFlbmFibGVkIHx8IGZsb2F0aW5nIHx8ICF0cmVlIHx8IHZpcnR1YWwgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF9ub2RlcyRmaW5kID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgaWYgKHBhcmVudCAmJiAhdHJlZUNvbnRhaW5zQWN0aXZlRWwgJiYgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCkge1xuICAgICAgcGFyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkLCB2aXJ0dWFsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXRyZWUgfHwgIXZpcnR1YWwgfHwgcGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCA9ICEhZmxvYXRpbmc7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gU2FmYXJpXG4gICAgICAuLi4oZm9jdXNJdGVtT25Ib3ZlciAmJiB7XG4gICAgICAgIG9uTW91c2VNb3ZlKF9yZWYzKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckxlYXZlKF9yZWY0KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKHJlZnMuZmxvYXRpbmcuY3VycmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtvcGVuLCByZWZzLCBmb2N1c0l0ZW0sIGZvY3VzSXRlbU9uSG92ZXIsIGxpc3RSZWYsIG9uTmF2aWdhdGUsIHZpcnR1YWxdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBkaXNhYmxlZEluZGljZXMgPSBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudDtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgICAgLy8gdGhlIGBhY3RpdmVJbmRleGAgZ2V0cyBzZXQgdG8gMCBkZXNwaXRlIG5vdCBiZWluZyBvcGVuIHNvIHRoZSBuZXh0IHRpbWVcbiAgICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSByZWZzLmZsb2F0aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZCAmJiBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIGRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICAgIH0sICgpID0+ICh7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhKGRpc2FibGVkSW5kaWNlcyAhPSBudWxsICYmIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkpKTtcbiAgICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgbG9vcCxcbiAgICAgICAgICBjb2xzLFxuICAgICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0Q2VsbEluZGljZXMoWy4uLihkaXNhYmxlZEluZGljZXMgfHwgW10pLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gd2UncmUgbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCA/ICd0cicgOiAndGwnKSxcbiAgICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgICAgfSldOyAvLyBuYXZpZ2F0ZWQgY2VsbCB3aWxsIG5ldmVyIGJlIG51bGxpc2hcblxuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AgPSB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGxpc3RSZWYuY3VycmVudC5maW5kKGl0ZW0gPT4gKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpID09PSBhY3RpdmVJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LmluZGV4T2YoJ0Fycm93JykgPT09IDA7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc0Nsb3NlS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSAobmVzdGVkID8gaXNDcm9zc09wZW5LZXkgOiBpc01haW5LZXkpIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkudHJpbSgpID09PSAnJztcbiAgICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBlc3ROb2RlID0gdHJlZSAmJiByb290Tm9kZSA/IGdldERlZXBlc3ROb2RlKHRyZWUubm9kZXNSZWYuY3VycmVudCwgcm9vdE5vZGUuaWQpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0Fycm93S2V5ICYmIGRlZXBlc3ROb2RlICYmIHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCwgX2RlZXBlc3ROb2RlJGNvbnRleHQyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFRhcmdldCA9ICgoX2RlZXBlc3ROb2RlJGNvbnRleHQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gYWN0aXZlSXRlbSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoSXRlbSkge1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHNldFZpcnR1YWxJZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNNYWluS2V5ICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcGVzdE5vZGUuY29udGV4dC5vcGVuICYmIGRlZXBlc3ROb2RlLnBhcmVudElkICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQkO1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIChfZGVlcGVzdE5vZGUkY29udGV4dCQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCB8fCBfZGVlcGVzdE5vZGUkY29udGV4dCQuZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbmVzdGVkICYmIGlzTWFpbktleSA/IG51bGwgOiBldmVudC5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSkge1xuICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKCkge1xuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgICAuLi4oIWlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCksXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZW1cbiAgICB9O1xuICB9LCBbZG9tUmVmZXJlbmNlLCByZWZzLCBhY3RpdmVJZCwgdmlydHVhbElkLCBkaXNhYmxlZEluZGljZXNSZWYsIGxhdGVzdE9wZW5SZWYsIGxpc3RSZWYsIGVuYWJsZWQsIG9yaWVudGF0aW9uLCBydGwsIHZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCBuZXN0ZWQsIHNlbGVjdGVkSW5kZXgsIG9wZW5PbkFycm93S2V5RG93biwgYWxsb3dFc2NhcGUsIGNvbHMsIGxvb3AsIGZvY3VzSXRlbU9uT3Blbiwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBpdGVtLCB0cmVlLCB2aXJ0dWFsSXRlbVJlZiwgaXRlbVNpemVzLCBkZW5zZV0pO1xufVxuXG5jb25zdCBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKFtbJ3NlbGVjdCcsICdsaXN0Ym94J10sIFsnY29tYm9ib3gnLCAnbGlzdGJveCddLCBbJ2xhYmVsJywgZmFsc2VdXSk7XG5cbi8qKlxuICogQWRkcyBiYXNlIHNjcmVlbiByZWFkZXIgcHJvcHMgdG8gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmcgZWxlbWVudHMgZm9yIGFcbiAqIGdpdmVuIGZsb2F0aW5nIGVsZW1lbnQgYHJvbGVgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVJvbGVcbiAqL1xuZnVuY3Rpb24gdXNlUm9sZShjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX2NvbXBvbmVudFJvbGVUb0FyaWFSO1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHJvbGUgPSAnZGlhbG9nJ1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFyaWFSb2xlID0gKF9jb21wb25lbnRSb2xlVG9BcmlhUiA9IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwLmdldChyb2xlKSkgIT0gbnVsbCA/IF9jb21wb25lbnRSb2xlVG9BcmlhUiA6IHJvbGU7XG4gIGNvbnN0IHJlZmVyZW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBpc05lc3RlZCA9IHBhcmVudElkICE9IG51bGw7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiB7fTtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICAuLi4oYXJpYVJvbGUgJiYge1xuICAgICAgICByb2xlOiBhcmlhUm9sZVxuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIFtcImFyaWEtXCIgKyAocm9sZSA9PT0gJ2xhYmVsJyA/ICdsYWJlbGxlZGJ5JyA6ICdkZXNjcmliZWRieScpXTogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGZsb2F0aW5nUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiBhcmlhUm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJyA/ICdkaWFsb2cnIDogYXJpYVJvbGUsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgICByb2xlOiAnY29tYm9ib3gnXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgaWQ6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgICAgcm9sZTogJ21lbnVpdGVtJ1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbm9uZSdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCdcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAuLi5mbG9hdGluZ1Byb3BzLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgaXRlbShfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItb3B0aW9uXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgICAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgICAgIC8vIGF2b2lkIGRlZmF1bHRpbmcgdG8gYG1lbnVpdGVtYCBhcyBpdCBtYXkgb3ZlcndyaXRlIGN1c3RvbSByb2xlIHByb3BzLlxuICAgICAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBhcmlhUm9sZSwgb3BlbiwgZmxvYXRpbmdJZCwgcmVmZXJlbmNlSWQsIGlzTmVzdGVkXSk7XG59XG5cbi8vIENvbnZlcnRzIGEgSlMgc3R5bGUga2V5IGxpa2UgYGJhY2tncm91bmRDb2xvcmAgdG8gYSBDU1MgdHJhbnNpdGlvbi1wcm9wZXJ0eVxuLy8gbGlrZSBgYmFja2dyb3VuZC1jb2xvcmAuXG5jb25zdCBjYW1lbENhc2VUb0tlYmFiQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csICgkLCBvZnMpID0+IChvZnMgPyAnLScgOiAnJykgKyAkLnRvTG93ZXJDYXNlKCkpO1xuZnVuY3Rpb24gZXhlY1dpdGhBcmdzT3JSZXR1cm4odmFsdWVPckZuLCBhcmdzKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVPckZuID09PSAnZnVuY3Rpb24nID8gdmFsdWVPckZuKGFyZ3MpIDogdmFsdWVPckZuO1xufVxuZnVuY3Rpb24gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGR1cmF0aW9uTXMpIHtcbiAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKG9wZW4pO1xuICBpZiAob3BlbiAmJiAhaXNNb3VudGVkKSB7XG4gICAgc2V0SXNNb3VudGVkKHRydWUpO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc01vdW50ZWQoZmFsc2UpLCBkdXJhdGlvbk1zKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbb3BlbiwgZHVyYXRpb25Nc10pO1xuICByZXR1cm4gaXNNb3VudGVkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIHN0YXR1cyBzdHJpbmcgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCxcbiAqIGNvcnJlY3RseSBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbaW5pdGlhdGVkLCBzZXRJbml0aWF0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3QudXNlU3RhdGUoJ3VubW91bnRlZCcpO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VEZWxheVVubW91bnQob3BlbiwgY2xvc2VEdXJhdGlvbik7XG5cbiAgLy8gYGluaXRpYXRlZGAgY2hlY2sgcHJldmVudHMgdGhpcyBgc2V0U3RhdGVgIGNhbGwgZnJvbSBicmVha2luZ1xuICAvLyA8RmxvYXRpbmdQb3J0YWwgLz4uIFRoaXMgY2FsbCBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHN1YnNlcXVlbnQgb3BlbnNcbiAgLy8gYWZ0ZXIgdGhlIGluaXRpYWwgb25lIGFsbG93cyB0aGUgY29ycmVjdCBzaWRlIGFuaW1hdGlvbiB0byBwbGF5IHdoZW4gdGhlXG4gIC8vIHBsYWNlbWVudCBoYXMgY2hhbmdlZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpbml0aWF0ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgc2V0U3RhdHVzKCd1bm1vdW50ZWQnKTtcbiAgICB9XG4gIH0sIFtpbml0aWF0ZWQsIGlzTW91bnRlZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U3RhdHVzKCdvcGVuJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHNldEluaXRpYXRlZCh0cnVlKTtcbiAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gIH0sIFtvcGVuLCBmbG9hdGluZ10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgc3R5bGVzIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsIGNvcnJlY3RseVxuICogaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLiBXcmFwcGVyIGFyb3VuZCBgdXNlVHJhbnNpdGlvblN0YXR1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdHlsZXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsOiB1bnN0YWJsZV9pbml0aWFsID0ge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgb3BlbjogdW5zdGFibGVfb3BlbixcbiAgICBjbG9zZTogdW5zdGFibGVfY2xvc2UsXG4gICAgY29tbW9uOiB1bnN0YWJsZV9jb21tb24sXG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBjb250ZXh0LnBsYWNlbWVudDtcbiAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbkFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2lkZSxcbiAgICBwbGFjZW1lbnRcbiAgfSksIFtzaWRlLCBwbGFjZW1lbnRdKTtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IG9wZW5EdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5vcGVuKSB8fCAwO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbc3R5bGVzLCBzZXRTdHlsZXNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9jb21tb24sIGZuQXJncyksXG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfaW5pdGlhbCwgZm5BcmdzKVxuICB9KSk7XG4gIGNvbnN0IHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH0gPSB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvblxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9pbml0aWFsKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9vcGVuKTtcbiAgY29uc3QgY2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY2xvc2UpO1xuICBjb25zdCBjb21tb25SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY29tbW9uKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihpbml0aWFsUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY2xvc2VTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjbG9zZVJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNvbW1vblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNvbW1vblJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IG9wZW5TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihvcGVuUmVmLmN1cnJlbnQsIGZuQXJncykgfHwgT2JqZWN0LmtleXMoaW5pdGlhbFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSAnJztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChzdGF0dXMgPT09ICdpbml0aWFsJykge1xuICAgICAgc2V0U3R5bGVzKHN0eWxlcyA9PiAoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHN0eWxlcy50cmFuc2l0aW9uUHJvcGVydHksXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnb3BlbicpIHtcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMob3BlblN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogb3BlbkR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLm9wZW5TdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBjbG9zZVN0eWxlcyB8fCBpbml0aWFsU3R5bGVzO1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhzdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGNsb3NlRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjbG9zZUR1cmF0aW9uLCBjbG9zZVJlZiwgaW5pdGlhbFJlZiwgb3BlblJlZiwgY29tbW9uUmVmLCBvcGVuRHVyYXRpb24sIHN0YXR1cywgZm5BcmdzXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0eWxlc1xuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbWF0Y2hpbmcgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byBmb2N1cyBhbiBpdGVtIGFzIHRoZSB1c2VyXG4gKiB0eXBlcywgb2Z0ZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb24oKWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHlwZWFoZWFkXG4gKi9cbmZ1bmN0aW9uIHVzZVR5cGVhaGVhZChjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX3JlZjtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25NYXRjaDogdW5zdGFibGVfb25NYXRjaCxcbiAgICBvblR5cGluZ0NoYW5nZTogdW5zdGFibGVfb25UeXBpbmdDaGFuZ2UsXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZmluZE1hdGNoID0gbnVsbCxcbiAgICByZXNldE1zID0gNzUwLFxuICAgIGlnbm9yZUtleXMgPSBbXSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBzdHJpbmdSZWYgPSBSZWFjdC51c2VSZWYoJycpO1xuICBjb25zdCBwcmV2SW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoKF9yZWYgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogLTEpO1xuICBjb25zdCBtYXRjaEluZGV4UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvbk1hdGNoID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25NYXRjaCk7XG4gIGNvbnN0IG9uVHlwaW5nQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25UeXBpbmdDaGFuZ2UpO1xuICBjb25zdCBmaW5kTWF0Y2hSZWYgPSB1c2VMYXRlc3RSZWYoZmluZE1hdGNoKTtcbiAgY29uc3QgaWdub3JlS2V5c1JlZiA9IHVzZUxhdGVzdFJlZihpZ25vcmVLZXlzKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHlwaW5nQ2hhbmdlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdHJpbmdSZWYuY3VycmVudC5sZW5ndGggPiAwICYmIHN0cmluZ1JlZi5jdXJyZW50WzBdICE9PSAnICcpIHtcbiAgICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgICAgLy8gTW9kaWZpZXIga2V5LlxuICAgICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlbiAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9LCByZXNldE1zKTtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHByZXZJbmRleFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBbLi4ubGlzdENvbnRlbnQuc2xpY2UoKHByZXZJbmRleCB8fCAwKSArIDEpLCAuLi5saXN0Q29udGVudC5zbGljZSgwLCAocHJldkluZGV4IHx8IDApICsgMSldLCBzdHJpbmdSZWYuY3VycmVudCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTWF0Y2goaW5kZXgpO1xuICAgICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd25cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGRhdGFSZWYsIGxpc3RSZWYsIHJlc2V0TXMsIGlnbm9yZUtleXNSZWYsIGZpbmRNYXRjaFJlZiwgb25NYXRjaCwgb25UeXBpbmdDaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZVxuICogb2YgaXQgaXMgYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IGlubmVyID0gcHJvcHMgPT4gKHtcbiAgbmFtZTogJ2lubmVyJyxcbiAgb3B0aW9uczogcHJvcHMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdFJlZixcbiAgICAgIG92ZXJmbG93UmVmLFxuICAgICAgb25GYWxsYmFja0NoYW5nZSxcbiAgICAgIG9mZnNldDogaW5uZXJPZmZzZXQgPSAwLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIHdhcm4oJ2BwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlIGBpbm5lcmAnLCAnbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgZWwuc2Nyb2xsSGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgZWwuc2Nyb2xsSGVpZ2h0IC0gZGlmZlkgLSBNYXRoLm1heCgwLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgZWwuc2Nyb2xsVG9wID0gZGlmZlk7XG5cbiAgICAvLyBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLCBmYWxsYmFjayB0byBzdGFuZGFyZCBhbmNob3JlZCBwb3NpdGlvbmluZ1xuICAgIGlmIChvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBpZiAoZWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBNYXRoLm1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvd1JlZikge1xuICAgICAgb3ZlcmZsb3dSZWYuY3VycmVudCA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoe1xuICAgICAgICAuLi5uZXh0QXJncyxcbiAgICAgICAgeTogbmV4dFlcbiAgICAgIH0sIGVsLm9mZnNldEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB5OiBuZXh0WVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBgaW5uZXJgIG1pZGRsZXdhcmUncyBgb2Zmc2V0YCB1cG9uIGEgYHdoZWVsYCBldmVudCB0b1xuICogZXhwYW5kIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgaGVpZ2h0LCByZXZlYWxpbmcgbW9yZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbldoZWVsKGUpIHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkWSA9IGUuZGVsdGFZO1xuICAgICAgY29uc3QgaXNBdFRvcCA9IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wID49IC0wLjU7XG4gICAgICBjb25zdCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNpZ24gPSBkWSA8IDAgPyAtMSA6IDE7XG4gICAgICBjb25zdCBtZXRob2QgPSBkWSA8IDAgPyAnbWF4JyA6ICdtaW4nO1xuICAgICAgaWYgKGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGQgPT4gZCArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gcHJvcGFnYXRlIHNjcm9sbGluZyBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsaW5nIHBoYXNlIG9uY2VcbiAgICAgICAgLy8gaXQgZ2V0cyBsaW1pdGVkIGJ5IHRoZSBib3VuZGFyeS4gVVggaW1wcm92ZW1lbnQsIG5vdCBjcml0aWNhbC5cbiAgICAgICAgZWwuc2Nyb2xsVG9wICs9IGRZO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAob3BlbiAmJiBlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5LlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5vdmVyZmxvd1JlZi5jdXJyZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24oKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XaGVlbCgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TY3JvbGwoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBlbC5zY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPCAtMC41ICYmIHNjcm9sbERpZmYgPCAtMSB8fCBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA+IDEpIHtcbiAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvdmVyZmxvd1JlZiwgZWxlbWVudHMuZmxvYXRpbmcsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHRpbWVvdXRJZDtcbiAgbGV0IGhhc0xhbmRlZCA9IGZhbHNlO1xuICBsZXQgbGFzdFggPSBudWxsO1xuICBsZXQgbGFzdFkgPSBudWxsO1xuICBsZXQgbGFzdEN1cnNvclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgZnVuY3Rpb24gZ2V0Q3Vyc29yU3BlZWQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIGxhc3RDdXJzb3JUaW1lO1xuICAgIGlmIChsYXN0WCA9PT0gbnVsbCB8fCBsYXN0WSA9PT0gbnVsbCB8fCBlbGFwc2VkVGltZSA9PT0gMCkge1xuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4IC0gbGFzdFg7XG4gICAgY29uc3QgZGVsdGFZID0geSAtIGxhc3RZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XG4gICAgY29uc3Qgc3BlZWQgPSBkaXN0YW5jZSAvIGVsYXBzZWRUaW1lOyAvLyBweCAvIG1zXG5cbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgcmV0dXJuIHNwZWVkO1xuICB9XG4gIGNvbnN0IGZuID0gX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvbkNsb3NlLFxuICAgICAgbm9kZUlkLFxuICAgICAgdHJlZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGlmICghZWxlbWVudHMuZG9tUmVmZXJlbmNlIHx8ICFlbGVtZW50cy5mbG9hdGluZyB8fCBwbGFjZW1lbnQgPT0gbnVsbCB8fCB4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgY2xpZW50UG9pbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJztcbiAgICAgIGNvbnN0IGlzT3ZlckZsb2F0aW5nRWwgPSBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZUVsID0gY29udGFpbnMoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCB0YXJnZXQpO1xuICAgICAgY29uc3QgcmVmUmVjdCA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50cy5mbG9hdGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID0geCA+IHJlY3QucmlnaHQgLSByZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA9IHkgPiByZWN0LmJvdHRvbSAtIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZVJlY3QgPSBpc0luc2lkZShjbGllbnRQb2ludCwgcmVmUmVjdCk7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nV2lkZXIgPSByZWN0LndpZHRoID4gcmVmUmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdUYWxsZXIgPSByZWN0LmhlaWdodCA+IHJlZlJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3QgbGVmdCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkubGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5yaWdodDtcbiAgICAgIGNvbnN0IHRvcCA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLmJvdHRvbTtcbiAgICAgIGlmIChpc092ZXJGbG9hdGluZ0VsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNMZWF2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsICYmICFpc0xlYXZlKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBmbG9hdGluZyBlbGVtZW50IGZyb20gYmVpbmcgc3R1Y2sgaW4gYW4gb3Blbi1jbG9zZVxuICAgICAgLy8gbG9vcDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xOTEwXG4gICAgICBpZiAoaXNMZWF2ZSAmJiBpc0VsZW1lbnQoZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IG5lc3RlZCBjaGlsZCBpcyBvcGVuLCBhYm9ydC5cbiAgICAgIGlmICh0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQub3BlbjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaXMgbGVhdmluZyBmcm9tIHRoZSBvcHBvc2l0ZSBzaWRlLCB0aGUgXCJidWZmZXJcIiBsb2dpY1xuICAgICAgLy8gY3JlYXRlcyBhIHBvaW50IHdoZXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbWFpbnMgb3BlbiwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gaWdub3JlZC5cbiAgICAgIC8vIEEgY29uc3RhbnQgb2YgMSBoYW5kbGVzIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyAmJiB5ID49IHJlZlJlY3QuYm90dG9tIC0gMSB8fCBzaWRlID09PSAnYm90dG9tJyAmJiB5IDw9IHJlZlJlY3QudG9wICsgMSB8fCBzaWRlID09PSAnbGVmdCcgJiYgeCA+PSByZWZSZWN0LnJpZ2h0IC0gMSB8fCBzaWRlID09PSAncmlnaHQnICYmIHggPD0gcmVmUmVjdC5sZWZ0ICsgMSkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIHdoZW4gdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIHJlY3Rhbmd1bGFyIHRyb3VnaCBiZXR3ZWVuIHRoZVxuICAgICAgLy8gdHdvIGVsZW1lbnRzLiBTaW5jZSB0aGUgdHJpYW5nbGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJzb3IgcG9pbnQsXG4gICAgICAvLyB3aGljaCBjYW4gc3RhcnQgYmV5b25kIHRoZSByZWYgZWxlbWVudCdzIGVkZ2UsIHRyYXZlcnNpbmcgYmFjayBhbmRcbiAgICAgIC8vIGZvcnRoIGZyb20gdGhlIHJlZiB0byB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG8gY2xvc2UuIFRoaXNcbiAgICAgIC8vIGVuc3VyZXMgaXQgYWx3YXlzIHJlbWFpbnMgb3BlbiBpbiB0aGF0IGNhc2UuXG4gICAgICBsZXQgcmVjdFBvbHkgPSBbXTtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWZSZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWZSZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlZlJlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UG9seWdvbihfcmVmMykge1xuICAgICAgICBsZXQgW3gsIHldID0gX3JlZjM7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcF0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3AgOiByZWN0LmJvdHRvbSAtIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC50b3AgKyBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbSA6IHJlY3QudG9wICsgYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5jb21tb25Qb2ludHMsIGN1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0ICsgYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCByZWN0UG9seSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xhbmRlZCAmJiAhaXNPdmVyUmVmZXJlbmNlUmVjdCkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZWF2ZSAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkID0gZ2V0Q3Vyc29yU3BlZWQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkVGhyZXNob2xkID0gMC4xO1xuICAgICAgICBpZiAoY3Vyc29yU3BlZWQgIT09IG51bGwgJiYgY3Vyc29yU3BlZWQgPCBjdXJzb3JTcGVlZFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBnZXRQb2x5Z29uKFt4LCB5XSkpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNMYW5kZWQgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChjbG9zZSwgNDApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBDb21wb3NpdGUsIENvbXBvc2l0ZUl0ZW0sIEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \********************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333• for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZsb2F0aW5nLXVpK3JlYWN0QDAuMjYuMTNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0VBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxRUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veW9vbS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AZmxvYXRpbmctdWkrcmVhY3RAMC4yNi4xM19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC51dGlscy5tanM/NGQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gYWN0aXZlRWxlbWVudChkb2MpIHtcbiAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKCgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSA9PSBudWxsIHx8IChfYWN0aXZlRWxlbWVudCA9IF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudC5hY3RpdmVFbGVtZW50KSAhPSBudWxsKSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50O1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmdldFJvb3ROb2RlKCk7XG5cbiAgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICBsZXQgbmV4dCA9IGNoaWxkO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAocGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyBBdm9pZCBDaHJvbWUgRGV2VG9vbHMgYmx1ZSB3YXJuaW5nLlxuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgYnJhbmQsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGJyYW5kICsgXCIvXCIgKyB2ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlL3JlYWN0LXNwZWN0cnVtL2Jsb2IvYjM1ZDVjMDJmZTkwMGJhZGNjZDBjZjFhOGYyM2JiNTkzNDE5ZjIzOC9wYWNrYWdlcy9AcmVhY3QtYXJpYS91dGlscy9zcmMvaXNWaXJ0dWFsRXZlbnQudHNcbmZ1bmN0aW9uIGlzVmlydHVhbENsaWNrKGV2ZW50KSB7XG4gIC8vIEZJWE1FOiBGaXJlZm94IGlzIG5vdyBlbWl0dGluZyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIGBtb3pJbnB1dFNvdXJjZWAuXG4gIC8vIFRyeSB0byBmaW5kIGEgd29ya2Fyb3VuZCBmb3IgdGhpcy4gYHJlYWN0LWFyaWFgIHNvdXJjZSBzdGlsbCBoYXMgdGhlIGNoZWNrLlxuICBpZiAoZXZlbnQubW96SW5wdXRTb3VyY2UgPT09IDAgJiYgZXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQW5kcm9pZCgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMTtcbiAgfVxuICByZXR1cm4gZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkge1xuICBpZiAoaXNKU0RPTSgpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAhaXNBbmRyb2lkKCkgJiYgZXZlbnQud2lkdGggPT09IDAgJiYgZXZlbnQuaGVpZ2h0ID09PSAwIHx8IGlzQW5kcm9pZCgpICYmIGV2ZW50LndpZHRoID09PSAxICYmIGV2ZW50LmhlaWdodCA9PT0gMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHxcbiAgLy8gaU9TIFZvaWNlT3ZlciByZXR1cm5zIDAuMzMz4oCiIGZvciB3aWR0aC9oZWlnaHQuXG4gIGV2ZW50LndpZHRoIDwgMSAmJiBldmVudC5oZWlnaHQgPCAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBDaHJvbWUgRGV2VG9vbHMgZG9lcyBub3QgY29tcGxhaW4gYWJvdXQgbmF2aWdhdG9yLnZlbmRvclxuICByZXR1cm4gL2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbn1cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgY29uc3QgcmUgPSAvYW5kcm9pZC9pO1xuICByZXR1cm4gcmUudGVzdChnZXRQbGF0Zm9ybSgpKSB8fCByZS50ZXN0KGdldFVzZXJBZ2VudCgpKTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gZ2V0UGxhdGZvcm0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21hYycpICYmICFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5mdW5jdGlvbiBpc0pTRE9NKCkge1xuICByZXR1cm4gZ2V0VXNlckFnZW50KCkuaW5jbHVkZXMoJ2pzZG9tLycpO1xufVxuZnVuY3Rpb24gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgc3RyaWN0KSB7XG4gIC8vIE9uIHNvbWUgTGludXggbWFjaGluZXMgd2l0aCBDaHJvbWl1bSwgbW91c2UgaW5wdXRzIHJldHVybiBhIGBwb2ludGVyVHlwZWBcbiAgLy8gb2YgXCJwZW5cIjogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMDE1XG4gIGNvbnN0IHZhbHVlcyA9IFsnbW91c2UnLCAncGVuJ107XG4gIGlmICghc3RyaWN0KSB7XG4gICAgdmFsdWVzLnB1c2goJycsIHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5pbmNsdWRlcyhwb2ludGVyVHlwZSk7XG59XG5mdW5jdGlvbiBpc1JlYWN0RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICduYXRpdmVFdmVudCcgaW4gZXZlbnQ7XG59XG5mdW5jdGlvbiBpc1Jvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcygnaHRtbCxib2R5Jyk7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChub2RlKSB7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5vd25lckRvY3VtZW50KSB8fCBkb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMobm9kZSk7XG4gIH1cblxuICAvLyBUUyB0aGlua3MgYGV2ZW50YCBpcyBvZiB0eXBlIG5ldmVyIGFzIGl0IGFzc3VtZXMgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY29tcG9zZWRQYXRoLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgZG9tIGRvbid0XG4gIGNvbnN0IGUgPSBldmVudDtcbiAgcmV0dXJuIGUudGFyZ2V0ICE9IG51bGwgJiYgbm9kZS5jb250YWlucyhlLnRhcmdldCk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0XG4gIC8vIGBjb21wb3NlZFBhdGgoKWAsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBET00gZG9uJ3QuXG4gIHJldHVybiBldmVudC50YXJnZXQ7XG59XG5jb25zdCBUWVBFQUJMRV9TRUxFQ1RPUiA9IFwiaW5wdXQ6bm90KFt0eXBlPSdoaWRkZW4nXSk6bm90KFtkaXNhYmxlZF0pLFwiICsgXCJbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT0nZmFsc2UnXSksdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCI7XG5mdW5jdGlvbiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQubWF0Y2hlcyhUWVBFQUJMRV9TRUxFQ1RPUik7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdjb21ib2JveCcgJiYgaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG5cbmV4cG9ydCB7IFRZUEVBQkxFX1NFTEVDVE9SLCBhY3RpdmVFbGVtZW50LCBjb250YWlucywgZ2V0RG9jdW1lbnQsIGdldFBsYXRmb3JtLCBnZXRUYXJnZXQsIGdldFVzZXJBZ2VudCwgaXNBbmRyb2lkLCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc0pTRE9NLCBpc01hYywgaXNNb3VzZUxpa2VQb2ludGVyVHlwZSwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc1NhZmFyaSwgaXNUeXBlYWJsZUNvbWJvYm94LCBpc1R5cGVhYmxlRWxlbWVudCwgaXNWaXJ0dWFsQ2xpY2ssIGlzVmlydHVhbFBvaW50ZXJFdmVudCwgc3RvcEV2ZW50IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@floating-ui+react@0.26.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ })

};
;